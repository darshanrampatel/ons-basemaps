var app = function () { "use strict"; function t() { } function e(t) { return t() } function i() { return Object.create(null) } function r(t) { t.forEach(e) } function n(t) { return "function" == typeof t } function a(t, e) { return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t } function o(t, e, i, r) { if (t) { const n = s(t, e, i, r); return t[0](n) } } function s(t, e, i, r) { return t[1] && r ? function (t, e) { for (const i in e) t[i] = e[i]; return t }(i.ctx.slice(), t[1](r(e))) : i.ctx } function l(t, e, i, r) { if (t[2] && r) { const n = t[2](r(i)); if (void 0 === e.dirty) return n; if ("object" == typeof n) { const t = [], i = Math.max(e.dirty.length, n.length); for (let r = 0; r < i; r += 1)t[r] = e.dirty[r] | n[r]; return t } return e.dirty | n } return e.dirty } function u(t, e, i, r, n, a) { if (n) { const o = s(e, i, r, a); t.p(o, n) } } function h(t) { if (t.ctx.length > 32) { const e = [], i = t.ctx.length / 32; for (let t = 0; t < i; t++)e[t] = -1; return e } return -1 } function c(t, e) { t.appendChild(e) } function p(t, e, i) { t.insertBefore(e, i || null) } function f(t) { t.parentNode && t.parentNode.removeChild(t) } function d(t, e) { for (let i = 0; i < t.length; i += 1)t[i] && t[i].d(e) } function m(t) { return document.createElement(t) } function y(t) { return document.createTextNode(t) } function g() { return y(" ") } function _(t, e, i, r) { return t.addEventListener(e, i, r), () => t.removeEventListener(e, i, r) } function v(t) { return function (e) { return e.preventDefault(), t.call(this, e) } } function x(t, e, i) { null == i ? t.removeAttribute(e) : t.getAttribute(e) !== i && t.setAttribute(e, i) } function b(t, e, i) { const r = new Set; for (let e = 0; e < t.length; e += 1)t[e].checked && r.add(t[e].__value); return i || r.delete(e), Array.from(r) } function w(t, e) { t.value = null == e ? "" : e } function M(t, e) { for (let i = 0; i < t.options.length; i += 1) { const r = t.options[i]; if (r.__value === e) return void (r.selected = !0) } t.selectedIndex = -1 } function S(t) { const e = t.querySelector(":checked") || t.options[0]; return e && e.__value } let E; function I(t) { E = t } function T(t) { (function () { if (!E) throw new Error("Function called outside component initialization"); return E })().$$.on_mount.push(t) } const A = [], P = [], C = [], z = [], k = Promise.resolve(); let L = !1; function D(t) { C.push(t) } function R(t) { z.push(t) } const B = new Set; let O = 0; function F() { const t = E; do { for (; O < A.length;) { const t = A[O]; O++, I(t), U(t.$$) } for (I(null), A.length = 0, O = 0; P.length;)P.pop()(); for (let t = 0; t < C.length; t += 1) { const e = C[t]; B.has(e) || (B.add(e), e()) } C.length = 0 } while (A.length); for (; z.length;)z.pop()(); L = !1, B.clear(), I(t) } function U(t) { if (null !== t.fragment) { t.update(), r(t.before_update); const e = t.dirty; t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(D) } } const N = new Set; let V; function j() { V = { r: 0, c: [], p: V } } function q() { V.r || r(V.c), V = V.p } function G(t, e) { t && t.i && (N.delete(t), t.i(e)) } function Z(t, e, i, r) { if (t && t.o) { if (N.has(t)) return; N.add(t), V.c.push((() => { N.delete(t), r && (i && t.d(1), r()) })), t.o(e) } else r && r() } function X(t, e, i) { const r = t.$$.props[e]; void 0 !== r && (t.$$.bound[r] = i, i(t.$$.ctx[r])) } function W(t) { t && t.c() } function K(t, i, a, o) { const { fragment: s, after_update: l } = t.$$; s && s.m(i, a), o || D((() => { const i = t.$$.on_mount.map(e).filter(n); t.$$.on_destroy ? t.$$.on_destroy.push(...i) : r(i), t.$$.on_mount = [] })), l.forEach(D) } function H(t, e) { const i = t.$$; null !== i.fragment && (r(i.on_destroy), i.fragment && i.fragment.d(e), i.on_destroy = i.fragment = null, i.ctx = []) } function $(t, e) { -1 === t.$$.dirty[0] && (A.push(t), L || (L = !0, k.then(F)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31 } function J(e, n, a, o, s, l, u, h = [-1]) { const c = E; I(e); const p = e.$$ = { fragment: null, ctx: [], props: l, update: t, not_equal: s, bound: i(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(n.context || (c ? c.$$.context : [])), callbacks: i(), dirty: h, skip_bound: !1, root: n.target || c.$$.root }; u && u(p.root); let d = !1; if (p.ctx = a ? a(e, n.props || {}, ((t, i, ...r) => { const n = r.length ? r[0] : i; return p.ctx && s(p.ctx[t], p.ctx[t] = n) && (!p.skip_bound && p.bound[t] && p.bound[t](n), d && $(e, t)), i })) : [], p.update(), d = !0, r(p.before_update), p.fragment = !!o && o(p.ctx), n.target) { if (n.hydrate) { const t = function (t) { return Array.from(t.childNodes) }(n.target); p.fragment && p.fragment.l(t), t.forEach(f) } else p.fragment && p.fragment.c(); n.intro && G(e.$$.fragment), K(e, n.target, n.anchor, n.customElement), F() } I(c) } class Y { $destroy() { H(this, 1), this.$destroy = t } $on(e, i) { if (!n(i)) return t; const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []); return r.push(i), () => { const t = r.indexOf(i); -1 !== t && r.splice(t, 1) } } $set(t) { var e; this.$$set && (e = t, 0 !== Object.keys(e).length) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1) } } var Q = 6378137, tt = .0066943799901413165, et = 484813681109536e-20, it = Math.PI / 2, rt = 1e-10, nt = .017453292519943295, at = 57.29577951308232, ot = Math.PI / 4, st = 2 * Math.PI, lt = 3.14159265359, ut = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 }, ht = { ft: { to_meter: .3048 }, "us-ft": { to_meter: 1200 / 3937 } }, ct = /[\s_\-\/\(\)]/g; function pt(t, e) { if (t[e]) return t[e]; for (var i, r = Object.keys(t), n = e.toLowerCase().replace(ct, ""), a = -1; ++a < r.length;)if ((i = r[a]).toLowerCase().replace(ct, "") === n) return t[i] } function ft(t) { var e, i, r, n = {}, a = t.split("+").map((function (t) { return t.trim() })).filter((function (t) { return t })).reduce((function (t, e) { var i = e.split("="); return i.push(!0), t[i[0].toLowerCase()] = i[1], t }), {}), o = { proj: "projName", datum: "datumCode", rf: function (t) { n.rf = parseFloat(t) }, lat_0: function (t) { n.lat0 = t * nt }, lat_1: function (t) { n.lat1 = t * nt }, lat_2: function (t) { n.lat2 = t * nt }, lat_ts: function (t) { n.lat_ts = t * nt }, lon_0: function (t) { n.long0 = t * nt }, lon_1: function (t) { n.long1 = t * nt }, lon_2: function (t) { n.long2 = t * nt }, alpha: function (t) { n.alpha = parseFloat(t) * nt }, lonc: function (t) { n.longc = t * nt }, x_0: function (t) { n.x0 = parseFloat(t) }, y_0: function (t) { n.y0 = parseFloat(t) }, k_0: function (t) { n.k0 = parseFloat(t) }, k: function (t) { n.k0 = parseFloat(t) }, a: function (t) { n.a = parseFloat(t) }, b: function (t) { n.b = parseFloat(t) }, r_a: function () { n.R_A = !0 }, zone: function (t) { n.zone = parseInt(t, 10) }, south: function () { n.utmSouth = !0 }, towgs84: function (t) { n.datum_params = t.split(",").map((function (t) { return parseFloat(t) })) }, to_meter: function (t) { n.to_meter = parseFloat(t) }, units: function (t) { n.units = t; var e = pt(ht, t); e && (n.to_meter = e.to_meter) }, from_greenwich: function (t) { n.from_greenwich = t * nt }, pm: function (t) { var e = pt(ut, t); n.from_greenwich = (e || parseFloat(t)) * nt }, nadgrids: function (t) { "@null" === t ? n.datumCode = "none" : n.nadgrids = t }, axis: function (t) { var e = "ewnsud"; 3 === t.length && -1 !== e.indexOf(t.substr(0, 1)) && -1 !== e.indexOf(t.substr(1, 1)) && -1 !== e.indexOf(t.substr(2, 1)) && (n.axis = t) }, approx: function () { n.approx = !0 } }; for (e in a) i = a[e], e in o ? "function" == typeof (r = o[e]) ? r(i) : n[r] = i : n[e] = i; return "string" == typeof n.datumCode && "WGS84" !== n.datumCode && (n.datumCode = n.datumCode.toLowerCase()), n } var dt = /\s/, mt = /[A-Za-z]/, yt = /[A-Za-z84]/, gt = /[,\]]/, _t = /[\d\.E\-\+]/; function vt(t) { if ("string" != typeof t) throw new Error("not a string"); this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = 1 } function xt(t, e, i) { Array.isArray(e) && (i.unshift(e), e = null); var r = e ? {} : t, n = i.reduce((function (t, e) { return bt(e, t), t }), r); e && (t[e] = n) } function bt(t, e) { if (Array.isArray(t)) { var i = t.shift(); if ("PARAMETER" === i && (i = t.shift()), 1 === t.length) return Array.isArray(t[0]) ? (e[i] = {}, void bt(t[0], e[i])) : void (e[i] = t[0]); if (t.length) if ("TOWGS84" !== i) { if ("AXIS" === i) return i in e || (e[i] = []), void e[i].push(t); var r; switch (Array.isArray(i) || (e[i] = {}), i) { case "UNIT": case "PRIMEM": case "VERT_DATUM": return e[i] = { name: t[0].toLowerCase(), convert: t[1] }, void (3 === t.length && bt(t[2], e[i])); case "SPHEROID": case "ELLIPSOID": return e[i] = { name: t[0], a: t[1], rf: t[2] }, void (4 === t.length && bt(t[3], e[i])); case "PROJECTEDCRS": case "PROJCRS": case "GEOGCS": case "GEOCCS": case "PROJCS": case "LOCAL_CS": case "GEODCRS": case "GEODETICCRS": case "GEODETICDATUM": case "EDATUM": case "ENGINEERINGDATUM": case "VERT_CS": case "VERTCRS": case "VERTICALCRS": case "COMPD_CS": case "COMPOUNDCRS": case "ENGINEERINGCRS": case "ENGCRS": case "FITTED_CS": case "LOCAL_DATUM": case "DATUM": return t[0] = ["name", t[0]], void xt(e, i, t); default: for (r = -1; ++r < t.length;)if (!Array.isArray(t[r])) return bt(t, e[i]); return xt(e, i, t) } } else e[i] = t; else e[i] = !0 } else e[t] = !0 } vt.prototype.readCharicter = function () { var t = this.text[this.place++]; if (4 !== this.state) for (; dt.test(t);) { if (this.place >= this.text.length) return; t = this.text[this.place++] } switch (this.state) { case 1: return this.neutral(t); case 2: return this.keyword(t); case 4: return this.quoted(t); case 5: return this.afterquote(t); case 3: return this.number(t); case -1: return } }, vt.prototype.afterquote = function (t) { if ('"' === t) return this.word += '"', void (this.state = 4); if (gt.test(t)) return this.word = this.word.trim(), void this.afterItem(t); throw new Error("havn't handled \"" + t + '" in afterquote yet, index ' + this.place) }, vt.prototype.afterItem = function (t) { return "," === t ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = 1)) : "]" === t ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = 1, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0 }, vt.prototype.number = function (t) { if (!_t.test(t)) { if (gt.test(t)) return this.word = parseFloat(this.word), void this.afterItem(t); throw new Error("havn't handled \"" + t + '" in number yet, index ' + this.place) } this.word += t }, vt.prototype.quoted = function (t) { '"' !== t ? this.word += t : this.state = 5 }, vt.prototype.keyword = function (t) { if (yt.test(t)) this.word += t; else { if ("[" === t) { var e = []; return e.push(this.word), this.level++, null === this.root ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, void (this.state = 1) } if (!gt.test(t)) throw new Error("havn't handled \"" + t + '" in keyword yet, index ' + this.place); this.afterItem(t) } }, vt.prototype.neutral = function (t) { if (mt.test(t)) return this.word = t, void (this.state = 2); if ('"' === t) return this.word = "", void (this.state = 4); if (_t.test(t)) return this.word = t, void (this.state = 3); if (!gt.test(t)) throw new Error("havn't handled \"" + t + '" in neutral yet, index ' + this.place); this.afterItem(t) }, vt.prototype.output = function () { for (; this.place < this.text.length;)this.readCharicter(); if (-1 === this.state) return this.root; throw new Error('unable to parse string "' + this.text + '". State is ' + this.state) }; function wt(t) { return .017453292519943295 * t } function Mt(t) { var e = new vt(t).output(), i = e.shift(), r = e.shift(); e.unshift(["name", r]), e.unshift(["type", i]); var n = {}; return bt(e, n), function (t) { if ("GEOGCS" === t.type ? t.projName = "longlat" : "LOCAL_CS" === t.type ? (t.projName = "identity", t.local = !0) : "object" == typeof t.PROJECTION ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) { for (var e = "", i = 0, r = t.AXIS.length; i < r; ++i) { var n = t.AXIS[i][0].toLowerCase(); -1 !== n.indexOf("north") ? e += "n" : -1 !== n.indexOf("south") ? e += "s" : -1 !== n.indexOf("east") ? e += "e" : -1 !== n.indexOf("west") && (e += "w") } 2 === e.length && (e += "u"), 3 === e.length && (t.axis = e) } t.UNIT && (t.units = t.UNIT.name.toLowerCase(), "metre" === t.units && (t.units = "meter"), t.UNIT.convert && ("GEOGCS" === t.type ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert)); var a = t.GEOGCS; function o(e) { return e * (t.to_meter || 1) } "GEOGCS" === t.type && (a = t), a && (a.DATUM ? t.datumCode = a.DATUM.name.toLowerCase() : t.datumCode = a.name.toLowerCase(), "d_" === t.datumCode.slice(0, 2) && (t.datumCode = t.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t.datumCode && "new_zealand_1949" !== t.datumCode || (t.datumCode = "nzgd49"), "wgs_1984" !== t.datumCode && "world_geodetic_system_1984" !== t.datumCode || ("Mercator_Auxiliary_Sphere" === t.PROJECTION && (t.sphere = !0), t.datumCode = "wgs84"), "_ferro" === t.datumCode.slice(-6) && (t.datumCode = t.datumCode.slice(0, -6)), "_jakarta" === t.datumCode.slice(-8) && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), a.DATUM && a.DATUM.SPHEROID && (t.ellps = a.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t.ellps.toLowerCase().slice(0, 13) && (t.ellps = "intl"), t.a = a.DATUM.SPHEROID.a, t.rf = parseFloat(a.DATUM.SPHEROID.rf, 10)), a.DATUM && a.DATUM.TOWGS84 && (t.datum_params = a.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), "ch1903+" === t.datumCode && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a), [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_2", "Standard_Parallel_2"], ["false_easting", "False_Easting"], ["false_northing", "False_Northing"], ["central_meridian", "Central_Meridian"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", wt], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", wt], ["x0", "false_easting", o], ["y0", "false_northing", o], ["long0", "central_meridian", wt], ["lat0", "latitude_of_origin", wt], ["lat0", "standard_parallel_1", wt], ["lat1", "standard_parallel_1", wt], ["lat2", "standard_parallel_2", wt], ["azimuth", "Azimuth"], ["alpha", "azimuth", wt], ["srsCode", "name"]].forEach((function (e) { return function (t, e) { var i = e[0], r = e[1]; !(i in t) && r in t && (t[i] = t[r], 3 === e.length && (t[i] = e[2](t[i]))) }(t, e) })), t.long0 || !t.longc || "Albers_Conic_Equal_Area" !== t.projName && "Lambert_Azimuthal_Equal_Area" !== t.projName || (t.long0 = t.longc), t.lat_ts || !t.lat1 || "Stereographic_South_Pole" !== t.projName && "Polar Stereographic (variant B)" !== t.projName || (t.lat0 = wt(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1) }(n), n } function St(t) { var e = this; if (2 === arguments.length) { var i = arguments[1]; "string" == typeof i ? "+" === i.charAt(0) ? St[t] = ft(arguments[1]) : St[t] = Mt(arguments[1]) : St[t] = i } else if (1 === arguments.length) { if (Array.isArray(t)) return t.map((function (t) { Array.isArray(t) ? St.apply(e, t) : St(t) })); if ("string" == typeof t) { if (t in St) return St[t] } else "EPSG" in t ? St["EPSG:" + t.EPSG] = t : "ESRI" in t ? St["ESRI:" + t.ESRI] = t : "IAU2000" in t ? St["IAU2000:" + t.IAU2000] = t : console.log(t); return } } !function (t) { t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"] }(St); var Et = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"]; var It = ["3857", "900913", "3785", "102113"]; function Tt(t) { if (!function (t) { return "string" == typeof t }(t)) return t; if (function (t) { return t in St }(t)) return St[t]; if (function (t) { return Et.some((function (e) { return t.indexOf(e) > -1 })) }(t)) { var e = Mt(t); if (function (t) { var e = pt(t, "authority"); if (e) { var i = pt(e, "epsg"); return i && It.indexOf(i) > -1 } }(e)) return St["EPSG:3857"]; var i = function (t) { var e = pt(t, "extension"); if (e) return pt(e, "proj4") }(e); return i ? ft(i) : e } return function (t) { return "+" === t[0] }(t) ? ft(t) : void 0 } function At(t, e) { var i, r; if (t = t || {}, !e) return t; for (r in e) void 0 !== (i = e[r]) && (t[r] = i); return t } function Pt(t, e, i) { var r = t * e; return i / Math.sqrt(1 - r * r) } function Ct(t) { return t < 0 ? -1 : 1 } function zt(t) { return Math.abs(t) <= lt ? t : t - Ct(t) * st } function kt(t, e, i) { var r = t * i, n = .5 * t; return r = Math.pow((1 - r) / (1 + r), n), Math.tan(.5 * (it - e)) / r } function Lt(t, e) { for (var i, r, n = .5 * t, a = it - 2 * Math.atan(e), o = 0; o <= 15; o++)if (i = t * Math.sin(a), a += r = it - 2 * Math.atan(e * Math.pow((1 - i) / (1 + i), n)) - a, Math.abs(r) <= 1e-10) return a; return -9999 } function Dt(t) { return t } var Rt = [{ init: function () { var t = this.b / this.a; this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Pt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1) }, forward: function (t) { var e, i, r = t.x, n = t.y; if (n * at > 90 && n * at < -90 && r * at > 180 && r * at < -180) return null; if (Math.abs(Math.abs(n) - it) <= rt) return null; if (this.sphere) e = this.x0 + this.a * this.k0 * zt(r - this.long0), i = this.y0 + this.a * this.k0 * Math.log(Math.tan(ot + .5 * n)); else { var a = Math.sin(n), o = kt(this.e, n, a); e = this.x0 + this.a * this.k0 * zt(r - this.long0), i = this.y0 - this.a * this.k0 * Math.log(o) } return t.x = e, t.y = i, t }, inverse: function (t) { var e, i, r = t.x - this.x0, n = t.y - this.y0; if (this.sphere) i = it - 2 * Math.atan(Math.exp(-n / (this.a * this.k0))); else { var a = Math.exp(-n / (this.a * this.k0)); if (-9999 === (i = Lt(this.e, a))) return null } return e = zt(this.long0 + r / (this.a * this.k0)), t.x = e, t.y = i, t }, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"] }, { init: function () { }, forward: Dt, inverse: Dt, names: ["longlat", "identity"] }], Bt = {}, Ot = []; function Ft(t, e) { var i = Ot.length; return t.names ? (Ot[i] = t, t.names.forEach((function (t) { Bt[t.toLowerCase()] = i })), this) : (console.log(e), !0) } var Ut = { start: function () { Rt.forEach(Ft) }, add: Ft, get: function (t) { if (!t) return !1; var e = t.toLowerCase(); return void 0 !== Bt[e] && Ot[Bt[e]] ? Ot[Bt[e]] : void 0 } }, Nt = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy" }, andrae: { a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk58: { a: 6378293.645208759, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 6355834.8467, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" } }, Vt = Nt.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" }; Nt.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" }; var jt = {}; jt.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, jt.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, jt.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, jt.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, jt.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, jt.potsdam = { towgs84: "606.0,23.0,413.0", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, jt.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, jt.hermannskogel = { towgs84: "653.0,-212.0,449.0", ellipse: "bessel", datumName: "Hermannskogel" }, jt.osni52 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, jt.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, jt.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, jt.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, jt.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, jt.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, jt.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, jt.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, jt.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" }; var qt = {}; function Gt(t) { if (0 === t.length) return null; var e = "@" === t[0]; return e && (t = t.slice(1)), "null" === t ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : { name: t, mandatory: !e, grid: qt[t] || null, isNull: !1 } } function Zt(t) { return t / 3600 * Math.PI / 180 } function Xt(t, e, i) { return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, i))) } function Wt(t) { return t.map((function (t) { return [Zt(t.longitudeShift), Zt(t.latitudeShift)] })) } function Kt(t, e, i) { return { name: Xt(t, e + 8, e + 16).trim(), parent: Xt(t, e + 24, e + 24 + 8).trim(), lowerLatitude: t.getFloat64(e + 72, i), upperLatitude: t.getFloat64(e + 88, i), lowerLongitude: t.getFloat64(e + 104, i), upperLongitude: t.getFloat64(e + 120, i), latitudeInterval: t.getFloat64(e + 136, i), longitudeInterval: t.getFloat64(e + 152, i), gridNodeCount: t.getInt32(e + 168, i) } } function Ht(t, e, i, r) { for (var n = e + 176, a = [], o = 0; o < i.gridNodeCount; o++) { var s = { latitudeShift: t.getFloat32(n + 16 * o, r), longitudeShift: t.getFloat32(n + 16 * o + 4, r), latitudeAccuracy: t.getFloat32(n + 16 * o + 8, r), longitudeAccuracy: t.getFloat32(n + 16 * o + 12, r) }; a.push(s) } return a } function $t(t, e) { if (!(this instanceof $t)) return new $t(t); e = e || function (t) { if (t) throw t }; var i = Tt(t); if ("object" == typeof i) { var r = $t.projections.get(i.projName); if (r) { if (i.datumCode && "none" !== i.datumCode) { var n = pt(jt, i.datumCode); n && (i.datum_params = n.towgs84 ? n.towgs84.split(",") : null, i.ellps = n.ellipse, i.datumName = n.datumName ? n.datumName : i.datumCode) } i.k0 = i.k0 || 1, i.axis = i.axis || "enu", i.ellps = i.ellps || "wgs84"; var a, o, s, l, u, h, c, p = function (t, e, i, r, n) { if (!t) { var a = pt(Nt, r); a || (a = Vt), t = a.a, e = a.b, i = a.rf } return i && !e && (e = (1 - 1 / i) * t), (0 === i || Math.abs(t - e) < rt) && (n = !0, e = t), { a: t, b: e, rf: i, sphere: n } }(i.a, i.b, i.rf, i.ellps, i.sphere), f = (a = p.a, o = p.b, p.rf, s = i.R_A, h = ((l = a * a) - (u = o * o)) / l, c = 0, s ? (l = (a *= 1 - h * (.16666666666666666 + h * (.04722222222222222 + .022156084656084655 * h))) * a, h = 0) : c = Math.sqrt(h), { es: h, e: c, ep2: (l - u) / u }), d = function (t) { return void 0 === t ? null : t.split(",").map(Gt) }(i.nadgrids), m = i.datum || function (t, e, i, r, n, a, o) { var s = {}; return s.datum_type = void 0 === t || "none" === t ? 5 : 4, e && (s.datum_params = e.map(parseFloat), 0 === s.datum_params[0] && 0 === s.datum_params[1] && 0 === s.datum_params[2] || (s.datum_type = 1), s.datum_params.length > 3 && (0 === s.datum_params[3] && 0 === s.datum_params[4] && 0 === s.datum_params[5] && 0 === s.datum_params[6] || (s.datum_type = 2, s.datum_params[3] *= et, s.datum_params[4] *= et, s.datum_params[5] *= et, s.datum_params[6] = s.datum_params[6] / 1e6 + 1))), o && (s.datum_type = 3, s.grids = o), s.a = i, s.b = r, s.es = n, s.ep2 = a, s }(i.datumCode, i.datum_params, p.a, p.b, f.es, f.ep2, d); At(this, i), At(this, r), this.a = p.a, this.b = p.b, this.rf = p.rf, this.sphere = p.sphere, this.es = f.es, this.e = f.e, this.ep2 = f.ep2, this.datum = m, this.init(), e(null, this) } else e(t) } else e(t) } function Jt(t, e, i) { var r, n, a, o, s = t.x, l = t.y, u = t.z ? t.z : 0; if (l < -it && l > -1.001 * it) l = -it; else if (l > it && l < 1.001 * it) l = it; else { if (l < -it) return { x: -1 / 0, y: -1 / 0, z: t.z }; if (l > it) return { x: 1 / 0, y: 1 / 0, z: t.z } } return s > Math.PI && (s -= 2 * Math.PI), n = Math.sin(l), o = Math.cos(l), a = n * n, { x: ((r = i / Math.sqrt(1 - e * a)) + u) * o * Math.cos(s), y: (r + u) * o * Math.sin(s), z: (r * (1 - e) + u) * n } } function Yt(t, e, i, r) { var n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v = 1e-12, x = t.x, b = t.y, w = t.z ? t.z : 0; if (n = Math.sqrt(x * x + b * b), a = Math.sqrt(x * x + b * b + w * w), n / i < v) { if (g = 0, a / i < v) return it, _ = -r, { x: t.x, y: t.y, z: t.z } } else g = Math.atan2(b, x); o = w / a, c = (s = n / a) * (1 - e) * (l = 1 / Math.sqrt(1 - e * (2 - e) * s * s)), p = o * l, y = 0; do { y++, u = e * (h = i / Math.sqrt(1 - e * p * p)) / (h + (_ = n * c + w * p - h * (1 - e * p * p))), m = (d = o * (l = 1 / Math.sqrt(1 - u * (2 - u) * s * s))) * c - (f = s * (1 - u) * l) * p, c = f, p = d } while (m * m > 1e-24 && y < 30); return { x: g, y: Math.atan(d / Math.abs(f)), z: _ } } function Qt(t) { return 1 === t || 2 === t } function te(t, e, i) { if (function (t, e) { return t.datum_type === e.datum_type && !(t.a !== e.a || Math.abs(t.es - e.es) > 5e-11) && (1 === t.datum_type ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : 2 !== t.datum_type || t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6]) }(t, e)) return i; if (5 === t.datum_type || 5 === e.datum_type) return i; var r = t.a, n = t.es; if (3 === t.datum_type) { if (0 !== ee(t, !1, i)) return; r = Q, n = tt } var a = e.a, o = e.b, s = e.es; if (3 === e.datum_type && (a = Q, o = 6356752.314, s = tt), n === s && r === a && !Qt(t.datum_type) && !Qt(e.datum_type)) return i; if ((i = Jt(i, n, r), Qt(t.datum_type) && (i = function (t, e, i) { if (1 === e) return { x: t.x + i[0], y: t.y + i[1], z: t.z + i[2] }; if (2 === e) { var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], u = i[6]; return { x: u * (t.x - l * t.y + s * t.z) + r, y: u * (l * t.x + t.y - o * t.z) + n, z: u * (-s * t.x + o * t.y + t.z) + a } } }(i, t.datum_type, t.datum_params)), Qt(e.datum_type) && (i = function (t, e, i) { if (1 === e) return { x: t.x - i[0], y: t.y - i[1], z: t.z - i[2] }; if (2 === e) { var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], u = i[6], h = (t.x - r) / u, c = (t.y - n) / u, p = (t.z - a) / u; return { x: h + l * c - s * p, y: -l * h + c + o * p, z: s * h - o * c + p } } }(i, e.datum_type, e.datum_params)), i = Yt(i, s, a, o), 3 === e.datum_type) && 0 !== ee(e, !0, i)) return; return i } function ee(t, e, i) { if (null === t.grids || 0 === t.grids.length) return console.log("Grid shift grids not found"), -1; for (var r = { x: -i.x, y: i.y }, n = { x: Number.NaN, y: Number.NaN }, a = [], o = 0; o < t.grids.length; o++) { var s = t.grids[o]; if (a.push(s.name), s.isNull) { n = r; break } if (s.mandatory, null !== s.grid) { var l = s.grid.subgrids[0], u = (Math.abs(l.del[1]) + Math.abs(l.del[0])) / 1e4, h = l.ll[0] - u, c = l.ll[1] - u, p = l.ll[0] + (l.lim[0] - 1) * l.del[0] + u, f = l.ll[1] + (l.lim[1] - 1) * l.del[1] + u; if (!(c > r.y || h > r.x || f < r.y || p < r.x || (n = ie(r, e, l), isNaN(n.x)))) break } else if (s.mandatory) return console.log("Unable to find mandatory grid '" + s.name + "'"), -1 } return isNaN(n.x) ? (console.log("Failed to find a grid shift table for location '" + -r.x * at + " " + r.y * at + " tried: '" + a + "'"), -1) : (i.x = -n.x, i.y = n.y, 0) } function ie(t, e, i) { var r = { x: Number.NaN, y: Number.NaN }; if (isNaN(t.x)) return r; var n = { x: t.x, y: t.y }; n.x -= i.ll[0], n.y -= i.ll[1], n.x = zt(n.x - Math.PI) + Math.PI; var a = re(n, i); if (e) { if (isNaN(a.x)) return r; a.x = n.x - a.x, a.y = n.y - a.y; var o, s, l = 9; do { if (s = re(a, i), isNaN(s.x)) { console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation."); break } o = { x: n.x - (s.x + a.x), y: n.y - (s.y + a.y) }, a.x += o.x, a.y += o.y } while (l-- && Math.abs(o.x) > 1e-12 && Math.abs(o.y) > 1e-12); if (l < 0) return console.log("Inverse grid shift iterator failed to converge."), r; r.x = zt(a.x + i.ll[0]), r.y = a.y + i.ll[1] } else isNaN(a.x) || (r.x = t.x + a.x, r.y = t.y + a.y); return r } function re(t, e) { var i, r = { x: t.x / e.del[0], y: t.y / e.del[1] }, n = Math.floor(r.x), a = Math.floor(r.y), o = r.x - 1 * n, s = r.y - 1 * a, l = { x: Number.NaN, y: Number.NaN }; if (n < 0 || n >= e.lim[0]) return l; if (a < 0 || a >= e.lim[1]) return l; i = a * e.lim[0] + n; var u = e.cvs[i][0], h = e.cvs[i][1]; i++; var c = e.cvs[i][0], p = e.cvs[i][1]; i += e.lim[0]; var f = e.cvs[i][0], d = e.cvs[i][1]; i--; var m = e.cvs[i][0], y = e.cvs[i][1], g = o * s, _ = o * (1 - s), v = (1 - o) * (1 - s), x = (1 - o) * s; return l.x = v * u + _ * c + x * m + g * f, l.y = v * h + _ * p + x * y + g * d, l } function ne(t, e, i) { var r, n, a, o = i.x, s = i.y, l = i.z || 0, u = {}; for (a = 0; a < 3; a++)if (!e || 2 !== a || void 0 !== i.z) switch (0 === a ? (r = o, n = -1 !== "ew".indexOf(t.axis[a]) ? "x" : "y") : 1 === a ? (r = s, n = -1 !== "ns".indexOf(t.axis[a]) ? "y" : "x") : (r = l, n = "z"), t.axis[a]) { case "e": u[n] = r; break; case "w": u[n] = -r; break; case "n": u[n] = r; break; case "s": u[n] = -r; break; case "u": void 0 !== i[n] && (u.z = r); break; case "d": void 0 !== i[n] && (u.z = -r); break; default: return null }return u } function ae(t) { var e = { x: t[0], y: t[1] }; return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e } function oe(t) { if ("function" == typeof Number.isFinite) { if (Number.isFinite(t)) return; throw new TypeError("coordinates must be finite numbers") } if ("number" != typeof t || t != t || !isFinite(t)) throw new TypeError("coordinates must be finite numbers") } function se(t, e, i) { var r; if (Array.isArray(i) && (i = ae(i)), function (t) { oe(t.x), oe(t.y) }(i), t.datum && e.datum && function (t, e) { return (1 === t.datum.datum_type || 2 === t.datum.datum_type) && "WGS84" !== e.datumCode || (1 === e.datum.datum_type || 2 === e.datum.datum_type) && "WGS84" !== t.datumCode }(t, e) && (i = se(t, r = new $t("WGS84"), i), t = r), "enu" !== t.axis && (i = ne(t, !1, i)), "longlat" === t.projName) i = { x: i.x * nt, y: i.y * nt, z: i.z || 0 }; else if (t.to_meter && (i = { x: i.x * t.to_meter, y: i.y * t.to_meter, z: i.z || 0 }), !(i = t.inverse(i))) return; if (t.from_greenwich && (i.x += t.from_greenwich), i = te(t.datum, e.datum, i)) return e.from_greenwich && (i = { x: i.x - e.from_greenwich, y: i.y, z: i.z || 0 }), "longlat" === e.projName ? i = { x: i.x * at, y: i.y * at, z: i.z || 0 } : (i = e.forward(i), e.to_meter && (i = { x: i.x / e.to_meter, y: i.y / e.to_meter, z: i.z || 0 })), "enu" !== e.axis ? ne(e, !0, i) : i } $t.projections = Ut, $t.projections.start(); var le = $t("WGS84"); function ue(t, e, i) { var r, n, a; return Array.isArray(i) ? (r = se(t, e, i) || { x: NaN, y: NaN }, i.length > 2 ? void 0 !== t.name && "geocent" === t.name || void 0 !== e.name && "geocent" === e.name ? "number" == typeof r.z ? [r.x, r.y, r.z].concat(i.splice(3)) : [r.x, r.y, i[2]].concat(i.splice(3)) : [r.x, r.y].concat(i.splice(2)) : [r.x, r.y]) : (n = se(t, e, i), 2 === (a = Object.keys(i)).length || a.forEach((function (r) { if (void 0 !== t.name && "geocent" === t.name || void 0 !== e.name && "geocent" === e.name) { if ("x" === r || "y" === r || "z" === r) return } else if ("x" === r || "y" === r) return; n[r] = i[r] })), n) } function he(t) { return t instanceof $t ? t : t.oProj ? t.oProj : $t(t) } function ce(t, e, i) { t = he(t); var r, n = !1; return void 0 === e ? (e = t, t = le, n = !0) : (void 0 !== e.x || Array.isArray(e)) && (i = e, e = t, t = le, n = !0), e = he(e), i ? ue(t, e, i) : (r = { forward: function (i) { return ue(t, e, i) }, inverse: function (i) { return ue(e, t, i) } }, n && (r.oProj = e), r) } var pe = "AJSAJS", fe = "AFAFAF", de = 65, me = 73, ye = 79, ge = 86, _e = 90, ve = { forward: xe, inverse: function (t) { var e = Se(Te(t.toUpperCase())); if (e.lat && e.lon) return [e.lon, e.lat, e.lon, e.lat]; return [e.left, e.bottom, e.right, e.top] }, toPoint: be }; function xe(t, e) { return e = e || 5, function (t, e) { var i = "00000" + t.easting, r = "00000" + t.northing; return t.zoneNumber + t.zoneLetter + (f = t.easting, d = t.northing, m = t.zoneNumber, y = Ie(m), g = Math.floor(f / 1e5), _ = Math.floor(d / 1e5) % 20, n = g, a = _, o = y, s = o - 1, l = pe.charCodeAt(s), u = fe.charCodeAt(s), h = l + n - 1, c = u + a, p = !1, h > _e && (h = h - _e + de - 1, p = !0), (h === me || l < me && h > me || (h > me || l < me) && p) && h++, (h === ye || l < ye && h > ye || (h > ye || l < ye) && p) && ++h === me && h++, h > _e && (h = h - _e + de - 1), c > ge ? (c = c - ge + de - 1, p = !0) : p = !1, (c === me || u < me && c > me || (c > me || u < me) && p) && c++, (c === ye || u < ye && c > ye || (c > ye || u < ye) && p) && ++c === me && c++, c > ge && (c = c - ge + de - 1), String.fromCharCode(h) + String.fromCharCode(c)) + i.substr(i.length - 5, e) + r.substr(r.length - 5, e); var n, a, o, s, l, u, h, c, p; var f, d, m, y, g, _ }(function (t) { var e, i, r, n, a, o, s, l, u = t.lat, h = t.lon, c = 6378137, p = .00669438, f = .9996, d = we(u), m = we(h); l = Math.floor((h + 180) / 6) + 1, 180 === h && (l = 60); u >= 56 && u < 64 && h >= 3 && h < 12 && (l = 32); u >= 72 && u < 84 && (h >= 0 && h < 9 ? l = 31 : h >= 9 && h < 21 ? l = 33 : h >= 21 && h < 33 ? l = 35 : h >= 33 && h < 42 && (l = 37)); s = we(6 * (l - 1) - 180 + 3), e = p / (1 - p), i = c / Math.sqrt(1 - p * Math.sin(d) * Math.sin(d)), r = Math.tan(d) * Math.tan(d), n = e * Math.cos(d) * Math.cos(d), a = Math.cos(d) * (m - s), o = c * ((1 - p / 4 - 3 * p * p / 64 - 5 * p * p * p / 256) * d - (3 * p / 8 + 3 * p * p / 32 + 45 * p * p * p / 1024) * Math.sin(2 * d) + (15 * p * p / 256 + 45 * p * p * p / 1024) * Math.sin(4 * d) - 35 * p * p * p / 3072 * Math.sin(6 * d)); var y = f * i * (a + (1 - r + n) * a * a * a / 6 + (5 - 18 * r + r * r + 72 * n - 58 * e) * a * a * a * a * a / 120) + 5e5, g = f * (o + i * Math.tan(d) * (a * a / 2 + (5 - r + 9 * n + 4 * n * n) * a * a * a * a / 24 + (61 - 58 * r + r * r + 600 * n - 330 * e) * a * a * a * a * a * a / 720)); u < 0 && (g += 1e7); return { northing: Math.round(g), easting: Math.round(y), zoneNumber: l, zoneLetter: Ee(u) } }({ lat: t[1], lon: t[0] }), e) } function be(t) { var e = Se(Te(t.toUpperCase())); return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2] } function we(t) { return t * (Math.PI / 180) } function Me(t) { return t / Math.PI * 180 } function Se(t) { var e = t.northing, i = t.easting, r = t.zoneLetter, n = t.zoneNumber; if (n < 0 || n > 60) return null; var a, o, s, l, u, h, c, p, f, d = .9996, m = 6378137, y = .00669438, g = (1 - Math.sqrt(.99330562)) / (1 + Math.sqrt(.99330562)), _ = i - 5e5, v = e; r < "N" && (v -= 1e7), c = 6 * (n - 1) - 180 + 3, a = .006739496752268451, f = (p = v / d / 6367449.145945056) + (3 * g / 2 - 27 * g * g * g / 32) * Math.sin(2 * p) + (21 * g * g / 16 - 55 * g * g * g * g / 32) * Math.sin(4 * p) + 151 * g * g * g / 96 * Math.sin(6 * p), o = m / Math.sqrt(1 - y * Math.sin(f) * Math.sin(f)), s = Math.tan(f) * Math.tan(f), l = a * Math.cos(f) * Math.cos(f), u = .99330562 * m / Math.pow(1 - y * Math.sin(f) * Math.sin(f), 1.5), h = _ / (o * d); var x = f - o * Math.tan(f) / u * (h * h / 2 - (5 + 3 * s + 10 * l - 4 * l * l - 9 * a) * h * h * h * h / 24 + (61 + 90 * s + 298 * l + 45 * s * s - 1.6983531815716497 - 3 * l * l) * h * h * h * h * h * h / 720); x = Me(x); var b, w = (h - (1 + 2 * s + l) * h * h * h / 6 + (5 - 2 * l + 28 * s - 3 * l * l + 8 * a + 24 * s * s) * h * h * h * h * h / 120) / Math.cos(f); if (w = c + Me(w), t.accuracy) { var M = Se({ northing: t.northing + t.accuracy, easting: t.easting + t.accuracy, zoneLetter: t.zoneLetter, zoneNumber: t.zoneNumber }); b = { top: M.lat, right: M.lon, bottom: x, left: w } } else b = { lat: x, lon: w }; return b } function Ee(t) { var e = "Z"; return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e } function Ie(t) { var e = t % 6; return 0 === e && (e = 6), e } function Te(t) { if (t && 0 === t.length) throw "MGRSPoint coverting from nothing"; for (var e, i = t.length, r = null, n = "", a = 0; !/[A-Z]/.test(e = t.charAt(a));) { if (a >= 2) throw "MGRSPoint bad conversion from: " + t; n += e, a++ } var o = parseInt(n, 10); if (0 === a || a + 3 > i) throw "MGRSPoint bad conversion from: " + t; var s = t.charAt(a++); if (s <= "A" || "B" === s || "Y" === s || s >= "Z" || "I" === s || "O" === s) throw "MGRSPoint zone letter " + s + " not handled: " + t; r = t.substring(a, a += 2); for (var l = Ie(o), u = function (t, e) { var i = pe.charCodeAt(e - 1), r = 1e5, n = !1; for (; i !== t.charCodeAt(0);) { if (++i === me && i++, i === ye && i++, i > _e) { if (n) throw "Bad character: " + t; i = de, n = !0 } r += 1e5 } return r }(r.charAt(0), l), h = function (t, e) { if (t > "V") throw "MGRSPoint given invalid Northing " + t; var i = fe.charCodeAt(e - 1), r = 0, n = !1; for (; i !== t.charCodeAt(0);) { if (++i === me && i++, i === ye && i++, i > ge) { if (n) throw "Bad character: " + t; i = de, n = !0 } r += 1e5 } return r }(r.charAt(1), l); h < Ae(s);)h += 2e6; var c = i - a; if (c % 2 != 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t; var p, f, d, m = c / 2, y = 0, g = 0; return m > 0 && (p = 1e5 / Math.pow(10, m), f = t.substring(a, a + m), y = parseFloat(f) * p, d = t.substring(a + m), g = parseFloat(d) * p), { easting: y + u, northing: g + h, zoneLetter: s, zoneNumber: o, accuracy: p } } function Ae(t) { var e; switch (t) { case "C": e = 11e5; break; case "D": e = 2e6; break; case "E": e = 28e5; break; case "F": e = 37e5; break; case "G": e = 46e5; break; case "H": e = 55e5; break; case "J": e = 64e5; break; case "K": e = 73e5; break; case "L": e = 82e5; break; case "M": e = 91e5; break; case "N": e = 0; break; case "P": e = 8e5; break; case "Q": e = 17e5; break; case "R": e = 26e5; break; case "S": e = 35e5; break; case "T": e = 44e5; break; case "U": e = 53e5; break; case "V": e = 62e5; break; case "W": e = 7e6; break; case "X": e = 79e5; break; default: e = -1 }if (e >= 0) return e; throw "Invalid zone letter: " + t } function Pe(t, e, i) { if (!(this instanceof Pe)) return new Pe(t, e, i); if (Array.isArray(t)) this.x = t[0], this.y = t[1], this.z = t[2] || 0; else if ("object" == typeof t) this.x = t.x, this.y = t.y, this.z = t.z || 0; else if ("string" == typeof t && void 0 === e) { var r = t.split(","); this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0 } else this.x = t, this.y = e, this.z = i || 0; console.warn("proj4.Point will be removed in version 3, use proj4.toPoint") } Pe.fromMGRS = function (t) { return new Pe(be(t)) }, Pe.prototype.toMGRS = function (t) { return xe([this.x, this.y], t) }; var Ce = .046875, ze = .01953125, ke = .01068115234375; function Le(t) { var e = []; e[0] = 1 - t * (.25 + t * (Ce + t * (ze + t * ke))), e[1] = t * (.75 - t * (Ce + t * (ze + t * ke))); var i = t * t; return e[2] = i * (.46875 - t * (.013020833333333334 + .007120768229166667 * t)), i *= t, e[3] = i * (.3645833333333333 - .005696614583333333 * t), e[4] = i * t * .3076171875, e } function De(t, e, i, r) { return i *= e, e *= e, r[0] * t - i * (r[1] + e * (r[2] + e * (r[3] + e * r[4]))) } function Re(t, e, i) { for (var r = 1 / (1 - e), n = t, a = 20; a; --a) { var o = Math.sin(n), s = 1 - e * o * o; if (n -= s = (De(n, o, Math.cos(n), i) - t) * (s * Math.sqrt(s)) * r, Math.abs(s) < rt) return n } return n } var Be = { init: function () { this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = Le(this.es), this.ml0 = De(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en)) }, forward: function (t) { var e, i, r, n = t.x, a = t.y, o = zt(n - this.long0), s = Math.sin(a), l = Math.cos(a); if (this.es) { var u = l * o, h = Math.pow(u, 2), c = this.ep2 * Math.pow(l, 2), p = Math.pow(c, 2), f = Math.abs(l) > rt ? Math.tan(a) : 0, d = Math.pow(f, 2), m = Math.pow(d, 2); e = 1 - this.es * Math.pow(s, 2), u /= Math.sqrt(e); var y = De(a, s, l, this.en); i = this.a * (this.k0 * u * (1 + h / 6 * (1 - d + c + h / 20 * (5 - 18 * d + m + 14 * c - 58 * d * c + h / 42 * (61 + 179 * m - m * d - 479 * d))))) + this.x0, r = this.a * (this.k0 * (y - this.ml0 + s * o * u / 2 * (1 + h / 12 * (5 - d + 9 * c + 4 * p + h / 30 * (61 + m - 58 * d + 270 * c - 330 * d * c + h / 56 * (1385 + 543 * m - m * d - 3111 * d)))))) + this.y0 } else { var g = l * Math.sin(o); if (Math.abs(Math.abs(g) - 1) < rt) return 93; if (i = .5 * this.a * this.k0 * Math.log((1 + g) / (1 - g)) + this.x0, r = l * Math.cos(o) / Math.sqrt(1 - Math.pow(g, 2)), (g = Math.abs(r)) >= 1) { if (g - 1 > rt) return 93; r = 0 } else r = Math.acos(r); a < 0 && (r = -r), r = this.a * this.k0 * (r - this.lat0) + this.y0 } return t.x = i, t.y = r, t }, inverse: function (t) { var e, i, r, n, a = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a); if (this.es) if (i = Re(e = this.ml0 + o / this.k0, this.es, this.en), Math.abs(i) < it) { var s = Math.sin(i), l = Math.cos(i), u = Math.abs(l) > rt ? Math.tan(i) : 0, h = this.ep2 * Math.pow(l, 2), c = Math.pow(h, 2), p = Math.pow(u, 2), f = Math.pow(p, 2); e = 1 - this.es * Math.pow(s, 2); var d = a * Math.sqrt(e) / this.k0, m = Math.pow(d, 2); r = i - (e *= u) * m / (1 - this.es) * .5 * (1 - m / 12 * (5 + 3 * p - 9 * h * p + h - 4 * c - m / 30 * (61 + 90 * p - 252 * h * p + 45 * f + 46 * h - m / 56 * (1385 + 3633 * p + 4095 * f + 1574 * f * p)))), n = zt(this.long0 + d * (1 - m / 6 * (1 + 2 * p + h - m / 20 * (5 + 28 * p + 24 * f + 8 * h * p + 6 * h - m / 42 * (61 + 662 * p + 1320 * f + 720 * f * p)))) / l) } else r = it * Ct(o), n = 0; else { var y = Math.exp(a / this.k0), g = .5 * (y - 1 / y), _ = this.lat0 + o / this.k0, v = Math.cos(_); e = Math.sqrt((1 - Math.pow(v, 2)) / (1 + Math.pow(g, 2))), r = Math.asin(e), o < 0 && (r = -r), n = 0 === g && 0 === v ? 0 : zt(Math.atan2(g, v) + this.long0) } return t.x = n, t.y = r, t }, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] }; function Oe(t) { var e = Math.exp(t); return e = (e - 1 / e) / 2 } function Fe(t, e) { t = Math.abs(t), e = Math.abs(e); var i = Math.max(t, e), r = Math.min(t, e) / (i || 1); return i * Math.sqrt(1 + Math.pow(r, 2)) } function Ue(t) { var e = Math.abs(t); return e = function (t) { var e = 1 + t, i = e - 1; return 0 === i ? t : t * Math.log(e) / i }(e * (1 + e / (Fe(1, e) + 1))), t < 0 ? -e : e } function Ne(t, e) { for (var i, r = 2 * Math.cos(2 * e), n = t.length - 1, a = t[n], o = 0; --n >= 0;)i = r * a - o + t[n], o = a, a = i; return e + i * Math.sin(2 * e) } function Ve(t, e, i) { for (var r, n, a = Math.sin(e), o = Math.cos(e), s = Oe(i), l = function (t) { var e = Math.exp(t); return (e + 1 / e) / 2 }(i), u = 2 * o * l, h = -2 * a * s, c = t.length - 1, p = t[c], f = 0, d = 0, m = 0; --c >= 0;)r = d, n = f, p = u * (d = p) - r - h * (f = m) + t[c], m = h * d - n + u * f; return [(u = a * l) * p - (h = o * s) * m, u * m + h * p] } var je = { init: function () { if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.'); this.approx && (Be.init.apply(this), this.forward = Be.forward, this.inverse = Be.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = []; var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), i = e; this.cgb[0] = e * (2 + e * (-2 / 3 + e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2))), this.cbg[0] = e * (e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) - 2), i *= e, this.cgb[1] = i * (7 / 3 + e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6)), this.cbg[1] = i * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), i *= e, this.cgb[2] = i * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = i * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835)))), i *= e, this.cgb[3] = i * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = i * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4)), i *= e, this.cgb[4] = i * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = i * (-734 / 315 + e * (109598 / 31185)), i *= e, this.cgb[5] = i * (601676 / 22275), this.cbg[5] = i * (444337 / 155925), i = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + i * (1 / 4 + i * (1 / 64 + i / 256))), this.utg[0] = e * (e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) - .5), this.gtu[0] = e * (.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = i * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = i * (13 / 48 + e * (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) - .6)), i *= e, this.utg[2] = i * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = i * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), i *= e, this.utg[3] = i * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = i * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), i *= e, this.utg[4] = i * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = i * (34729 / 80640 + e * (-3418889 / 1995840)), i *= e, this.utg[5] = i * (-20648693 / 638668800), this.gtu[5] = .6650675310896665 * i; var r = Ne(this.cbg, this.lat0); this.Zb = -this.Qn * (r + function (t, e) { for (var i, r = 2 * Math.cos(e), n = t.length - 1, a = t[n], o = 0; --n >= 0;)i = r * a - o + t[n], o = a, a = i; return Math.sin(e) * i }(this.gtu, 2 * r)) }, forward: function (t) { var e = zt(t.x - this.long0), i = t.y; i = Ne(this.cbg, i); var r = Math.sin(i), n = Math.cos(i), a = Math.sin(e), o = Math.cos(e); i = Math.atan2(r, o * n), e = Math.atan2(a * n, Fe(r, n * o)), e = Ue(Math.tan(e)); var s, l, u = Ve(this.gtu, 2 * i, 2 * e); return i += u[0], e += u[1], Math.abs(e) <= 2.623395162778 ? (s = this.a * (this.Qn * e) + this.x0, l = this.a * (this.Qn * i + this.Zb) + this.y0) : (s = 1 / 0, l = 1 / 0), t.x = s, t.y = l, t }, inverse: function (t) { var e, i, r = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a); if (n = (n - this.Zb) / this.Qn, r /= this.Qn, Math.abs(r) <= 2.623395162778) { var a = Ve(this.utg, 2 * n, 2 * r); n += a[0], r += a[1], r = Math.atan(Oe(r)); var o = Math.sin(n), s = Math.cos(n), l = Math.sin(r), u = Math.cos(r); n = Math.atan2(o * u, Fe(l, u * s)), e = zt((r = Math.atan2(l, u * s)) + this.long0), i = Ne(this.cgb, n) } else e = 1 / 0, i = 1 / 0; return t.x = e, t.y = i, t }, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"] }; var qe = { init: function () { var t = function (t, e) { if (void 0 === t) { if ((t = Math.floor(30 * (zt(e) + Math.PI) / Math.PI) + 1) < 0) return 0; if (t > 60) return 60 } return t }(this.zone, this.long0); if (void 0 === t) throw new Error("unknown utm zone"); this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * nt, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, je.init.apply(this), this.forward = je.forward, this.inverse = je.inverse }, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" }; function Ge(t, e) { return Math.pow((1 - t) / (1 + t), e) } var Ze = { init: function () { var t = Math.sin(this.lat0), e = Math.cos(this.lat0); e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + ot) / (Math.pow(Math.tan(.5 * this.lat0 + ot), this.C) * Ge(this.e * t, this.ratexp)) }, forward: function (t) { var e = t.x, i = t.y; return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * i + ot), this.C) * Ge(this.e * Math.sin(i), this.ratexp)) - it, t.x = this.C * e, t }, inverse: function (t) { for (var e = t.x / this.C, i = t.y, r = Math.pow(Math.tan(.5 * i + ot) / this.K, 1 / this.C), n = 20; n > 0 && (i = 2 * Math.atan(r * Ge(this.e * Math.sin(t.y), -.5 * this.e)) - it, !(Math.abs(i - t.y) < 1e-14)); --n)t.y = i; return n ? (t.x = e, t.y = i, t) : null }, names: ["gauss"] }; var Xe = { init: function () { Ze.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative")) }, forward: function (t) { var e, i, r, n; return t.x = zt(t.x - this.long0), Ze.forward.apply(this, [t]), e = Math.sin(t.y), i = Math.cos(t.y), r = Math.cos(t.x), n = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * i * r), t.x = n * i * Math.sin(t.x), t.y = n * (this.cosc0 * e - this.sinc0 * i * r), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t }, inverse: function (t) { var e, i, r, n, a; if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, a = Math.sqrt(t.x * t.x + t.y * t.y)) { var o = 2 * Math.atan2(a, this.R2); e = Math.sin(o), i = Math.cos(o), n = Math.asin(i * this.sinc0 + t.y * e * this.cosc0 / a), r = Math.atan2(t.x * e, a * this.cosc0 * i - t.y * this.sinc0 * e) } else n = this.phic0, r = 0; return t.x = r, t.y = n, Ze.inverse.apply(this, [t]), t.x = zt(t.x + this.long0), t }, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] }; var We = { init: function () { this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= rt && (this.k0 = .5 * (1 + Ct(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= rt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= rt && (this.k0 = .5 * this.cons * Pt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / kt(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Pt(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - it, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0)) }, forward: function (t) { var e, i, r, n, a, o, s = t.x, l = t.y, u = Math.sin(l), h = Math.cos(l), c = zt(s - this.long0); return Math.abs(Math.abs(s - this.long0) - Math.PI) <= rt && Math.abs(l + this.lat0) <= rt ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * u + this.coslat0 * h * Math.cos(c)), t.x = this.a * e * h * Math.sin(c) + this.x0, t.y = this.a * e * (this.coslat0 * u - this.sinlat0 * h * Math.cos(c)) + this.y0, t) : (i = 2 * Math.atan(this.ssfn_(l, u, this.e)) - it, n = Math.cos(i), r = Math.sin(i), Math.abs(this.coslat0) <= rt ? (a = kt(this.e, l * this.con, this.con * u), o = 2 * this.a * this.k0 * a / this.cons, t.x = this.x0 + o * Math.sin(s - this.long0), t.y = this.y0 - this.con * o * Math.cos(s - this.long0), t) : (Math.abs(this.sinlat0) < rt ? (e = 2 * this.a * this.k0 / (1 + n * Math.cos(c)), t.y = e * r) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * r + this.cosX0 * n * Math.cos(c))), t.y = e * (this.cosX0 * r - this.sinX0 * n * Math.cos(c)) + this.y0), t.x = e * n * Math.sin(c) + this.x0, t)) }, inverse: function (t) { var e, i, r, n, a; t.x -= this.x0, t.y -= this.y0; var o = Math.sqrt(t.x * t.x + t.y * t.y); if (this.sphere) { var s = 2 * Math.atan(o / (2 * this.a * this.k0)); return e = this.long0, i = this.lat0, o <= rt ? (t.x = e, t.y = i, t) : (i = Math.asin(Math.cos(s) * this.sinlat0 + t.y * Math.sin(s) * this.coslat0 / o), e = Math.abs(this.coslat0) < rt ? this.lat0 > 0 ? zt(this.long0 + Math.atan2(t.x, -1 * t.y)) : zt(this.long0 + Math.atan2(t.x, t.y)) : zt(this.long0 + Math.atan2(t.x * Math.sin(s), o * this.coslat0 * Math.cos(s) - t.y * this.sinlat0 * Math.sin(s))), t.x = e, t.y = i, t) } if (Math.abs(this.coslat0) <= rt) { if (o <= rt) return i = this.lat0, e = this.long0, t.x = e, t.y = i, t; t.x *= this.con, t.y *= this.con, r = o * this.cons / (2 * this.a * this.k0), i = this.con * Lt(this.e, r), e = this.con * zt(this.con * this.long0 + Math.atan2(t.x, -1 * t.y)) } else n = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= rt ? a = this.X0 : (a = Math.asin(Math.cos(n) * this.sinX0 + t.y * Math.sin(n) * this.cosX0 / o), e = zt(this.long0 + Math.atan2(t.x * Math.sin(n), o * this.cosX0 * Math.cos(n) - t.y * this.sinX0 * Math.sin(n)))), i = -1 * Lt(this.e, Math.tan(.5 * (it + a))); return t.x = e, t.y = i, t }, names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"], ssfn_: function (t, e, i) { return e *= i, Math.tan(.5 * (it + t)) * Math.pow((1 - e) / (1 + e), .5 * i) } }; var Ke = { init: function () { var t = this.lat0; this.lambda0 = this.long0; var e = Math.sin(t), i = this.a, r = 1 / this.rf, n = 2 * r - Math.pow(r, 2), a = this.e = Math.sqrt(n); this.R = this.k0 * i * Math.sqrt(1 - n) / (1 - n * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + n / (1 - n) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha); var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), s = Math.log(Math.tan(Math.PI / 4 + t / 2)), l = Math.log((1 + a * e) / (1 - a * e)); this.K = o - this.alpha * s + this.alpha * a / 2 * l }, forward: function (t) { var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), i = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), r = -this.alpha * (e + i) + this.K, n = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4), a = this.alpha * (t.x - this.lambda0), o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(a))), s = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(a)); return t.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, t.x = this.R * o + this.x0, t }, inverse: function (t) { for (var e = t.x - this.x0, i = t.y - this.y0, r = e / this.R, n = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(r)), o = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(n))), s = this.lambda0 + o / this.alpha, l = 0, u = a, h = -1e3, c = 0; Math.abs(u - h) > 1e-7;) { if (++c > 20) return; l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(u)) / 2)), h = u, u = 2 * Math.atan(Math.exp(l)) - Math.PI / 2 } return t.x = s, t.y = u, t }, names: ["somerc"] }; var He = { init: function () { this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0) && (this.k0 = 1); var t = Math.sin(this.lat0), e = Math.cos(this.lat0), i = this.e * t; this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(e, 4)), this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - i * i); var r, n, a = kt(this.e, this.lat0, t), o = this.bl / e * Math.sqrt((1 - this.es) / (1 - i * i)); if (o * o < 1 && (o = 1), isNaN(this.longc)) { var s = kt(this.e, this.lat1, Math.sin(this.lat1)), l = kt(this.e, this.lat2, Math.sin(this.lat2)); this.lat0 >= 0 ? this.el = (o + Math.sqrt(o * o - 1)) * Math.pow(a, this.bl) : this.el = (o - Math.sqrt(o * o - 1)) * Math.pow(a, this.bl); var u = Math.pow(s, this.bl), h = Math.pow(l, this.bl); n = .5 * ((r = this.el / u) - 1 / r); var c = (this.el * this.el - h * u) / (this.el * this.el + h * u), p = (h - u) / (h + u), f = zt(this.long1 - this.long2); this.long0 = .5 * (this.long1 + this.long2) - Math.atan(c * Math.tan(.5 * this.bl * f) / p) / this.bl, this.long0 = zt(this.long0); var d = zt(this.long1 - this.long0); this.gamma0 = Math.atan(Math.sin(this.bl * d) / n), this.alpha = Math.asin(o * Math.sin(this.gamma0)) } else r = this.lat0 >= 0 ? o + Math.sqrt(o * o - 1) : o - Math.sqrt(o * o - 1), this.el = r * Math.pow(a, this.bl), n = .5 * (r - 1 / r), this.gamma0 = Math.asin(Math.sin(this.alpha) / o), this.long0 = this.longc - Math.asin(n * Math.tan(this.gamma0)) / this.bl; this.no_off ? this.uc = 0 : this.lat0 >= 0 ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(o * o - 1), Math.cos(this.alpha)) : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(o * o - 1), Math.cos(this.alpha)) }, forward: function (t) { var e, i, r, n = t.x, a = t.y, o = zt(n - this.long0); if (Math.abs(Math.abs(a) - it) <= rt) r = a > 0 ? -1 : 1, i = this.al / this.bl * Math.log(Math.tan(ot + r * this.gamma0 * .5)), e = -1 * r * it * this.al / this.bl; else { var s = kt(this.e, a, Math.sin(a)), l = this.el / Math.pow(s, this.bl), u = .5 * (l - 1 / l), h = .5 * (l + 1 / l), c = Math.sin(this.bl * o), p = (u * Math.sin(this.gamma0) - c * Math.cos(this.gamma0)) / h; i = Math.abs(Math.abs(p) - 1) <= rt ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - p) / (1 + p)) / this.bl, e = Math.abs(Math.cos(this.bl * o)) <= rt ? this.al * this.bl * o : this.al * Math.atan2(u * Math.cos(this.gamma0) + c * Math.sin(this.gamma0), Math.cos(this.bl * o)) / this.bl } return this.no_rot ? (t.x = this.x0 + e, t.y = this.y0 + i) : (e -= this.uc, t.x = this.x0 + i * Math.cos(this.alpha) + e * Math.sin(this.alpha), t.y = this.y0 + e * Math.cos(this.alpha) - i * Math.sin(this.alpha)), t }, inverse: function (t) { var e, i; this.no_rot ? (i = t.y - this.y0, e = t.x - this.x0) : (i = (t.x - this.x0) * Math.cos(this.alpha) - (t.y - this.y0) * Math.sin(this.alpha), e = (t.y - this.y0) * Math.cos(this.alpha) + (t.x - this.x0) * Math.sin(this.alpha), e += this.uc); var r = Math.exp(-1 * this.bl * i / this.al), n = .5 * (r - 1 / r), a = .5 * (r + 1 / r), o = Math.sin(this.bl * e / this.al), s = (o * Math.cos(this.gamma0) + n * Math.sin(this.gamma0)) / a, l = Math.pow(this.el / Math.sqrt((1 + s) / (1 - s)), 1 / this.bl); return Math.abs(s - 1) < rt ? (t.x = this.long0, t.y = it) : Math.abs(s + 1) < rt ? (t.x = this.long0, t.y = -1 * it) : (t.y = Lt(this.e, l), t.x = zt(this.long0 - Math.atan2(n * Math.cos(this.gamma0) - o * Math.sin(this.gamma0), Math.cos(this.bl * e / this.al)) / this.bl)), t }, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"] }; var $e = { init: function () { if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < rt)) { var t = this.b / this.a; this.e = Math.sqrt(1 - t * t); var e = Math.sin(this.lat1), i = Math.cos(this.lat1), r = Pt(this.e, e, i), n = kt(this.e, this.lat1, e), a = Math.sin(this.lat2), o = Math.cos(this.lat2), s = Pt(this.e, a, o), l = kt(this.e, this.lat2, a), u = kt(this.e, this.lat0, Math.sin(this.lat0)); Math.abs(this.lat1 - this.lat2) > rt ? this.ns = Math.log(r / s) / Math.log(n / l) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = r / (this.ns * Math.pow(n, this.ns)), this.rh = this.a * this.f0 * Math.pow(u, this.ns), this.title || (this.title = "Lambert Conformal Conic") } }, forward: function (t) { var e = t.x, i = t.y; Math.abs(2 * Math.abs(i) - Math.PI) <= rt && (i = Ct(i) * (it - 2e-10)); var r, n, a = Math.abs(Math.abs(i) - it); if (a > rt) r = kt(this.e, i, Math.sin(i)), n = this.a * this.f0 * Math.pow(r, this.ns); else { if ((a = i * this.ns) <= 0) return null; n = 0 } var o = this.ns * zt(e - this.long0); return t.x = this.k0 * (n * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - n * Math.cos(o)) + this.y0, t }, inverse: function (t) { var e, i, r, n, a, o = (t.x - this.x0) / this.k0, s = this.rh - (t.y - this.y0) / this.k0; this.ns > 0 ? (e = Math.sqrt(o * o + s * s), i = 1) : (e = -Math.sqrt(o * o + s * s), i = -1); var l = 0; if (0 !== e && (l = Math.atan2(i * o, i * s)), 0 !== e || this.ns > 0) { if (i = 1 / this.ns, r = Math.pow(e / (this.a * this.f0), i), -9999 === (n = Lt(this.e, r))) return null } else n = -it; return a = zt(l / this.ns + this.long0), t.x = a, t.y = n, t }, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"] }; var Je = { init: function () { this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq }, forward: function (t) { var e, i, r, n, a, o, s, l = t.x, u = t.y, h = zt(l - this.long0); return e = Math.pow((1 + this.e * Math.sin(u)) / (1 - this.e * Math.sin(u)), this.alfa * this.e / 2), i = 2 * (Math.atan(this.k * Math.pow(Math.tan(u / 2 + this.s45), this.alfa) / e) - this.s45), r = -h * this.alfa, n = Math.asin(Math.cos(this.ad) * Math.sin(i) + Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), a = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(n)), o = this.n * a, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(n / 2 + this.s45), this.n), t.y = s * Math.cos(o) / 1, t.x = s * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t }, inverse: function (t) { var e, i, r, n, a, o, s, l = t.x; t.x = t.y, t.y = l, this.czech || (t.y *= -1, t.x *= -1), a = Math.sqrt(t.x * t.x + t.y * t.y), n = Math.atan2(t.y, t.x) / Math.sin(this.s0), r = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), i = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(e)), t.x = this.long0 - i / this.alfa, o = e, s = 0; var u = 0; do { t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - t.y) < 1e-10 && (s = 1), o = t.y, u += 1 } while (0 === s && u < 15); return u >= 15 ? null : t }, names: ["Krovak", "krovak"] }; function Ye(t, e, i, r, n) { return t * n - e * Math.sin(2 * n) + i * Math.sin(4 * n) - r * Math.sin(6 * n) } function Qe(t) { return 1 - .25 * t * (1 + t / 16 * (3 + 1.25 * t)) } function ti(t) { return .375 * t * (1 + .25 * t * (1 + .46875 * t)) } function ei(t) { return .05859375 * t * t * (1 + .75 * t) } function ii(t) { return t * t * t * (35 / 3072) } function ri(t, e, i) { var r = e * i; return t / Math.sqrt(1 - r * r) } function ni(t) { return Math.abs(t) < it ? t : t - Ct(t) * Math.PI } function ai(t, e, i, r, n) { var a, o; a = t / e; for (var s = 0; s < 15; s++)if (a += o = (t - (e * a - i * Math.sin(2 * a) + r * Math.sin(4 * a) - n * Math.sin(6 * a))) / (e - 2 * i * Math.cos(2 * a) + 4 * r * Math.cos(4 * a) - 6 * n * Math.cos(6 * a)), Math.abs(o) <= 1e-10) return a; return NaN } var oi = { init: function () { this.sphere || (this.e0 = Qe(this.es), this.e1 = ti(this.es), this.e2 = ei(this.es), this.e3 = ii(this.es), this.ml0 = this.a * Ye(this.e0, this.e1, this.e2, this.e3, this.lat0)) }, forward: function (t) { var e, i, r = t.x, n = t.y; if (r = zt(r - this.long0), this.sphere) e = this.a * Math.asin(Math.cos(n) * Math.sin(r)), i = this.a * (Math.atan2(Math.tan(n), Math.cos(r)) - this.lat0); else { var a = Math.sin(n), o = Math.cos(n), s = ri(this.a, this.e, a), l = Math.tan(n) * Math.tan(n), u = r * Math.cos(n), h = u * u, c = this.es * o * o / (1 - this.es); e = s * u * (1 - h * l * (1 / 6 - (8 - l + 8 * c) * h / 120)), i = this.a * Ye(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + s * a / o * h * (.5 + (5 - l + 6 * c) * h / 24) } return t.x = e + this.x0, t.y = i + this.y0, t }, inverse: function (t) { t.x -= this.x0, t.y -= this.y0; var e, i, r = t.x / this.a, n = t.y / this.a; if (this.sphere) { var a = n + this.lat0; e = Math.asin(Math.sin(a) * Math.cos(r)), i = Math.atan2(Math.tan(r), Math.cos(a)) } else { var o = ai(this.ml0 / this.a + n, this.e0, this.e1, this.e2, this.e3); if (Math.abs(Math.abs(o) - it) <= rt) return t.x = this.long0, t.y = it, n < 0 && (t.y *= -1), t; var s = ri(this.a, this.e, Math.sin(o)), l = s * s * s / this.a / this.a * (1 - this.es), u = Math.pow(Math.tan(o), 2), h = r * this.a / s, c = h * h; e = o - s * Math.tan(o) / l * h * h * (.5 - (1 + 3 * u) * h * h / 24), i = h * (1 - c * (u / 3 + (1 + 3 * u) * u * c / 15)) / Math.cos(o) } return t.x = zt(i + this.long0), t.y = ni(e), t }, names: ["Cassini", "Cassini_Soldner", "cass"] }; function si(t, e) { var i; return t > 1e-7 ? (1 - t * t) * (e / (1 - (i = t * e) * i) - .5 / t * Math.log((1 - i) / (1 + i))) : 2 * e } var li = .3333333333333333, ui = .17222222222222222, hi = .10257936507936508, ci = .06388888888888888, pi = .0664021164021164, fi = .016415012942191543; var di = { init: function () { var t, e = Math.abs(this.lat0); if (Math.abs(e - it) < rt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < rt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) switch (this.qp = si(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = function (t) { var e, i = []; return i[0] = t * li, e = t * t, i[0] += e * ui, i[1] = e * ci, e *= t, i[0] += e * hi, i[1] += e * pi, i[2] = e * fi, i }(this.es), this.mode) { case this.N_POLE: case this.S_POLE: this.dd = 1; break; case this.EQUIT: this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp; break; case this.OBLIQ: this.rq = Math.sqrt(.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = si(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)) }, forward: function (t) { var e, i, r, n, a, o, s, l, u, h, c = t.x, p = t.y; if (c = zt(c - this.long0), this.sphere) { if (a = Math.sin(p), h = Math.cos(p), r = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) { if ((i = this.mode === this.EQUIT ? 1 + h * r : 1 + this.sinph0 * a + this.cosph0 * h * r) <= rt) return null; e = (i = Math.sqrt(2 / i)) * h * Math.sin(c), i *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * h * r } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) { if (this.mode === this.N_POLE && (r = -r), Math.abs(p + this.lat0) < rt) return null; i = ot - .5 * p, e = (i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i))) * Math.sin(c), i *= r } } else { switch (s = 0, l = 0, u = 0, r = Math.cos(c), n = Math.sin(c), a = Math.sin(p), o = si(this.e, a), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (s = o / this.qp, l = Math.sqrt(1 - s * s)), this.mode) { case this.OBLIQ: u = 1 + this.sinb1 * s + this.cosb1 * l * r; break; case this.EQUIT: u = 1 + l * r; break; case this.N_POLE: u = it + p, o = this.qp - o; break; case this.S_POLE: u = p - it, o = this.qp + o }if (Math.abs(u) < rt) return null; switch (this.mode) { case this.OBLIQ: case this.EQUIT: u = Math.sqrt(2 / u), i = this.mode === this.OBLIQ ? this.ymf * u * (this.cosb1 * s - this.sinb1 * l * r) : (u = Math.sqrt(2 / (1 + l * r))) * s * this.ymf, e = this.xmf * u * l * n; break; case this.N_POLE: case this.S_POLE: o >= 0 ? (e = (u = Math.sqrt(o)) * n, i = r * (this.mode === this.S_POLE ? u : -u)) : e = i = 0 } } return t.x = this.a * e + this.x0, t.y = this.a * i + this.y0, t }, inverse: function (t) { t.x -= this.x0, t.y -= this.y0; var e, i, r, n, a, o, s, l, u, h, c = t.x / this.a, p = t.y / this.a; if (this.sphere) { var f, d = 0, m = 0; if ((i = .5 * (f = Math.sqrt(c * c + p * p))) > 1) return null; switch (i = 2 * Math.asin(i), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (m = Math.sin(i), d = Math.cos(i)), this.mode) { case this.EQUIT: i = Math.abs(f) <= rt ? 0 : Math.asin(p * m / f), c *= m, p = d * f; break; case this.OBLIQ: i = Math.abs(f) <= rt ? this.lat0 : Math.asin(d * this.sinph0 + p * m * this.cosph0 / f), c *= m * this.cosph0, p = (d - Math.sin(i) * this.sinph0) * f; break; case this.N_POLE: p = -p, i = it - i; break; case this.S_POLE: i -= it }e = 0 !== p || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(c, p) : 0 } else { if (s = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) { if (c /= this.dd, p *= this.dd, (o = Math.sqrt(c * c + p * p)) < rt) return t.x = this.long0, t.y = this.lat0, t; n = 2 * Math.asin(.5 * o / this.rq), r = Math.cos(n), c *= n = Math.sin(n), this.mode === this.OBLIQ ? (s = r * this.sinb1 + p * n * this.cosb1 / o, a = this.qp * s, p = o * this.cosb1 * r - p * this.sinb1 * n) : (s = p * n / o, a = this.qp * s, p = o * r) } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) { if (this.mode === this.N_POLE && (p = -p), !(a = c * c + p * p)) return t.x = this.long0, t.y = this.lat0, t; s = 1 - a / this.qp, this.mode === this.S_POLE && (s = -s) } e = Math.atan2(c, p), l = Math.asin(s), u = this.apa, h = l + l, i = l + u[0] * Math.sin(h) + u[1] * Math.sin(h + h) + u[2] * Math.sin(h + h + h) } return t.x = zt(this.long0 + e), t.y = i, t }, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 }; function mi(t) { return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t) } var yi = { init: function () { Math.abs(this.lat1 + this.lat2) < rt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Pt(this.e3, this.sin_po, this.cos_po), this.qs1 = si(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Pt(this.e3, this.sin_po, this.cos_po), this.qs2 = si(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = si(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > rt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0) }, forward: function (t) { var e = t.x, i = t.y; this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i); var r = si(this.e3, this.sin_phi, this.cos_phi), n = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0, a = this.ns0 * zt(e - this.long0), o = n * Math.sin(a) + this.x0, s = this.rh - n * Math.cos(a) + this.y0; return t.x = o, t.y = s, t }, inverse: function (t) { var e, i, r, n, a, o; return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), r = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), r = -1), n = 0, 0 !== e && (n = Math.atan2(r * t.x, r * t.y)), r = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - r * r) / (2 * this.ns0)) : (i = (this.c - r * r) / this.ns0, o = this.phi1z(this.e3, i)), a = zt(n / this.ns0 + this.long0), t.x = a, t.y = o, t }, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function (t, e) { var i, r, n, a, o = mi(.5 * e); if (t < rt) return o; for (var s = t * t, l = 1; l <= 25; l++)if (o += a = .5 * (n = 1 - (r = t * (i = Math.sin(o))) * r) * n / Math.cos(o) * (e / (1 - s) - i / n + .5 / t * Math.log((1 - r) / (1 + r))), Math.abs(a) <= 1e-7) return o; return null } }; var gi = { init: function () { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1 }, forward: function (t) { var e, i, r, n, a, o, s, l = t.x, u = t.y; return r = zt(l - this.long0), e = Math.sin(u), i = Math.cos(u), n = Math.cos(r), 1, (a = this.sin_p14 * e + this.cos_p14 * i * n) > 0 || Math.abs(a) <= rt ? (o = this.x0 + 1 * this.a * i * Math.sin(r) / a, s = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * n) / a) : (o = this.x0 + this.infinity_dist * i * Math.sin(r), s = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = o, t.y = s, t }, inverse: function (t) { var e, i, r, n, a, o; return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (n = Math.atan2(e, this.rc), i = Math.sin(n), o = mi((r = Math.cos(n)) * this.sin_p14 + t.y * i * this.cos_p14 / e), a = Math.atan2(t.x * i, e * this.cos_p14 * r - t.y * this.sin_p14 * i), a = zt(this.long0 + a)) : (o = this.phic0, a = 0), t.x = a, t.y = o, t }, names: ["gnom"] }; var _i = { init: function () { this.sphere || (this.k0 = Pt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts))) }, forward: function (t) { var e, i, r = t.x, n = t.y, a = zt(r - this.long0); if (this.sphere) e = this.x0 + this.a * a * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts); else { var o = si(this.e, Math.sin(n)); e = this.x0 + this.a * this.k0 * a, i = this.y0 + this.a * o * .5 / this.k0 } return t.x = e, t.y = i, t }, inverse: function (t) { var e, i; return t.x -= this.x0, t.y -= this.y0, this.sphere ? (e = zt(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (i = function (t, e) { var i = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t)); if (Math.abs(Math.abs(e) - i) < 1e-6) return e < 0 ? -1 * it : it; for (var r, n, a, o, s = Math.asin(.5 * e), l = 0; l < 30; l++)if (n = Math.sin(s), a = Math.cos(s), o = t * n, s += r = Math.pow(1 - o * o, 2) / (2 * a) * (e / (1 - t * t) - n / (1 - o * o) + .5 / t * Math.log((1 - o) / (1 + o))), Math.abs(r) <= 1e-10) return s; return NaN }(this.e, 2 * t.y * this.k0 / this.a), e = zt(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = i, t }, names: ["cea"] }; var vi = { init: function () { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts) }, forward: function (t) { var e = t.x, i = t.y, r = zt(e - this.long0), n = ni(i - this.lat0); return t.x = this.x0 + this.a * r * this.rc, t.y = this.y0 + this.a * n, t }, inverse: function (t) { var e = t.x, i = t.y; return t.x = zt(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = ni(this.lat0 + (i - this.y0) / this.a), t }, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"] }; var xi = { init: function () { this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Qe(this.es), this.e1 = ti(this.es), this.e2 = ei(this.es), this.e3 = ii(this.es), this.ml0 = this.a * Ye(this.e0, this.e1, this.e2, this.e3, this.lat0) }, forward: function (t) { var e, i, r, n = t.x, a = t.y, o = zt(n - this.long0); if (r = o * Math.sin(a), this.sphere) Math.abs(a) <= rt ? (e = this.a * o, i = -1 * this.a * this.lat0) : (e = this.a * Math.sin(r) / Math.tan(a), i = this.a * (ni(a - this.lat0) + (1 - Math.cos(r)) / Math.tan(a))); else if (Math.abs(a) <= rt) e = this.a * o, i = -1 * this.ml0; else { var s = ri(this.a, this.e, Math.sin(a)) / Math.tan(a); e = s * Math.sin(r), i = this.a * Ye(this.e0, this.e1, this.e2, this.e3, a) - this.ml0 + s * (1 - Math.cos(r)) } return t.x = e + this.x0, t.y = i + this.y0, t }, inverse: function (t) { var e, i, r, n, a, o, s, l, u; if (r = t.x - this.x0, n = t.y - this.y0, this.sphere) if (Math.abs(n + this.a * this.lat0) <= rt) e = zt(r / this.a + this.long0), i = 0; else { var h; for (o = this.lat0 + n / this.a, s = r * r / this.a / this.a + o * o, l = o, a = 20; a; --a)if (l += u = -1 * (o * (l * (h = Math.tan(l)) + 1) - l - .5 * (l * l + s) * h) / ((l - o) / h - 1), Math.abs(u) <= rt) { i = l; break } e = zt(this.long0 + Math.asin(r * Math.tan(l) / this.a) / Math.sin(i)) } else if (Math.abs(n + this.ml0) <= rt) i = 0, e = zt(this.long0 + r / this.a); else { var c, p, f, d, m; for (o = (this.ml0 + n) / this.a, s = r * r / this.a / this.a + o * o, l = o, a = 20; a; --a)if (m = this.e * Math.sin(l), c = Math.sqrt(1 - m * m) * Math.tan(l), p = this.a * Ye(this.e0, this.e1, this.e2, this.e3, l), f = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), l -= u = (o * (c * (d = p / this.a) + 1) - d - .5 * c * (d * d + s)) / (this.es * Math.sin(2 * l) * (d * d + s - 2 * o * d) / (4 * c) + (o - d) * (c * f - 2 / Math.sin(2 * l)) - f), Math.abs(u) <= rt) { i = l; break } c = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), e = zt(this.long0 + Math.asin(r * c / this.a) / Math.sin(i)) } return t.x = e, t.y = i, t }, names: ["Polyconic", "poly"] }; var bi = { init: function () { this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013 }, forward: function (t) { var e, i = t.x, r = t.y - this.lat0, n = i - this.long0, a = r / et * 1e-5, o = n, s = 1, l = 0; for (e = 1; e <= 10; e++)s *= a, l += this.A[e] * s; var u, h = l, c = o, p = 1, f = 0, d = 0, m = 0; for (e = 1; e <= 6; e++)u = f * h + p * c, p = p * h - f * c, f = u, d = d + this.B_re[e] * p - this.B_im[e] * f, m = m + this.B_im[e] * p + this.B_re[e] * f; return t.x = m * this.a + this.x0, t.y = d * this.a + this.y0, t }, inverse: function (t) { var e, i, r = t.x, n = t.y, a = r - this.x0, o = (n - this.y0) / this.a, s = a / this.a, l = 1, u = 0, h = 0, c = 0; for (e = 1; e <= 6; e++)i = u * o + l * s, l = l * o - u * s, u = i, h = h + this.C_re[e] * l - this.C_im[e] * u, c = c + this.C_im[e] * l + this.C_re[e] * u; for (var p = 0; p < this.iterations; p++) { var f, d = h, m = c, y = o, g = s; for (e = 2; e <= 6; e++)f = m * h + d * c, d = d * h - m * c, m = f, y += (e - 1) * (this.B_re[e] * d - this.B_im[e] * m), g += (e - 1) * (this.B_im[e] * d + this.B_re[e] * m); d = 1, m = 0; var _ = this.B_re[1], v = this.B_im[1]; for (e = 2; e <= 6; e++)f = m * h + d * c, d = d * h - m * c, m = f, _ += e * (this.B_re[e] * d - this.B_im[e] * m), v += e * (this.B_im[e] * d + this.B_re[e] * m); var x = _ * _ + v * v; h = (y * _ + g * v) / x, c = (g * _ - y * v) / x } var b = h, w = c, M = 1, S = 0; for (e = 1; e <= 9; e++)M *= b, S += this.D[e] * M; var E = this.lat0 + S * et * 1e5, I = this.long0 + w; return t.x = I, t.y = E, t }, names: ["New_Zealand_Map_Grid", "nzmg"] }; var wi = { init: function () { }, forward: function (t) { var e = t.x, i = t.y, r = zt(e - this.long0), n = this.x0 + this.a * r, a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25; return t.x = n, t.y = a, t }, inverse: function (t) { t.x -= this.x0, t.y -= this.y0; var e = zt(this.long0 + t.x / this.a), i = 2.5 * (Math.atan(Math.exp(.8 * t.y / this.a)) - Math.PI / 4); return t.x = e, t.y = i, t }, names: ["Miller_Cylindrical", "mill"] }; var Mi = { init: function () { this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Le(this.es) }, forward: function (t) { var e, i, r = t.x, n = t.y; if (r = zt(r - this.long0), this.sphere) { if (this.m) for (var a = this.n * Math.sin(n), o = 20; o; --o) { var s = (this.m * n + Math.sin(n) - a) / (this.m + Math.cos(n)); if (n -= s, Math.abs(s) < rt) break } else n = 1 !== this.n ? Math.asin(this.n * Math.sin(n)) : n; e = this.a * this.C_x * r * (this.m + Math.cos(n)), i = this.a * this.C_y * n } else { var l = Math.sin(n), u = Math.cos(n); i = this.a * De(n, l, u, this.en), e = this.a * r * u / Math.sqrt(1 - this.es * l * l) } return t.x = e, t.y = i, t }, inverse: function (t) { var e, i, r; return t.x -= this.x0, i = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, i /= this.C_x * (this.m + Math.cos(e)), this.m ? e = mi((this.m * e + Math.sin(e)) / this.n) : 1 !== this.n && (e = mi(Math.sin(e) / this.n)), i = zt(i + this.long0), e = ni(e)) : (e = Re(t.y / this.a, this.es, this.en), (r = Math.abs(e)) < it ? (r = Math.sin(e), i = zt(this.long0 + t.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(e)))) : r - rt < it && (i = this.long0)), t.x = i, t.y = e, t }, names: ["Sinusoidal", "sinu"] }; var Si = { init: function () { }, forward: function (t) { for (var e = t.x, i = t.y, r = zt(e - this.long0), n = i, a = Math.PI * Math.sin(i); ;) { var o = -(n + Math.sin(n) - a) / (1 + Math.cos(n)); if (n += o, Math.abs(o) < rt) break } n /= 2, Math.PI / 2 - Math.abs(i) < rt && (r = 0); var s = .900316316158 * this.a * r * Math.cos(n) + this.x0, l = 1.4142135623731 * this.a * Math.sin(n) + this.y0; return t.x = s, t.y = l, t }, inverse: function (t) { var e, i; t.x -= this.x0, t.y -= this.y0, i = t.y / (1.4142135623731 * this.a), Math.abs(i) > .999999999999 && (i = .999999999999), e = Math.asin(i); var r = zt(this.long0 + t.x / (.900316316158 * this.a * Math.cos(e))); r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), i = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(i) > 1 && (i = 1); var n = Math.asin(i); return t.x = r, t.y = n, t }, names: ["Mollweide", "moll"] }; var Ei = { init: function () { Math.abs(this.lat1 + this.lat2) < rt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Qe(this.es), this.e1 = ti(this.es), this.e2 = ei(this.es), this.e3 = ii(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Pt(this.e, this.sinphi, this.cosphi), this.ml1 = Ye(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < rt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Pt(this.e, this.sinphi, this.cosphi), this.ml2 = Ye(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Ye(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0)) }, forward: function (t) { var e, i = t.x, r = t.y; if (this.sphere) e = this.a * (this.g - r); else { var n = Ye(this.e0, this.e1, this.e2, this.e3, r); e = this.a * (this.g - n) } var a = this.ns * zt(i - this.long0), o = this.x0 + e * Math.sin(a), s = this.y0 + this.rh - e * Math.cos(a); return t.x = o, t.y = s, t }, inverse: function (t) { var e, i, r, n; t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns >= 0 ? (i = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (i = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1); var a = 0; return 0 !== i && (a = Math.atan2(e * t.x, e * t.y)), this.sphere ? (n = zt(this.long0 + a / this.ns), r = ni(this.g - i / this.a), t.x = n, t.y = r, t) : (r = ai(this.g - i / this.a, this.e0, this.e1, this.e2, this.e3), n = zt(this.long0 + a / this.ns), t.x = n, t.y = r, t) }, names: ["Equidistant_Conic", "eqdc"] }; var Ii = { init: function () { this.R = this.a }, forward: function (t) { var e, i, r = t.x, n = t.y, a = zt(r - this.long0); Math.abs(n) <= rt && (e = this.x0 + this.R * a, i = this.y0); var o = mi(2 * Math.abs(n / Math.PI)); (Math.abs(a) <= rt || Math.abs(Math.abs(n) - it) <= rt) && (e = this.x0, i = n >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * o) : this.y0 + Math.PI * this.R * -Math.tan(.5 * o)); var s = .5 * Math.abs(Math.PI / a - a / Math.PI), l = s * s, u = Math.sin(o), h = Math.cos(o), c = h / (u + h - 1), p = c * c, f = c * (2 / u - 1), d = f * f, m = Math.PI * this.R * (s * (c - d) + Math.sqrt(l * (c - d) * (c - d) - (d + l) * (p - d))) / (d + l); a < 0 && (m = -m), e = this.x0 + m; var y = l + c; return m = Math.PI * this.R * (f * y - s * Math.sqrt((d + l) * (l + 1) - y * y)) / (d + l), i = n >= 0 ? this.y0 + m : this.y0 - m, t.x = e, t.y = i, t }, inverse: function (t) { var e, i, r, n, a, o, s, l, u, h, c, p; return t.x -= this.x0, t.y -= this.y0, c = Math.PI * this.R, a = (r = t.x / c) * r + (n = t.y / c) * n, c = 3 * (n * n / (l = -2 * (o = -Math.abs(n) * (1 + a)) + 1 + 2 * n * n + a * a) + (2 * (s = o - 2 * n * n + r * r) * s * s / l / l / l - 9 * o * s / l / l) / 27) / (u = (o - s * s / 3 / l) / l) / (h = 2 * Math.sqrt(-u / 3)), Math.abs(c) > 1 && (c = c >= 0 ? 1 : -1), p = Math.acos(c) / 3, i = t.y >= 0 ? (-h * Math.cos(p + Math.PI / 3) - s / 3 / l) * Math.PI : -(-h * Math.cos(p + Math.PI / 3) - s / 3 / l) * Math.PI, e = Math.abs(r) < rt ? this.long0 : zt(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (r * r - n * n) + a * a)) / 2 / r), t.x = e, t.y = i, t }, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"] }; var Ti = { init: function () { this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0) }, forward: function (t) { var e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, M = t.x, S = t.y, E = Math.sin(t.y), I = Math.cos(t.y), T = zt(M - this.long0); return this.sphere ? Math.abs(this.sin_p12 - 1) <= rt ? (t.x = this.x0 + this.a * (it - S) * Math.sin(T), t.y = this.y0 - this.a * (it - S) * Math.cos(T), t) : Math.abs(this.sin_p12 + 1) <= rt ? (t.x = this.x0 + this.a * (it + S) * Math.sin(T), t.y = this.y0 + this.a * (it + S) * Math.cos(T), t) : (_ = this.sin_p12 * E + this.cos_p12 * I * Math.cos(T), g = (y = Math.acos(_)) ? y / Math.sin(y) : 1, t.x = this.x0 + this.a * g * I * Math.sin(T), t.y = this.y0 + this.a * g * (this.cos_p12 * E - this.sin_p12 * I * Math.cos(T)), t) : (e = Qe(this.es), i = ti(this.es), r = ei(this.es), n = ii(this.es), Math.abs(this.sin_p12 - 1) <= rt ? (a = this.a * Ye(e, i, r, n, it), o = this.a * Ye(e, i, r, n, S), t.x = this.x0 + (a - o) * Math.sin(T), t.y = this.y0 - (a - o) * Math.cos(T), t) : Math.abs(this.sin_p12 + 1) <= rt ? (a = this.a * Ye(e, i, r, n, it), o = this.a * Ye(e, i, r, n, S), t.x = this.x0 + (a + o) * Math.sin(T), t.y = this.y0 + (a + o) * Math.cos(T), t) : (s = E / I, l = ri(this.a, this.e, this.sin_p12), u = ri(this.a, this.e, E), h = Math.atan((1 - this.es) * s + this.es * l * this.sin_p12 / (u * I)), v = 0 === (c = Math.atan2(Math.sin(T), this.cos_p12 * Math.tan(h) - this.sin_p12 * Math.cos(T))) ? Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.abs(Math.abs(c) - Math.PI) <= rt ? -Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.asin(Math.sin(T) * Math.cos(h) / Math.sin(c)), p = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = l * v * (1 - (x = v * v) * (m = (f = this.e * this.cos_p12 * Math.cos(c) / Math.sqrt(1 - this.es)) * f) * (1 - m) / 6 + (b = x * v) / 8 * (d = p * f) * (1 - 2 * m) + (w = b * v) / 120 * (m * (4 - 7 * m) - 3 * p * p * (1 - 7 * m)) - w * v / 48 * d), t.x = this.x0 + y * Math.sin(c), t.y = this.y0 + y * Math.cos(c), t)) }, inverse: function (t) { var e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, M; if (t.x -= this.x0, t.y -= this.y0, this.sphere) { if ((e = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * it * this.a) return; return i = e / this.a, r = Math.sin(i), n = Math.cos(i), a = this.long0, Math.abs(e) <= rt ? o = this.lat0 : (o = mi(n * this.sin_p12 + t.y * r * this.cos_p12 / e), s = Math.abs(this.lat0) - it, a = Math.abs(s) <= rt ? this.lat0 >= 0 ? zt(this.long0 + Math.atan2(t.x, -t.y)) : zt(this.long0 - Math.atan2(-t.x, t.y)) : zt(this.long0 + Math.atan2(t.x * r, e * this.cos_p12 * n - t.y * this.sin_p12 * r))), t.x = a, t.y = o, t } return l = Qe(this.es), u = ti(this.es), h = ei(this.es), c = ii(this.es), Math.abs(this.sin_p12 - 1) <= rt ? (o = ai(((p = this.a * Ye(l, u, h, c, it)) - (e = Math.sqrt(t.x * t.x + t.y * t.y))) / this.a, l, u, h, c), a = zt(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = a, t.y = o, t) : Math.abs(this.sin_p12 + 1) <= rt ? (p = this.a * Ye(l, u, h, c, it), o = ai(((e = Math.sqrt(t.x * t.x + t.y * t.y)) - p) / this.a, l, u, h, c), a = zt(this.long0 + Math.atan2(t.x, t.y)), t.x = a, t.y = o, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), m = Math.atan2(t.x, t.y), f = ri(this.a, this.e, this.sin_p12), y = Math.cos(m), _ = -(g = this.e * this.cos_p12 * y) * g / (1 - this.es), v = 3 * this.es * (1 - _) * this.sin_p12 * this.cos_p12 * y / (1 - this.es), w = 1 - _ * (b = (x = e / f) - _ * (1 + _) * Math.pow(x, 3) / 6 - v * (1 + 3 * _) * Math.pow(x, 4) / 24) * b / 2 - x * b * b * b / 6, d = Math.asin(this.sin_p12 * Math.cos(b) + this.cos_p12 * Math.sin(b) * y), a = zt(this.long0 + Math.asin(Math.sin(m) * Math.sin(b) / Math.cos(d))), M = Math.sin(d), o = Math.atan2((M - this.es * w * this.sin_p12) * Math.tan(d), M * (1 - this.es)), t.x = a, t.y = o, t) }, names: ["Azimuthal_Equidistant", "aeqd"] }; var Ai = { init: function () { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0) }, forward: function (t) { var e, i, r, n, a, o, s, l = t.x, u = t.y; return r = zt(l - this.long0), e = Math.sin(u), i = Math.cos(u), n = Math.cos(r), 1, ((a = this.sin_p14 * e + this.cos_p14 * i * n) > 0 || Math.abs(a) <= rt) && (o = 1 * this.a * i * Math.sin(r), s = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = o, t.y = s, t }, inverse: function (t) { var e, i, r, n, a, o, s; return t.x -= this.x0, t.y -= this.y0, i = mi((e = Math.sqrt(t.x * t.x + t.y * t.y)) / this.a), r = Math.sin(i), n = Math.cos(i), o = this.long0, Math.abs(e) <= rt ? (s = this.lat0, t.x = o, t.y = s, t) : (s = mi(n * this.sin_p14 + t.y * r * this.cos_p14 / e), a = Math.abs(this.lat0) - it, Math.abs(a) <= rt ? (o = this.lat0 >= 0 ? zt(this.long0 + Math.atan2(t.x, -t.y)) : zt(this.long0 - Math.atan2(-t.x, t.y)), t.x = o, t.y = s, t) : (o = zt(this.long0 + Math.atan2(t.x * r, e * this.cos_p14 * n - t.y * this.sin_p14 * r)), t.x = o, t.y = s, t)) }, names: ["ortho"] }, Pi = 1, Ci = 2, zi = 3, ki = 4, Li = 5, Di = 6, Ri = 1, Bi = 2, Oi = 3, Fi = 4; function Ui(t, e, i, r) { var n; return t < rt ? (r.value = Ri, n = 0) : (n = Math.atan2(e, i), Math.abs(n) <= ot ? r.value = Ri : n > ot && n <= it + ot ? (r.value = Bi, n -= it) : n > it + ot || n <= -(it + ot) ? (r.value = Oi, n = n >= 0 ? n - lt : n + lt) : (r.value = Fi, n += it)), n } function Ni(t, e) { var i = t + e; return i < -lt ? i += st : i > +lt && (i -= st), i } var Vi = { init: function () { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= it - ot / 2 ? this.face = Li : this.lat0 <= -(it - ot / 2) ? this.face = Di : Math.abs(this.long0) <= ot ? this.face = Pi : Math.abs(this.long0) <= it + ot ? this.face = this.long0 > 0 ? Ci : ki : this.face = zi, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f) }, forward: function (t) { var e, i, r, n, a, o, s = { x: 0, y: 0 }, l = { value: 0 }; if (t.x -= this.long0, e = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : t.y, i = t.x, this.face === Li) n = it - e, i >= ot && i <= it + ot ? (l.value = Ri, r = i - it) : i > it + ot || i <= -(it + ot) ? (l.value = Bi, r = i > 0 ? i - lt : i + lt) : i > -(it + ot) && i <= -ot ? (l.value = Oi, r = i + it) : (l.value = Fi, r = i); else if (this.face === Di) n = it + e, i >= ot && i <= it + ot ? (l.value = Ri, r = -i + it) : i < ot && i >= -ot ? (l.value = Bi, r = -i) : i < -ot && i >= -(it + ot) ? (l.value = Oi, r = -i - it) : (l.value = Fi, r = i > 0 ? -i + lt : -i - lt); else { var u, h, c, p, f, d; this.face === Ci ? i = Ni(i, +it) : this.face === zi ? i = Ni(i, +lt) : this.face === ki && (i = Ni(i, -it)), p = Math.sin(e), f = Math.cos(e), d = Math.sin(i), u = f * Math.cos(i), h = f * d, c = p, this.face === Pi ? r = Ui(n = Math.acos(u), c, h, l) : this.face === Ci ? r = Ui(n = Math.acos(h), c, -u, l) : this.face === zi ? r = Ui(n = Math.acos(-u), c, -h, l) : this.face === ki ? r = Ui(n = Math.acos(-h), c, u, l) : (n = r = 0, l.value = Ri) } return o = Math.atan(12 / lt * (r + Math.acos(Math.sin(r) * Math.cos(ot)) - it)), a = Math.sqrt((1 - Math.cos(n)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === Bi ? o += it : l.value === Oi ? o += lt : l.value === Fi && (o += 1.5 * lt), s.x = a * Math.cos(o), s.y = a * Math.sin(o), s.x = s.x * this.a + this.x0, s.y = s.y * this.a + this.y0, t.x = s.x, t.y = s.y, t }, inverse: function (t) { var e, i, r, n, a, o, s, l, u, h, c, p, f = { lam: 0, phi: 0 }, d = { value: 0 }; if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, i = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), e = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? d.value = Ri : t.y >= 0 && t.y >= Math.abs(t.x) ? (d.value = Bi, e -= it) : t.x < 0 && -t.x >= Math.abs(t.y) ? (d.value = Oi, e = e < 0 ? e + lt : e - lt) : (d.value = Fi, e += it), u = lt / 12 * Math.tan(e), a = Math.sin(u) / (Math.cos(u) - 1 / Math.sqrt(2)), o = Math.atan(a), (s = 1 - (r = Math.cos(e)) * r * (n = Math.tan(i)) * n * (1 - Math.cos(Math.atan(1 / Math.cos(o))))) < -1 ? s = -1 : s > 1 && (s = 1), this.face === Li) l = Math.acos(s), f.phi = it - l, d.value === Ri ? f.lam = o + it : d.value === Bi ? f.lam = o < 0 ? o + lt : o - lt : d.value === Oi ? f.lam = o - it : f.lam = o; else if (this.face === Di) l = Math.acos(s), f.phi = l - it, d.value === Ri ? f.lam = -o + it : d.value === Bi ? f.lam = -o : d.value === Oi ? f.lam = -o - it : f.lam = o < 0 ? -o - lt : -o + lt; else { var m, y, g; u = (m = s) * m, y = (u += (g = u >= 1 ? 0 : Math.sqrt(1 - u) * Math.sin(o)) * g) >= 1 ? 0 : Math.sqrt(1 - u), d.value === Bi ? (u = y, y = -g, g = u) : d.value === Oi ? (y = -y, g = -g) : d.value === Fi && (u = y, y = g, g = -u), this.face === Ci ? (u = m, m = -y, y = u) : this.face === zi ? (m = -m, y = -y) : this.face === ki && (u = m, m = y, y = -u), f.phi = Math.acos(-g) - it, f.lam = Math.atan2(y, m), this.face === Ci ? f.lam = Ni(f.lam, -it) : this.face === zi ? f.lam = Ni(f.lam, -lt) : this.face === ki && (f.lam = Ni(f.lam, +it)) } return 0 !== this.es && (h = f.phi < 0 ? 1 : 0, c = Math.tan(f.phi), p = this.b / Math.sqrt(c * c + this.one_minus_f_squared), f.phi = Math.atan(Math.sqrt(this.a * this.a - p * p) / (this.one_minus_f * p)), h && (f.phi = -f.phi)), f.lam += this.long0, t.x = f.lam, t.y = f.phi, t }, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] }, ji = [[1, 22199e-21, -715515e-10, 31103e-10], [.9986, -482243e-9, -24897e-9, -13309e-10], [.9954, -83103e-8, -448605e-10, -9.86701e-7], [.99, -.00135364, -59661e-9, 36777e-10], [.9822, -.00167442, -449547e-11, -572411e-11], [.973, -.00214868, -903571e-10, 1.8736e-8], [.96, -.00305085, -900761e-10, 164917e-11], [.9427, -.00382792, -653386e-10, -26154e-10], [.9216, -.00467746, -10457e-8, 481243e-11], [.8962, -.00536223, -323831e-10, -543432e-11], [.8679, -.00609363, -113898e-9, 332484e-11], [.835, -.00698325, -640253e-10, 9.34959e-7], [.7986, -.00755338, -500009e-10, 9.35324e-7], [.7597, -.00798324, -35971e-9, -227626e-11], [.7186, -.00851367, -701149e-10, -86303e-10], [.6732, -.00986209, -199569e-9, 191974e-10], [.6213, -.010418, 883923e-10, 624051e-11], [.5722, -.00906601, 182e-6, 624051e-11], [.5322, -.00677797, 275608e-9, 624051e-11]], qi = [[-520417e-23, .0124, 121431e-23, -845284e-16], [.062, .0124, -1.26793e-9, 4.22642e-10], [.124, .0124, 5.07171e-9, -1.60604e-9], [.186, .0123999, -1.90189e-8, 6.00152e-9], [.248, .0124002, 7.10039e-8, -2.24e-8], [.31, .0123992, -2.64997e-7, 8.35986e-8], [.372, .0124029, 9.88983e-7, -3.11994e-7], [.434, .0123893, -369093e-11, -4.35621e-7], [.4958, .0123198, -102252e-10, -3.45523e-7], [.5571, .0121916, -154081e-10, -5.82288e-7], [.6176, .0119938, -241424e-10, -5.25327e-7], [.6769, .011713, -320223e-10, -5.16405e-7], [.7346, .0113541, -397684e-10, -6.09052e-7], [.7903, .0109107, -489042e-10, -104739e-11], [.8435, .0103431, -64615e-9, -1.40374e-9], [.8936, .00969686, -64636e-9, -8547e-9], [.9394, .00840947, -192841e-9, -42106e-10], [.9761, .00616527, -256e-6, -42106e-10], [1, .00328947, -319159e-9, -42106e-10]], Gi = .8487, Zi = 1.3523, Xi = at / 5, Wi = 18, Ki = function (t, e) { return t[0] + e * (t[1] + e * (t[2] + e * t[3])) }; var Hi = { init: function () { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson" }, forward: function (t) { var e = zt(t.x - this.long0), i = Math.abs(t.y), r = Math.floor(i * Xi); r < 0 ? r = 0 : r >= Wi && (r = 17); var n = { x: Ki(ji[r], i = at * (i - .08726646259971647 * r)) * e, y: Ki(qi[r], i) }; return t.y < 0 && (n.y = -n.y), n.x = n.x * this.a * Gi + this.x0, n.y = n.y * this.a * Zi + this.y0, n }, inverse: function (t) { var e = { x: (t.x - this.x0) / (this.a * Gi), y: Math.abs(t.y - this.y0) / (this.a * Zi) }; if (e.y >= 1) e.x /= ji[18][0], e.y = t.y < 0 ? -it : it; else { var i = Math.floor(e.y * Wi); for (i < 0 ? i = 0 : i >= Wi && (i = 17); ;)if (qi[i][0] > e.y) --i; else { if (!(qi[i + 1][0] <= e.y)) break; ++i } var r = qi[i], n = 5 * (e.y - r[0]) / (qi[i + 1][0] - r[0]); n = function (t, e, i, r) { for (var n = e; r; --r) { var a = t(n); if (n -= a, Math.abs(a) < i) break } return n }((function (t) { return (Ki(r, t) - e.y) / function (t, e) { return t[1] + e * (2 * t[2] + 3 * e * t[3]) }(r, t) }), n, rt, 100), e.x /= Ki(ji[i], n), e.y = (5 * i + n) * nt, t.y < 0 && (e.y = -e.y) } return e.x = zt(e.x + this.long0), e }, names: ["Robinson", "robin"] }; var $i = { init: function () { this.name = "geocent" }, forward: function (t) { return Jt(t, this.es, this.a) }, inverse: function (t) { return Yt(t, this.es, this.a, this.b) }, names: ["Geocentric", "geocentric", "geocent", "Geocent"] }, Ji = 0, Yi = 1, Qi = 2, tr = 3, er = { h: { def: 1e5, num: !0 }, azi: { def: 0, num: !0, degrees: !0 }, tilt: { def: 0, num: !0, degrees: !0 }, long0: { def: 0, num: !0 }, lat0: { def: 0, num: !0 } }; var ir = { init: function () { if (Object.keys(er).forEach(function (t) { if (void 0 === this[t]) this[t] = er[t].def; else { if (er[t].num && isNaN(this[t])) throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]); er[t].num && (this[t] = parseFloat(this[t])) } er[t].degrees && (this[t] = this[t] * nt) }.bind(this)), Math.abs(Math.abs(this.lat0) - it) < rt ? this.mode = this.lat0 < 0 ? Yi : Ji : Math.abs(this.lat0) < rt ? this.mode = Qi : (this.mode = tr, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height"); this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0; var t = this.tilt, e = this.azi; this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t) }, forward: function (t) { t.x -= this.long0; var e, i, r, n, a = Math.sin(t.y), o = Math.cos(t.y), s = Math.cos(t.x); switch (this.mode) { case tr: i = this.sinph0 * a + this.cosph0 * o * s; break; case Qi: i = o * s; break; case Yi: i = -a; break; case Ji: i = a }switch (e = (i = this.pn1 / (this.p - i)) * o * Math.sin(t.x), this.mode) { case tr: i *= this.cosph0 * a - this.sinph0 * o * s; break; case Qi: i *= a; break; case Ji: i *= -o * s; break; case Yi: i *= o * s }return n = 1 / ((r = i * this.cg + e * this.sg) * this.sw * this.h1 + this.cw), e = (e * this.cg - i * this.sg) * this.cw * n, i = r * n, t.x = e * this.a, t.y = i * this.a, t }, inverse: function (t) { t.x /= this.a, t.y /= this.a; var e, i, r, n = { x: t.x, y: t.y }; r = 1 / (this.pn1 - t.y * this.sw), e = this.pn1 * t.x * r, i = this.pn1 * t.y * this.cw * r, t.x = e * this.cg + i * this.sg, t.y = i * this.cg - e * this.sg; var a = Fe(t.x, t.y); if (Math.abs(a) < rt) n.x = 0, n.y = t.y; else { var o, s; switch (s = 1 - a * a * this.pfact, s = (this.p - Math.sqrt(s)) / (this.pn1 / a + a / this.pn1), o = Math.sqrt(1 - s * s), this.mode) { case tr: n.y = Math.asin(o * this.sinph0 + t.y * s * this.cosph0 / a), t.y = (o - this.sinph0 * Math.sin(n.y)) * a, t.x *= s * this.cosph0; break; case Qi: n.y = Math.asin(t.y * s / a), t.y = o * a, t.x *= s; break; case Ji: n.y = Math.asin(o), t.y = -t.y; break; case Yi: n.y = -Math.asin(o) }n.x = Math.atan2(t.x, t.y) } return t.x = n.x + this.long0, t.y = n.y, t }, names: ["Tilted_Perspective", "tpers"] }; function rr(t, e, i) { var r, n, a, o, s; function l() { var u = Date.now() - o; u < e && u >= 0 ? r = setTimeout(l, e - u) : (r = null, i || (s = t.apply(a, n), a = n = null)) } null == e && (e = 100); var u = function () { a = this, n = arguments, o = Date.now(); var u = i && !r; return r || (r = setTimeout(l, e)), u && (s = t.apply(a, n), a = n = null), s }; return u.clear = function () { r && (clearTimeout(r), r = null) }, u.flush = function () { r && (s = t.apply(a, n), a = n = null, clearTimeout(r), r = null) }, u } ce.defaultDatum = "WGS84", ce.Proj = $t, ce.WGS84 = new ce.Proj("WGS84"), ce.Point = Pe, ce.toPoint = ae, ce.defs = St, ce.nadgrid = function (t, e) { var i = new DataView(e), r = function (t) { var e = t.getInt32(8, !1); if (11 === e) return !1; 11 !== (e = t.getInt32(8, !0)) && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"); return !0 }(i), n = function (t, e) { return { nFields: t.getInt32(8, e), nSubgridFields: t.getInt32(24, e), nSubgrids: t.getInt32(40, e), shiftType: Xt(t, 56, 64).trim(), fromSemiMajorAxis: t.getFloat64(120, e), fromSemiMinorAxis: t.getFloat64(136, e), toSemiMajorAxis: t.getFloat64(152, e), toSemiMinorAxis: t.getFloat64(168, e) } }(i, r); n.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored"); var a = { header: n, subgrids: function (t, e, i) { for (var r = 176, n = [], a = 0; a < e.nSubgrids; a++) { var o = Kt(t, r, i), s = Ht(t, r, o, i), l = Math.round(1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval), u = Math.round(1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval); n.push({ ll: [Zt(o.lowerLongitude), Zt(o.lowerLatitude)], del: [Zt(o.longitudeInterval), Zt(o.latitudeInterval)], lim: [l, u], count: o.gridNodeCount, cvs: Wt(s) }) } return n }(i, n, r) }; return qt[t] = a, a }, ce.transform = se, ce.mgrs = ve, ce.version = "__VERSION__", function (t) { t.Proj.projections.add(Be), t.Proj.projections.add(je), t.Proj.projections.add(qe), t.Proj.projections.add(Xe), t.Proj.projections.add(We), t.Proj.projections.add(Ke), t.Proj.projections.add(He), t.Proj.projections.add($e), t.Proj.projections.add(Je), t.Proj.projections.add(oi), t.Proj.projections.add(di), t.Proj.projections.add(yi), t.Proj.projections.add(gi), t.Proj.projections.add(_i), t.Proj.projections.add(vi), t.Proj.projections.add(xi), t.Proj.projections.add(bi), t.Proj.projections.add(wi), t.Proj.projections.add(Mi), t.Proj.projections.add(Si), t.Proj.projections.add(Ei), t.Proj.projections.add(Ii), t.Proj.projections.add(Ti), t.Proj.projections.add(Ai), t.Proj.projections.add(Vi), t.Proj.projections.add(Hi), t.Proj.projections.add($i), t.Proj.projections.add(ir) }(ce), rr.debounce = rr; var nr = rr; const ar = ["EPSG:27700", "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs"], or = [{ id: "zoomstack-outdoor", name: "OS Zoomstack (outdoor style)", url: "./data/style-outdoor.json" }, { id: "zoomstack-roads", name: "OS Zoomstack (roads style)", url: "./data/style-roads.json" }, { id: "zoomstack-ons", name: "OS Zoomstack (ONS style)", url: "./data/style-os.json" }, { id: "ons-light", name: "OpenMapTiles (ONS style)", url: "./data/style-omt.json" }, { id: "ons-dark", name: "OpenMapTiles (ONS dark)", url: "./data/style-dark.json" }, { id: "hills", name: "Ordnance Survey (Hills) 1885-1903", url: "./data/style-hills.json" }, { id: "os-1900", name: "Ordnance Survey 1888-1913", url: "./data/style-os-1900.json" }, { id: "os-1937", name: "Ordnance Survey 1937-61", url: "./data/style-os-1937.json" }, { id: "esri", name: "ESRI Satellite Imagery", url: "./data/style-esri.json" }, { id: "openstreetmap", name: "OpenStreetMap", url: "./data/style-osm.json" }, { id: "roads-overlay", name: "OS Roads 2020", url: "./data/style-overlay.json", overlay: !0 }, { id: "bldg-overlay", name: "OS Buildings 2020", url: "./data/style-buildings.json", overlay: !0, middle: !0 }]; async function sr(t) { let e = await fetch(t.url); return await e.json() } function lr(t) { return new Promise((e => setTimeout(e, t))) } function ur(t) { let e, i; const r = t[2].default, n = o(r, t, t[1], null); return { c() { e = m("div"), n && n.c() }, m(r, a) { p(r, e, a), n && n.m(e, null), t[3](e), i = !0 }, p(t, [e]) { n && n.p && (!i || 2 & e) && u(n, r, t, t[1], i ? l(r, t[1], e, null) : h(t[1]), null) }, i(t) { i || (G(n, t), i = !0) }, o(t) { Z(n, t), i = !1 }, d(i) { i && f(e), n && n.d(i), t[3](null) } } } function hr(t, e, i) { let { $$slots: r = {}, $$scope: n } = e, { div: a } = e; return T((() => { const t = document.createElement("link"); return t.rel = "stylesheet", t.href = "https://unpkg.com/mapbox-gl-compare@0.4.0/dist/mapbox-gl-compare.css", document.head.appendChild(t), () => { t.parentNode.removeChild(t) } })), t.$$set = t => { "div" in t && i(0, a = t.div), "$$scope" in t && i(1, n = t.$$scope) }, [a, n, r, function (t) { P[t ? "unshift" : "push"]((() => { a = t, i(0, a) })) }] } class cr extends Y { constructor(t) { super(), J(this, t, hr, ur, a, { div: 0 }) } } "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var pr, fr = (function (t, e) { t.exports = function () { var t, e, i; function r(r, n) { if (t) if (e) { var a = "var sharedChunk = {}; (" + t + ")(sharedChunk); (" + e + ")(sharedChunk);", o = {}; t(o), i = n(o), "undefined" != typeof window && (i.workerUrl = window.URL.createObjectURL(new Blob([a], { type: "text/javascript" }))) } else e = n; else t = n } return r(["exports"], (function (t) { function e(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var i = r; function r(t, e, i, r) { this.cx = 3 * t, this.bx = 3 * (i - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (r - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = i, this.p2y = r } r.prototype.sampleCurveX = function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, r.prototype.sampleCurveY = function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, r.prototype.sampleCurveDerivativeX = function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, r.prototype.solveCurveX = function (t, e) { var i, r, n, a, o; for (void 0 === e && (e = 1e-6), n = t, o = 0; o < 8; o++) { if (a = this.sampleCurveX(n) - t, Math.abs(a) < e) return n; var s = this.sampleCurveDerivativeX(n); if (Math.abs(s) < 1e-6) break; n -= a / s } if ((n = t) < (i = 0)) return i; if (n > (r = 1)) return r; for (; i < r;) { if (a = this.sampleCurveX(n), Math.abs(a - t) < e) return n; t > a ? i = n : r = n, n = .5 * (r - i) + i } return n }, r.prototype.solve = function (t, e) { return this.sampleCurveY(this.solveCurveX(t, e)) }; var n = a; function a(t, e) { this.x = t, this.y = e } a.prototype = { clone: function () { return new a(this.x, this.y) }, add: function (t) { return this.clone()._add(t) }, sub: function (t) { return this.clone()._sub(t) }, multByPoint: function (t) { return this.clone()._multByPoint(t) }, divByPoint: function (t) { return this.clone()._divByPoint(t) }, mult: function (t) { return this.clone()._mult(t) }, div: function (t) { return this.clone()._div(t) }, rotate: function (t) { return this.clone()._rotate(t) }, rotateAround: function (t, e) { return this.clone()._rotateAround(t, e) }, matMult: function (t) { return this.clone()._matMult(t) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (t) { return this.x === t.x && this.y === t.y }, dist: function (t) { return Math.sqrt(this.distSqr(t)) }, distSqr: function (t) { var e = t.x - this.x, i = t.y - this.y; return e * e + i * i }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (t) { return Math.atan2(this.y - t.y, this.x - t.x) }, angleWith: function (t) { return this.angleWithSep(t.x, t.y) }, angleWithSep: function (t, e) { return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e) }, _matMult: function (t) { var e = t[2] * this.x + t[3] * this.y; return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, _sub: function (t) { return this.x -= t.x, this.y -= t.y, this }, _mult: function (t) { return this.x *= t, this.y *= t, this }, _div: function (t) { return this.x /= t, this.y /= t, this }, _multByPoint: function (t) { return this.x *= t.x, this.y *= t.y, this }, _divByPoint: function (t) { return this.x /= t.x, this.y /= t.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var t = this.y; return this.y = this.x, this.x = -t, this }, _rotate: function (t) { var e = Math.cos(t), i = Math.sin(t), r = i * this.x + e * this.y; return this.x = e * this.x - i * this.y, this.y = r, this }, _rotateAround: function (t, e) { var i = Math.cos(t), r = Math.sin(t), n = e.y + r * (this.x - e.x) + i * (this.y - e.y); return this.x = e.x + i * (this.x - e.x) - r * (this.y - e.y), this.y = n, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, a.convert = function (t) { return t instanceof a ? t : Array.isArray(t) ? new a(t[0], t[1]) : t }; var o = "undefined" != typeof self ? self : {}, s = Math.pow(2, 53) - 1; function l(t, e, r, n) { var a = new i(t, e, r, n); return function (t) { return a.solve(t) } } var u = l(.25, .1, .25, 1); function h(t, e, i) { return Math.min(i, Math.max(e, t)) } function c(t, e, i) { var r = i - e, n = ((t - e) % r + r) % r + e; return n === e ? i : n } function p(t) { for (var e = [], i = arguments.length - 1; i-- > 0;)e[i] = arguments[i + 1]; for (var r = 0, n = e; r < n.length; r += 1) { var a = n[r]; for (var o in a) t[o] = a[o] } return t } var f = 1; function d() { return f++ } function m() { return function t(e) { return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t) }() } function y(t) { return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t) } function g(t, e) { t.forEach((function (t) { e[t] && (e[t] = e[t].bind(e)) })) } function _(t, e) { return -1 !== t.indexOf(e, t.length - e.length) } function v(t, e, i) { var r = {}; for (var n in t) r[n] = e.call(i || this, t[n], n, t); return r } function x(t, e, i) { var r = {}; for (var n in t) e.call(i || this, t[n], n, t) && (r[n] = t[n]); return r } function b(t) { return Array.isArray(t) ? t.map(b) : "object" == typeof t && t ? v(t, b) : t } var w = {}; function M(t) { w[t] || ("undefined" != typeof console && console.warn(t), w[t] = !0) } function S(t, e, i) { return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x) } function E(t) { for (var e = 0, i = 0, r = t.length, n = r - 1, a = void 0, o = void 0; i < r; n = i++)e += ((o = t[n]).x - (a = t[i]).x) * (a.y + o.y); return e } function I() { return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope } function T(t) { var e = {}; if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (function (t, i, r, n) { var a = r || n; return e[i] = !a || a.toLowerCase(), "" })), e["max-age"]) { var i = parseInt(e["max-age"], 10); isNaN(i) ? delete e["max-age"] : e["max-age"] = i } return e } var A = null; function P(t) { if (null == A) { var e = t.navigator ? t.navigator.userAgent : null; A = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome"))) } return A } function C(t) { try { var e = o[t]; return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0 } catch (t) { return !1 } } var z, k, L, D, R = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date), B = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame, O = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame, F = { now: R, frame: function (t) { var e = B(t); return { cancel: function () { return O(e) } } }, getImageData: function (t, e) { void 0 === e && (e = 0); var i = o.document.createElement("canvas"), r = i.getContext("2d"); if (!r) throw new Error("failed to create canvas 2d context"); return i.width = t.width, i.height = t.height, r.drawImage(t, 0, 0, t.width, t.height), r.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e) }, resolveURL: function (t) { return z || (z = o.document.createElement("a")), z.href = t, z.href }, hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4, get devicePixelRatio() { return o.devicePixelRatio }, get prefersReducedMotion() { return !!o.matchMedia && (null == k && (k = o.matchMedia("(prefers-reduced-motion: reduce)")), k.matches) } }, U = { API_URL: "https://api.mapbox.com", get EVENTS_URL() { return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, N = { supported: !1, testSupport: function (t) { !V && D && (j ? q(t) : L = t) } }, V = !1, j = !1; function q(t) { var e = t.createTexture(); t.bindTexture(t.TEXTURE_2D, e); try { if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, D), t.isContextLost()) return; N.supported = !0 } catch (t) { } t.deleteTexture(e), V = !0 } o.document && ((D = o.document.createElement("img")).onload = function () { L && q(L), L = null, j = !0 }, D.onerror = function () { V = !0, L = null }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="); var G = "01", Z = function (t, e) { this._transformRequestFn = t, this._customAccessToken = e, this._createSkuToken() }; function X(t) { return 0 === t.indexOf("mapbox:") } Z.prototype._createSkuToken = function () { var t = function () { for (var t = "", e = 0; e < 10; e++)t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())]; return { token: ["1", G, t].join(""), tokenExpiresAt: Date.now() + 432e5 } }(); this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt }, Z.prototype._isSkuTokenExpired = function () { return Date.now() > this._skuTokenExpiresAt }, Z.prototype.transformRequest = function (t, e) { return this._transformRequestFn && this._transformRequestFn(t, e) || { url: t } }, Z.prototype.normalizeStyleURL = function (t, e) { if (!X(t)) return t; var i = $(t); return i.path = "/styles/v1" + i.path, this._makeAPIURL(i, this._customAccessToken || e) }, Z.prototype.normalizeGlyphsURL = function (t, e) { if (!X(t)) return t; var i = $(t); return i.path = "/fonts/v1" + i.path, this._makeAPIURL(i, this._customAccessToken || e) }, Z.prototype.normalizeSourceURL = function (t, e) { if (!X(t)) return t; var i = $(t); return i.path = "/v4/" + i.authority + ".json", i.params.push("secure"), this._makeAPIURL(i, this._customAccessToken || e) }, Z.prototype.normalizeSpriteURL = function (t, e, i, r) { var n = $(t); return X(t) ? (n.path = "/styles/v1" + n.path + "/sprite" + e + i, this._makeAPIURL(n, this._customAccessToken || r)) : (n.path += "" + e + i, J(n)) }, Z.prototype.normalizeTileURL = function (t, e) { if (this._isSkuTokenExpired() && this._createSkuToken(), t && !X(t)) return t; var i = $(t); i.path = i.path.replace(/(\.(png|jpg)\d*)(?=$)/, (F.devicePixelRatio >= 2 || 512 === e ? "@2x" : "") + (N.supported ? ".webp" : "$1")), i.path = i.path.replace(/^.+\/v4\//, "/"), i.path = "/v4" + i.path; var r = this._customAccessToken || function (t) { for (var e = 0, i = t; e < i.length; e += 1) { var r = i[e].match(/^access_token=(.*)$/); if (r) return r[1] } return null }(i.params) || U.ACCESS_TOKEN; return U.REQUIRE_ACCESS_TOKEN && r && this._skuToken && i.params.push("sku=" + this._skuToken), this._makeAPIURL(i, r) }, Z.prototype.canonicalizeTileURL = function (t, e) { var i = $(t); if (!i.path.match(/(^\/v4\/)/) || !i.path.match(/\.[\w]+$/)) return t; var r = "mapbox://tiles/"; r += i.path.replace("/v4/", ""); var n = i.params; return e && (n = n.filter((function (t) { return !t.match(/^access_token=/) }))), n.length && (r += "?" + n.join("&")), r }, Z.prototype.canonicalizeTileset = function (t, e) { for (var i = !!e && X(e), r = [], n = 0, a = t.tiles || []; n < a.length; n += 1) { var o = a[n]; K(o) ? r.push(this.canonicalizeTileURL(o, i)) : r.push(o) } return r }, Z.prototype._makeAPIURL = function (t, e) { var i = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", r = $(U.API_URL); if (t.protocol = r.protocol, t.authority = r.authority, "http" === t.protocol) { var n = t.params.indexOf("secure"); n >= 0 && t.params.splice(n, 1) } if ("/" !== r.path && (t.path = "" + r.path + t.path), !U.REQUIRE_ACCESS_TOKEN) return J(t); if (!(e = e || U.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + i); if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + i); return t.params = t.params.filter((function (t) { return -1 === t.indexOf("access_token") })), t.params.push("access_token=" + e), J(t) }; var W = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i; function K(t) { return W.test(t) } var H = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/; function $(t) { var e = t.match(H); if (!e) throw new Error("Unable to parse URL object"); return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] } } function J(t) { var e = t.params.length ? "?" + t.params.join("&") : ""; return t.protocol + "://" + t.authority + t.path + e } function Y(t) { if (!t) return null; var e = t.split("."); if (!e || 3 !== e.length) return null; try { return JSON.parse(decodeURIComponent(o.atob(e[1]).split("").map((function (t) { return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2) })).join(""))) } catch (t) { return null } } var Q = function (t) { this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null }; Q.prototype.getStorageKey = function (t) { var e, i = Y(U.ACCESS_TOKEN); return e = i && i.u ? o.btoa(encodeURIComponent(i.u).replace(/%([0-9A-F]{2})/g, (function (t, e) { return String.fromCharCode(Number("0x" + e)) }))) : U.ACCESS_TOKEN || "", t ? "mapbox.eventData." + t + ":" + e : "mapbox.eventData:" + e }, Q.prototype.fetchEventData = function () { var t = C("localStorage"), e = this.getStorageKey(), i = this.getStorageKey("uuid"); if (t) try { var r = o.localStorage.getItem(e); r && (this.eventData = JSON.parse(r)); var n = o.localStorage.getItem(i); n && (this.anonId = n) } catch (t) { M("Unable to read from LocalStorage") } }, Q.prototype.saveEventData = function () { var t = C("localStorage"), e = this.getStorageKey(), i = this.getStorageKey("uuid"); if (t) try { o.localStorage.setItem(i, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e, JSON.stringify(this.eventData)) } catch (t) { M("Unable to write to LocalStorage") } }, Q.prototype.processRequests = function (t) { }, Q.prototype.postEvent = function (t, e, i, r) { var n = this; if (U.EVENTS_URL) { var a = $(U.EVENTS_URL); a.params.push("access_token=" + (r || U.ACCESS_TOKEN || "")); var o = { event: this.type, created: new Date(t).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.0", skuId: G, userId: this.anonId }, s = e ? p(o, e) : o, l = { url: J(a), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([s]) }; this.pendingRequest = bt(l, (function (t) { n.pendingRequest = null, i(t), n.saveEventData(), n.processRequests(r) })) } }, Q.prototype.queueRequest = function (t, e) { this.queue.push(t), this.processRequests(e) }; var tt, et, it = function (t) { function e() { t.call(this, "map.load"), this.success = {}, this.skuToken = "" } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postMapLoadEvent = function (t, e, i, r) { this.skuToken = i, (U.EVENTS_URL && r || U.ACCESS_TOKEN && Array.isArray(t) && t.some((function (t) { return X(t) || K(t) }))) && this.queueRequest({ id: e, timestamp: Date.now() }, r) }, e.prototype.processRequests = function (t) { var e = this; if (!this.pendingRequest && 0 !== this.queue.length) { var i = this.queue.shift(), r = i.id, n = i.timestamp; r && this.success[r] || (this.anonId || this.fetchEventData(), y(this.anonId) || (this.anonId = m()), this.postEvent(n, { skuToken: this.skuToken }, (function (t) { t || r && (e.success[r] = !0) }), t)) } }, e }(Q), rt = new (function (t) { function e(e) { t.call(this, "appUserTurnstile"), this._customAccessToken = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postTurnstileEvent = function (t, e) { U.EVENTS_URL && U.ACCESS_TOKEN && Array.isArray(t) && t.some((function (t) { return X(t) || K(t) })) && this.queueRequest(Date.now(), e) }, e.prototype.processRequests = function (t) { var e = this; if (!this.pendingRequest && 0 !== this.queue.length) { this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData(); var i = Y(U.ACCESS_TOKEN), r = i ? i.u : U.ACCESS_TOKEN, n = r !== this.eventData.tokenU; y(this.anonId) || (this.anonId = m(), n = !0); var a = this.queue.shift(); if (this.eventData.lastSuccess) { var o = new Date(this.eventData.lastSuccess), s = new Date(a), l = (a - this.eventData.lastSuccess) / 864e5; n = n || l >= 1 || l < -1 || o.getDate() !== s.getDate() } else n = !0; if (!n) return this.processRequests(); this.postEvent(a, { "enabled.telemetry": !1 }, (function (t) { t || (e.eventData.lastSuccess = a, e.eventData.tokenU = r) }), t) } }, e }(Q)), nt = rt.postTurnstileEvent.bind(rt), at = new it, ot = at.postMapLoadEvent.bind(at), st = 500, lt = 50; function ut() { o.caches && !tt && (tt = o.caches.open("mapbox-tiles")) } function ht(t) { var e = t.indexOf("?"); return e < 0 ? t : t.slice(0, e) } var ct, pt = 1 / 0; function ft() { return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct } var dt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" }; "function" == typeof Object.freeze && Object.freeze(dt); var mt, yt, gt = function (t) { function e(e, i, r) { 401 === i && K(r) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t.call(this, e), this.status = i, this.url = r, this.name = this.constructor.name, this.message = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.toString = function () { return this.name + ": " + this.message + " (" + this.status + "): " + this.url }, e }(Error), _t = I() ? function () { return self.worker && self.worker.referrer } : function () { return ("blob:" === o.location.protocol ? o.parent : o).location.href }, vt = function (t, e) { if (!(/^file:/.test(i = t.url) || /^file:/.test(_t()) && !/^\w+:/.test(i))) { if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal")) return function (t, e) { var i, r = new o.AbortController, n = new o.Request(t.url, { method: t.method || "GET", body: t.body, credentials: t.credentials, headers: t.headers, referrer: _t(), signal: r.signal }), a = !1, s = !1, l = (i = n.url).indexOf("sku=") > 0 && K(i); "json" === t.type && n.headers.set("Accept", "application/json"); var u = function (i, r, a) { if (!s) { if (i && "SecurityError" !== i.message && M(i), r && a) return h(r); var u = Date.now(); o.fetch(n).then((function (i) { if (i.ok) { var r = l ? i.clone() : null; return h(i, r, u) } return e(new gt(i.statusText, i.status, t.url)) })).catch((function (t) { 20 !== t.code && e(new Error(t.message)) })) } }, h = function (i, r, l) { ("arrayBuffer" === t.type ? i.arrayBuffer() : "json" === t.type ? i.json() : i.text()).then((function (t) { s || (r && l && function (t, e, i) { if (ut(), tt) { var r = { status: e.status, statusText: e.statusText, headers: new o.Headers }; e.headers.forEach((function (t, e) { return r.headers.set(e, t) })); var n = T(e.headers.get("Cache-Control") || ""); n["no-store"] || (n["max-age"] && r.headers.set("Expires", new Date(i + 1e3 * n["max-age"]).toUTCString()), new Date(r.headers.get("Expires")).getTime() - i < 42e4 || function (t, e) { if (void 0 === et) try { new Response(new ReadableStream), et = !0 } catch (t) { et = !1 } et ? e(t.body) : t.blob().then(e) }(e, (function (e) { var i = new o.Response(e, r); ut(), tt && tt.then((function (e) { return e.put(ht(t.url), i) })).catch((function (t) { return M(t.message) })) }))) } }(n, r, l), a = !0, e(null, t, i.headers.get("Cache-Control"), i.headers.get("Expires"))) })).catch((function (t) { s || e(new Error(t.message)) })) }; return l ? function (t, e) { if (ut(), !tt) return e(null); var i = ht(t.url); tt.then((function (t) { t.match(i).then((function (r) { var n = function (t) { if (!t) return !1; var e = new Date(t.headers.get("Expires") || 0), i = T(t.headers.get("Cache-Control") || ""); return e > Date.now() && !i["no-cache"] }(r); t.delete(i), n && t.put(i, r.clone()), e(null, r, n) })).catch(e) })).catch(e) }(n, u) : u(null, null), { cancel: function () { s = !0, a || r.abort() } } }(t, e); if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0) } var i; return function (t, e) { var i = new o.XMLHttpRequest; for (var r in i.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (i.responseType = "arraybuffer"), t.headers) i.setRequestHeader(r, t.headers[r]); return "json" === t.type && (i.responseType = "text", i.setRequestHeader("Accept", "application/json")), i.withCredentials = "include" === t.credentials, i.onerror = function () { e(new Error(i.statusText)) }, i.onload = function () { if ((i.status >= 200 && i.status < 300 || 0 === i.status) && null !== i.response) { var r = i.response; if ("json" === t.type) try { r = JSON.parse(i.response) } catch (t) { return e(t) } e(null, r, i.getResponseHeader("Cache-Control"), i.getResponseHeader("Expires")) } else e(new gt(i.statusText, i.status, t.url)) }, i.send(t.body), { cancel: function () { return i.abort() } } }(t, e) }, xt = function (t, e) { return vt(p(t, { type: "arrayBuffer" }), e) }, bt = function (t, e) { return vt(p(t, { method: "POST" }), e) }, wt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; mt = [], yt = 0; var Mt = function (t, e) { if (N.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), yt >= U.MAX_PARALLEL_IMAGE_REQUESTS) { var i = { requestParameters: t, callback: e, cancelled: !1, cancel: function () { this.cancelled = !0 } }; return mt.push(i), i } yt++; var r = !1, n = function () { if (!r) for (r = !0, yt--; mt.length && yt < U.MAX_PARALLEL_IMAGE_REQUESTS;) { var t = mt.shift(); t.cancelled || (t.cancel = Mt(t.requestParameters, t.callback).cancel) } }, a = xt(t, (function (t, i, r, a) { n(), t ? e(t) : i && (ft() ? function (t, e) { var i = new o.Blob([new Uint8Array(t)], { type: "image/png" }); o.createImageBitmap(i).then((function (t) { e(null, t) })).catch((function (t) { e(new Error("Could not load image because of " + t.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) })) }(i, e) : function (t, e, i, r) { var n = new o.Image, a = o.URL; n.onload = function () { e(null, n), a.revokeObjectURL(n.src), n.onload = null, n.src = wt }, n.onerror = function () { return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) }; var s = new o.Blob([new Uint8Array(t)], { type: "image/png" }); n.cacheControl = i, n.expires = r, n.src = t.byteLength ? a.createObjectURL(s) : wt }(i, e, r, a)) })); return { cancel: function () { a.cancel(), n() } } }; function St(t, e, i) { i[t] && -1 !== i[t].indexOf(e) || (i[t] = i[t] || [], i[t].push(e)) } function Et(t, e, i) { if (i && i[t]) { var r = i[t].indexOf(e); -1 !== r && i[t].splice(r, 1) } } var It = function (t, e) { void 0 === e && (e = {}), p(this, e), this.type = t }, Tt = function (t) { function e(e, i) { void 0 === i && (i = {}), t.call(this, "error", p({ error: e }, i)) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(It), At = function () { }; At.prototype.on = function (t, e) { return this._listeners = this._listeners || {}, St(t, e, this._listeners), this }, At.prototype.off = function (t, e) { return Et(t, e, this._listeners), Et(t, e, this._oneTimeListeners), this }, At.prototype.once = function (t, e) { return this._oneTimeListeners = this._oneTimeListeners || {}, St(t, e, this._oneTimeListeners), this }, At.prototype.fire = function (t, e) { "string" == typeof t && (t = new It(t, e || {})); var i = t.type; if (this.listens(i)) { t.target = this; for (var r = 0, n = this._listeners && this._listeners[i] ? this._listeners[i].slice() : []; r < n.length; r += 1)n[r].call(this, t); for (var a = 0, o = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : []; a < o.length; a += 1) { var s = o[a]; Et(i, s, this._oneTimeListeners), s.call(this, t) } var l = this._eventedParent; l && (p(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), l.fire(t)) } else t instanceof Tt && console.error(t.error); return this }, At.prototype.listens = function (t) { return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t) }, At.prototype.setEventedParent = function (t, e) { return this._eventedParent = t, this._eventedParentData = e, this }; var Pt = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, Ct = function (t, e, i, r) { this.message = (t ? t + ": " : "") + i, r && (this.identifier = r), null != e && e.__line__ && (this.line = e.__line__) }; function zt(t) { var e = t.value; return e ? [new Ct(t.key, e, "constants have been deprecated as of v8")] : [] } function kt(t) { for (var e = [], i = arguments.length - 1; i-- > 0;)e[i] = arguments[i + 1]; for (var r = 0, n = e; r < n.length; r += 1) { var a = n[r]; for (var o in a) t[o] = a[o] } return t } function Lt(t) { return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t } function Dt(t) { if (Array.isArray(t)) return t.map(Dt); if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) { var e = {}; for (var i in t) e[i] = Dt(t[i]); return e } return Lt(t) } var Rt = function (t) { function e(e, i) { t.call(this, i), this.message = i, this.key = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(Error), Bt = function (t, e) { void 0 === e && (e = []), this.parent = t, this.bindings = {}; for (var i = 0, r = e; i < r.length; i += 1) { var n = r[i]; this.bindings[n[0]] = n[1] } }; Bt.prototype.concat = function (t) { return new Bt(this, t) }, Bt.prototype.get = function (t) { if (this.bindings[t]) return this.bindings[t]; if (this.parent) return this.parent.get(t); throw new Error(t + " not found in scope.") }, Bt.prototype.has = function (t) { return !!this.bindings[t] || !!this.parent && this.parent.has(t) }; var Ot = { kind: "null" }, Ft = { kind: "number" }, Ut = { kind: "string" }, Nt = { kind: "boolean" }, Vt = { kind: "color" }, jt = { kind: "object" }, qt = { kind: "value" }, Gt = { kind: "collator" }, Zt = { kind: "formatted" }, Xt = { kind: "resolvedImage" }; function Wt(t, e) { return { kind: "array", itemType: t, N: e } } function Kt(t) { if ("array" === t.kind) { var e = Kt(t.itemType); return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">" } return t.kind } var Ht = [Ot, Ft, Ut, Nt, Vt, Zt, jt, Wt(qt), Xt]; function $t(t, e) { if ("error" === e.kind) return null; if ("array" === t.kind) { if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !$t(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null } else { if (t.kind === e.kind) return null; if ("value" === t.kind) for (var i = 0, r = Ht; i < r.length; i += 1)if (!$t(r[i], e)) return null } return "Expected " + Kt(t) + " but found " + Kt(e) + " instead." } function Jt(t, e) { return e.some((function (e) { return e.kind === t.kind })) } function Yt(t, e) { return e.some((function (e) { return "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t })) } var Qt = e((function (t, e) { var i = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function r(t) { return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t } function n(t) { return r("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t)) } function a(t) { return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e; var e } function o(t, e, i) { return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t } try { e.parseCSSColor = function (t) { var e, s = t.replace(/ /g, "").toLowerCase(); if (s in i) return i[s].slice(); if ("#" === s[0]) return 4 === s.length ? (e = parseInt(s.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === s.length && (e = parseInt(s.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null; var l = s.indexOf("("), u = s.indexOf(")"); if (-1 !== l && u + 1 === s.length) { var h = s.substr(0, l), c = s.substr(l + 1, u - (l + 1)).split(","), p = 1; switch (h) { case "rgba": if (4 !== c.length) return null; p = a(c.pop()); case "rgb": return 3 !== c.length ? null : [n(c[0]), n(c[1]), n(c[2]), p]; case "hsla": if (4 !== c.length) return null; p = a(c.pop()); case "hsl": if (3 !== c.length) return null; var f = (parseFloat(c[0]) % 360 + 360) % 360 / 360, d = a(c[1]), m = a(c[2]), y = m <= .5 ? m * (d + 1) : m + d - m * d, g = 2 * m - y; return [r(255 * o(g, y, f + 1 / 3)), r(255 * o(g, y, f)), r(255 * o(g, y, f - 1 / 3)), p]; default: return null } } return null } } catch (t) { } })).parseCSSColor, te = function (t, e, i, r) { void 0 === r && (r = 1), this.r = t, this.g = e, this.b = i, this.a = r }; te.parse = function (t) { if (t) { if (t instanceof te) return t; if ("string" == typeof t) { var e = Qt(t); if (e) return new te(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) } } }, te.prototype.toString = function () { var t = this.toArray(), e = t[1], i = t[2], r = t[3]; return "rgba(" + Math.round(t[0]) + "," + Math.round(e) + "," + Math.round(i) + "," + r + ")" }, te.prototype.toArray = function () { var t = this.a; return 0 === t ? [0, 0, 0, 0] : [255 * this.r / t, 255 * this.g / t, 255 * this.b / t, t] }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1); var ee = function (t, e, i) { this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = i, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) }; ee.prototype.compare = function (t, e) { return this.collator.compare(t, e) }, ee.prototype.resolvedLocale = function () { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale }; var ie = function (t, e, i, r, n) { this.text = t, this.image = e, this.scale = i, this.fontStack = r, this.textColor = n }, re = function (t) { this.sections = t }; re.fromString = function (t) { return new re([new ie(t, null, null, null, null)]) }, re.prototype.isEmpty = function () { return 0 === this.sections.length || !this.sections.some((function (t) { return 0 !== t.text.length || t.image && 0 !== t.image.name.length })) }, re.factory = function (t) { return t instanceof re ? t : re.fromString(t) }, re.prototype.toString = function () { return 0 === this.sections.length ? "" : this.sections.map((function (t) { return t.text })).join("") }, re.prototype.serialize = function () { for (var t = ["format"], e = 0, i = this.sections; e < i.length; e += 1) { var r = i[e]; if (r.image) t.push(["image", r.image.name]); else { t.push(r.text); var n = {}; r.fontStack && (n["text-font"] = ["literal", r.fontStack.split(",")]), r.scale && (n["font-scale"] = r.scale), r.textColor && (n["text-color"] = ["rgba"].concat(r.textColor.toArray())), t.push(n) } } return t }; var ne = function (t) { this.name = t.name, this.available = t.available }; function ae(t, e, i, r) { return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof i && i >= 0 && i <= 255 ? void 0 === r || "number" == typeof r && r >= 0 && r <= 1 ? null : "Invalid rgba value [" + [t, e, i, r].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof r ? [t, e, i, r] : [t, e, i]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255." } function oe(t) { if (null === t) return !0; if ("string" == typeof t) return !0; if ("boolean" == typeof t) return !0; if ("number" == typeof t) return !0; if (t instanceof te) return !0; if (t instanceof ee) return !0; if (t instanceof re) return !0; if (t instanceof ne) return !0; if (Array.isArray(t)) { for (var e = 0, i = t; e < i.length; e += 1)if (!oe(i[e])) return !1; return !0 } if ("object" == typeof t) { for (var r in t) if (!oe(t[r])) return !1; return !0 } return !1 } function se(t) { if (null === t) return Ot; if ("string" == typeof t) return Ut; if ("boolean" == typeof t) return Nt; if ("number" == typeof t) return Ft; if (t instanceof te) return Vt; if (t instanceof ee) return Gt; if (t instanceof re) return Zt; if (t instanceof ne) return Xt; if (Array.isArray(t)) { for (var e, i = t.length, r = 0, n = t; r < n.length; r += 1) { var a = se(n[r]); if (e) { if (e === a) continue; e = qt; break } e = a } return Wt(e || qt, i) } return jt } function le(t) { var e = typeof t; return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof te || t instanceof re || t instanceof ne ? t.toString() : JSON.stringify(t) } ne.prototype.toString = function () { return this.name }, ne.fromString = function (t) { return t ? new ne({ name: t, available: !1 }) : null }, ne.prototype.serialize = function () { return ["image", this.name] }; var ue = function (t, e) { this.type = t, this.value = e }; ue.parse = function (t, e) { if (2 !== t.length) return e.error("'literal' expression requires exactly one argument, but found " + (t.length - 1) + " instead."); if (!oe(t[1])) return e.error("invalid value"); var i = t[1], r = se(i), n = e.expectedType; return "array" !== r.kind || 0 !== r.N || !n || "array" !== n.kind || "number" == typeof n.N && 0 !== n.N || (r = n), new ue(r, i) }, ue.prototype.evaluate = function () { return this.value }, ue.prototype.eachChild = function () { }, ue.prototype.outputDefined = function () { return !0 }, ue.prototype.serialize = function () { return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof re ? this.value.serialize() : this.value }; var he = function (t) { this.name = "ExpressionEvaluationError", this.message = t }; he.prototype.toJSON = function () { return this.message }; var ce = { string: Ut, number: Ft, boolean: Nt, object: jt }, pe = function (t, e) { this.type = t, this.args = e }; pe.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var i, r = 1, n = t[0]; if ("array" === n) { var a, o; if (t.length > 2) { var s = t[1]; if ("string" != typeof s || !(s in ce) || "object" === s) return e.error('The item type argument of "array" must be one of string, number, boolean', 1); a = ce[s], r++ } else a = qt; if (t.length > 3) { if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2); o = t[2], r++ } i = Wt(a, o) } else i = ce[n]; for (var l = []; r < t.length; r++) { var u = e.parse(t[r], r, qt); if (!u) return null; l.push(u) } return new pe(i, l) }, pe.prototype.evaluate = function (t) { for (var e = 0; e < this.args.length; e++) { var i = this.args[e].evaluate(t); if (!$t(this.type, se(i))) return i; if (e === this.args.length - 1) throw new he("Expected value to be of type " + Kt(this.type) + ", but found " + Kt(se(i)) + " instead.") } return null }, pe.prototype.eachChild = function (t) { this.args.forEach(t) }, pe.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, pe.prototype.serialize = function () { var t = this.type, e = [t.kind]; if ("array" === t.kind) { var i = t.itemType; if ("string" === i.kind || "number" === i.kind || "boolean" === i.kind) { e.push(i.kind); var r = t.N; ("number" == typeof r || this.args.length > 1) && e.push(r) } } return e.concat(this.args.map((function (t) { return t.serialize() }))) }; var fe = function (t) { this.type = Zt, this.sections = t }; fe.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var i = t[1]; if (!Array.isArray(i) && "object" == typeof i) return e.error("First argument must be an image or text section."); for (var r = [], n = !1, a = 1; a <= t.length - 1; ++a) { var o = t[a]; if (n && "object" == typeof o && !Array.isArray(o)) { n = !1; var s = null; if (o["font-scale"] && !(s = e.parse(o["font-scale"], 1, Ft))) return null; var l = null; if (o["text-font"] && !(l = e.parse(o["text-font"], 1, Wt(Ut)))) return null; var u = null; if (o["text-color"] && !(u = e.parse(o["text-color"], 1, Vt))) return null; var h = r[r.length - 1]; h.scale = s, h.font = l, h.textColor = u } else { var c = e.parse(t[a], 1, qt); if (!c) return null; var p = c.type.kind; if ("string" !== p && "value" !== p && "null" !== p && "resolvedImage" !== p) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); n = !0, r.push({ content: c, scale: null, font: null, textColor: null }) } } return new fe(r) }, fe.prototype.evaluate = function (t) { return new re(this.sections.map((function (e) { var i = e.content.evaluate(t); return se(i) === Xt ? new ie("", i, null, null, null) : new ie(le(i), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null) }))) }, fe.prototype.eachChild = function (t) { for (var e = 0, i = this.sections; e < i.length; e += 1) { var r = i[e]; t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor) } }, fe.prototype.outputDefined = function () { return !1 }, fe.prototype.serialize = function () { for (var t = ["format"], e = 0, i = this.sections; e < i.length; e += 1) { var r = i[e]; t.push(r.content.serialize()); var n = {}; r.scale && (n["font-scale"] = r.scale.serialize()), r.font && (n["text-font"] = r.font.serialize()), r.textColor && (n["text-color"] = r.textColor.serialize()), t.push(n) } return t }; var de = function (t) { this.type = Xt, this.input = t }; de.parse = function (t, e) { if (2 !== t.length) return e.error("Expected two arguments."); var i = e.parse(t[1], 1, Ut); return i ? new de(i) : e.error("No image name provided.") }, de.prototype.evaluate = function (t) { var e = this.input.evaluate(t), i = ne.fromString(e); return i && t.availableImages && (i.available = t.availableImages.indexOf(e) > -1), i }, de.prototype.eachChild = function (t) { t(this.input) }, de.prototype.outputDefined = function () { return !1 }, de.prototype.serialize = function () { return ["image", this.input.serialize()] }; var me = { "to-boolean": Nt, "to-color": Vt, "to-number": Ft, "to-string": Ut }, ye = function (t, e) { this.type = t, this.args = e }; ye.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); var i = t[0]; if (("to-boolean" === i || "to-string" === i) && 2 !== t.length) return e.error("Expected one argument."); for (var r = me[i], n = [], a = 1; a < t.length; a++) { var o = e.parse(t[a], a, qt); if (!o) return null; n.push(o) } return new ye(r, n) }, ye.prototype.evaluate = function (t) { if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t)); if ("color" === this.type.kind) { for (var e, i, r = 0, n = this.args; r < n.length; r += 1) { if (i = null, (e = n[r].evaluate(t)) instanceof te) return e; if ("string" == typeof e) { var a = t.parseColor(e); if (a) return a } else if (Array.isArray(e) && !(i = e.length < 3 || e.length > 4 ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : ae(e[0], e[1], e[2], e[3]))) return new te(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) } throw new he(i || "Could not parse color from value '" + ("string" == typeof e ? e : String(JSON.stringify(e))) + "'") } if ("number" === this.type.kind) { for (var o = null, s = 0, l = this.args; s < l.length; s += 1) { if (null === (o = l[s].evaluate(t))) return 0; var u = Number(o); if (!isNaN(u)) return u } throw new he("Could not convert " + JSON.stringify(o) + " to number.") } return "formatted" === this.type.kind ? re.fromString(le(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? ne.fromString(le(this.args[0].evaluate(t))) : le(this.args[0].evaluate(t)) }, ye.prototype.eachChild = function (t) { this.args.forEach(t) }, ye.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, ye.prototype.serialize = function () { if ("formatted" === this.type.kind) return new fe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize(); if ("resolvedImage" === this.type.kind) return new de(this.args[0]).serialize(); var t = ["to-" + this.type.kind]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var ge = ["Unknown", "Point", "LineString", "Polygon"], _e = function () { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null }; _e.prototype.id = function () { return this.feature && "id" in this.feature ? this.feature.id : null }, _e.prototype.geometryType = function () { return this.feature ? "number" == typeof this.feature.type ? ge[this.feature.type] : this.feature.type : null }, _e.prototype.geometry = function () { return this.feature && "geometry" in this.feature ? this.feature.geometry : null }, _e.prototype.canonicalID = function () { return this.canonical }, _e.prototype.properties = function () { return this.feature && this.feature.properties || {} }, _e.prototype.parseColor = function (t) { var e = this._parseColorCache[t]; return e || (e = this._parseColorCache[t] = te.parse(t)), e }; var ve = function (t, e, i, r) { this.name = t, this.type = e, this._evaluate = i, this.args = r }; ve.prototype.evaluate = function (t) { return this._evaluate(t, this.args) }, ve.prototype.eachChild = function (t) { this.args.forEach(t) }, ve.prototype.outputDefined = function () { return !1 }, ve.prototype.serialize = function () { return [this.name].concat(this.args.map((function (t) { return t.serialize() }))) }, ve.parse = function (t, e) { var i, r = t[0], n = ve.definitions[r]; if (!n) return e.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0); for (var a = Array.isArray(n) ? n[0] : n.type, o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, s = o.filter((function (e) { var i = e[0]; return !Array.isArray(i) || i.length === t.length - 1 })), l = null, u = 0, h = s; u < h.length; u += 1) { var c = h[u], p = c[0], f = c[1]; l = new Ve(e.registry, e.path, null, e.scope); for (var d = [], m = !1, y = 1; y < t.length; y++) { var g = t[y], _ = Array.isArray(p) ? p[y - 1] : p.type, v = l.parse(g, 1 + d.length, _); if (!v) { m = !0; break } d.push(v) } if (!m) if (Array.isArray(p) && p.length !== d.length) l.error("Expected " + p.length + " arguments, but found " + d.length + " instead."); else { for (var x = 0; x < d.length; x++) { var b = Array.isArray(p) ? p[x] : p.type, w = d[x]; l.concat(x + 1).checkSubtype(b, w.type) } if (0 === l.errors.length) return new ve(r, a, f, d) } } if (1 === s.length) (i = e.errors).push.apply(i, l.errors); else { for (var M = (s.length ? s : o).map((function (t) { var e; return e = t[0], Array.isArray(e) ? "(" + e.map(Kt).join(", ") + ")" : "(" + Kt(e.type) + "...)" })).join(" | "), S = [], E = 1; E < t.length; E++) { var I = e.parse(t[E], 1 + S.length); if (!I) return null; S.push(Kt(I.type)) } e.error("Expected arguments of type " + M + ", but found (" + S.join(", ") + ") instead.") } return null }, ve.register = function (t, e) { for (var i in ve.definitions = e, e) t[i] = ve }; var xe = function (t, e, i) { this.type = Gt, this.locale = i, this.caseSensitive = t, this.diacriticSensitive = e }; function be(t, e) { t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]) } function we(t, e) { return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]) } function Me(t, e) { var i = (180 + t[0]) / 360, r = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360, n = Math.pow(2, e.z); return [Math.round(i * n * 8192), Math.round(r * n * 8192)] } function Se(t, e, i) { return e[1] > t[1] != i[1] > t[1] && t[0] < (i[0] - e[0]) * (t[1] - e[1]) / (i[1] - e[1]) + e[0] } function Ee(t, e) { for (var i, r, n, a, o, s, l, u = !1, h = 0, c = e.length; h < c; h++)for (var p = e[h], f = 0, d = p.length; f < d - 1; f++) { if ((a = (i = t)[0] - (r = p[f])[0]) * (l = i[1] - (n = p[f + 1])[1]) - (s = i[0] - n[0]) * (o = i[1] - r[1]) == 0 && a * s <= 0 && o * l <= 0) return !1; Se(t, p[f], p[f + 1]) && (u = !u) } return u } function Ie(t, e) { for (var i = 0; i < e.length; i++)if (Ee(t, e[i])) return !0; return !1 } function Te(t, e, i, r) { var n = r[0] - i[0], a = r[1] - i[1], o = (t[0] - i[0]) * a - n * (t[1] - i[1]), s = (e[0] - i[0]) * a - n * (e[1] - i[1]); return o > 0 && s < 0 || o < 0 && s > 0 } function Ae(t, e, i) { for (var r = 0, n = i; r < n.length; r += 1)for (var a = n[r], o = 0; o < a.length - 1; ++o)if (0 != (c = [(h = a[o + 1])[0] - (u = a[o])[0], h[1] - u[1]])[0] * (p = [(l = e)[0] - (s = t)[0], l[1] - s[1]])[1] - c[1] * p[0] && Te(s, l, u, h) && Te(u, h, s, l)) return !0; var s, l, u, h, c, p; return !1 } function Pe(t, e) { for (var i = 0; i < t.length; ++i)if (!Ee(t[i], e)) return !1; for (var r = 0; r < t.length - 1; ++r)if (Ae(t[r], t[r + 1], e)) return !1; return !0 } function Ce(t, e) { for (var i = 0; i < e.length; i++)if (Pe(t, e[i])) return !0; return !1 } function ze(t, e, i) { for (var r = [], n = 0; n < t.length; n++) { for (var a = [], o = 0; o < t[n].length; o++) { var s = Me(t[n][o], i); be(e, s), a.push(s) } r.push(a) } return r } function ke(t, e, i) { for (var r = [], n = 0; n < t.length; n++) { var a = ze(t[n], e, i); r.push(a) } return r } function Le(t, e, i, r) { if (t[0] < i[0] || t[0] > i[2]) { var n = .5 * r, a = t[0] - i[0] > n ? -r : i[0] - t[0] > n ? r : 0; 0 === a && (a = t[0] - i[2] > n ? -r : i[2] - t[0] > n ? r : 0), t[0] += a } be(e, t) } function De(t, e, i, r) { for (var n = 8192 * Math.pow(2, r.z), a = [8192 * r.x, 8192 * r.y], o = [], s = 0, l = t; s < l.length; s += 1)for (var u = 0, h = l[s]; u < h.length; u += 1) { var c = h[u], p = [c.x + a[0], c.y + a[1]]; Le(p, e, i, n), o.push(p) } return o } function Re(t, e, i, r) { for (var n, a = 8192 * Math.pow(2, r.z), o = [8192 * r.x, 8192 * r.y], s = [], l = 0, u = t; l < u.length; l += 1) { for (var h = [], c = 0, p = u[l]; c < p.length; c += 1) { var f = p[c], d = [f.x + o[0], f.y + o[1]]; be(e, d), h.push(d) } s.push(h) } if (e[2] - e[0] <= a / 2) { (n = e)[0] = n[1] = 1 / 0, n[2] = n[3] = -1 / 0; for (var m = 0, y = s; m < y.length; m += 1)for (var g = 0, _ = y[m]; g < _.length; g += 1)Le(_[g], e, i, a) } return s } xe.parse = function (t, e) { if (2 !== t.length) return e.error("Expected one argument."); var i = t[1]; if ("object" != typeof i || Array.isArray(i)) return e.error("Collator options argument must be an object."); var r = e.parse(void 0 !== i["case-sensitive"] && i["case-sensitive"], 1, Nt); if (!r) return null; var n = e.parse(void 0 !== i["diacritic-sensitive"] && i["diacritic-sensitive"], 1, Nt); if (!n) return null; var a = null; return i.locale && !(a = e.parse(i.locale, 1, Ut)) ? null : new xe(r, n, a) }, xe.prototype.evaluate = function (t) { return new ee(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null) }, xe.prototype.eachChild = function (t) { t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale) }, xe.prototype.outputDefined = function () { return !1 }, xe.prototype.serialize = function () { var t = {}; return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t] }; var Be = function (t, e) { this.type = Nt, this.geojson = t, this.geometries = e }; function Oe(t) { if (t instanceof ve) { if ("get" === t.name && 1 === t.args.length) return !1; if ("feature-state" === t.name) return !1; if ("has" === t.name && 1 === t.args.length) return !1; if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1; if (/^filter-/.test(t.name)) return !1 } if (t instanceof Be) return !1; var e = !0; return t.eachChild((function (t) { e && !Oe(t) && (e = !1) })), e } function Fe(t) { if (t instanceof ve && "feature-state" === t.name) return !1; var e = !0; return t.eachChild((function (t) { e && !Fe(t) && (e = !1) })), e } function Ue(t, e) { if (t instanceof ve && e.indexOf(t.name) >= 0) return !1; var i = !0; return t.eachChild((function (t) { i && !Ue(t, e) && (i = !1) })), i } Be.parse = function (t, e) { if (2 !== t.length) return e.error("'within' expression requires exactly one argument, but found " + (t.length - 1) + " instead."); if (oe(t[1])) { var i = t[1]; if ("FeatureCollection" === i.type) for (var r = 0; r < i.features.length; ++r) { var n = i.features[r].geometry.type; if ("Polygon" === n || "MultiPolygon" === n) return new Be(i, i.features[r].geometry) } else if ("Feature" === i.type) { var a = i.geometry.type; if ("Polygon" === a || "MultiPolygon" === a) return new Be(i, i.geometry) } else if ("Polygon" === i.type || "MultiPolygon" === i.type) return new Be(i, i) } return e.error("'within' expression requires valid geojson object that contains polygon geometry type.") }, Be.prototype.evaluate = function (t) { if (null != t.geometry() && null != t.canonicalID()) { if ("Point" === t.geometryType()) return function (t, e) { var i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = t.canonicalID(); if ("Polygon" === e.type) { var a = ze(e.coordinates, r, n), o = De(t.geometry(), i, r, n); if (!we(i, r)) return !1; for (var s = 0, l = o; s < l.length; s += 1)if (!Ee(l[s], a)) return !1 } if ("MultiPolygon" === e.type) { var u = ke(e.coordinates, r, n), h = De(t.geometry(), i, r, n); if (!we(i, r)) return !1; for (var c = 0, p = h; c < p.length; c += 1)if (!Ie(p[c], u)) return !1 } return !0 }(t, this.geometries); if ("LineString" === t.geometryType()) return function (t, e) { var i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = t.canonicalID(); if ("Polygon" === e.type) { var a = ze(e.coordinates, r, n), o = Re(t.geometry(), i, r, n); if (!we(i, r)) return !1; for (var s = 0, l = o; s < l.length; s += 1)if (!Pe(l[s], a)) return !1 } if ("MultiPolygon" === e.type) { var u = ke(e.coordinates, r, n), h = Re(t.geometry(), i, r, n); if (!we(i, r)) return !1; for (var c = 0, p = h; c < p.length; c += 1)if (!Ce(p[c], u)) return !1 } return !0 }(t, this.geometries) } return !1 }, Be.prototype.eachChild = function () { }, Be.prototype.outputDefined = function () { return !0 }, Be.prototype.serialize = function () { return ["within", this.geojson] }; var Ne = function (t, e) { this.type = e.type, this.name = t, this.boundExpression = e }; Ne.parse = function (t, e) { if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument."); var i = t[1]; return e.scope.has(i) ? new Ne(i, e.scope.get(i)) : e.error('Unknown variable "' + i + '". Make sure "' + i + '" has been bound in an enclosing "let" expression before using it.', 1) }, Ne.prototype.evaluate = function (t) { return this.boundExpression.evaluate(t) }, Ne.prototype.eachChild = function () { }, Ne.prototype.outputDefined = function () { return !1 }, Ne.prototype.serialize = function () { return ["var", this.name] }; var Ve = function (t, e, i, r, n) { void 0 === e && (e = []), void 0 === r && (r = new Bt), void 0 === n && (n = []), this.registry = t, this.path = e, this.key = e.map((function (t) { return "[" + t + "]" })).join(""), this.scope = r, this.errors = n, this.expectedType = i }; function je(t, e) { for (var i, r = t.length - 1, n = 0, a = r, o = 0; n <= a;)if ((i = t[o = Math.floor((n + a) / 2)]) <= e) { if (o === r || e < t[o + 1]) return o; n = o + 1 } else { if (!(i > e)) throw new he("Input is not a number."); a = o - 1 } return 0 } Ve.prototype.parse = function (t, e, i, r, n) { return void 0 === n && (n = {}), e ? this.concat(e, i, r)._parse(t, n) : this._parse(t, n) }, Ve.prototype._parse = function (t, e) { function i(t, e, i) { return "assert" === i ? new pe(e, [t]) : "coerce" === i ? new ye(e, [t]) : t } if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) { if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); var r = t[0]; if ("string" != typeof r) return this.error("Expression name must be a string, but found " + typeof r + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null; var n = this.registry[r]; if (n) { var a = n.parse(t, this); if (!a) return null; if (this.expectedType) { var o = this.expectedType, s = a.type; if ("string" !== o.kind && "number" !== o.kind && "boolean" !== o.kind && "object" !== o.kind && "array" !== o.kind || "value" !== s.kind) if ("color" !== o.kind && "formatted" !== o.kind && "resolvedImage" !== o.kind || "value" !== s.kind && "string" !== s.kind) { if (this.checkSubtype(o, s)) return null } else a = i(a, o, e.typeAnnotation || "coerce"); else a = i(a, o, e.typeAnnotation || "assert") } if (!(a instanceof ue) && "resolvedImage" !== a.type.kind && function t(e) { if (e instanceof Ne) return t(e.boundExpression); if (e instanceof ve && "error" === e.name) return !1; if (e instanceof xe) return !1; if (e instanceof Be) return !1; var i = e instanceof ye || e instanceof pe, r = !0; return e.eachChild((function (e) { r = i ? r && t(e) : r && e instanceof ue })), !!r && Oe(e) && Ue(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) }(a)) { var l = new _e; try { a = new ue(a.type, a.evaluate(l)) } catch (t) { return this.error(t.message), null } } return a } return this.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0) } return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof t + " instead.") }, Ve.prototype.concat = function (t, e, i) { var r = "number" == typeof t ? this.path.concat(t) : this.path, n = i ? this.scope.concat(i) : this.scope; return new Ve(this.registry, r, e || null, n, this.errors) }, Ve.prototype.error = function (t) { for (var e = [], i = arguments.length - 1; i-- > 0;)e[i] = arguments[i + 1]; var r = "" + this.key + e.map((function (t) { return "[" + t + "]" })).join(""); this.errors.push(new Rt(r, t)) }, Ve.prototype.checkSubtype = function (t, e) { var i = $t(t, e); return i && this.error(i), i }; var qe = function (t, e, i) { this.type = t, this.input = e, this.labels = [], this.outputs = []; for (var r = 0, n = i; r < n.length; r += 1) { var a = n[r], o = a[1]; this.labels.push(a[0]), this.outputs.push(o) } }; function Ge(t, e, i) { return t * (1 - i) + e * i } qe.parse = function (t, e) { if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); var i = e.parse(t[1], 1, Ft); if (!i) return null; var r = [], n = null; e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType); for (var a = 1; a < t.length; a += 2) { var o = 1 === a ? -1 / 0 : t[a], s = t[a + 1], l = a, u = a + 1; if ("number" != typeof o) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', l); if (r.length && r[r.length - 1][0] >= o) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', l); var h = e.parse(s, u, n); if (!h) return null; n = n || h.type, r.push([o, h]) } return new qe(n, i, r) }, qe.prototype.evaluate = function (t) { var e = this.labels, i = this.outputs; if (1 === e.length) return i[0].evaluate(t); var r = this.input.evaluate(t); if (r <= e[0]) return i[0].evaluate(t); var n = e.length; return r >= e[n - 1] ? i[n - 1].evaluate(t) : i[je(e, r)].evaluate(t) }, qe.prototype.eachChild = function (t) { t(this.input); for (var e = 0, i = this.outputs; e < i.length; e += 1)t(i[e]) }, qe.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) }, qe.prototype.serialize = function () { for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++)e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize()); return t }; var Ze = Object.freeze({ __proto__: null, number: Ge, color: function (t, e, i) { return new te(Ge(t.r, e.r, i), Ge(t.g, e.g, i), Ge(t.b, e.b, i), Ge(t.a, e.a, i)) }, array: function (t, e, i) { return t.map((function (t, r) { return Ge(t, e[r], i) })) } }), Xe = 6 / 29 * 3 * (6 / 29), We = Math.PI / 180, Ke = 180 / Math.PI; function He(t) { return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Xe + 4 / 29 } function $e(t) { return t > 6 / 29 ? t * t * t : Xe * (t - 4 / 29) } function Je(t) { return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) } function Ye(t) { return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } function Qe(t) { var e = Ye(t.r), i = Ye(t.g), r = Ye(t.b), n = He((.4124564 * e + .3575761 * i + .1804375 * r) / .95047), a = He((.2126729 * e + .7151522 * i + .072175 * r) / 1); return { l: 116 * a - 16, a: 500 * (n - a), b: 200 * (a - He((.0193339 * e + .119192 * i + .9503041 * r) / 1.08883)), alpha: t.a } } function ti(t) { var e = (t.l + 16) / 116, i = isNaN(t.a) ? e : e + t.a / 500, r = isNaN(t.b) ? e : e - t.b / 200; return e = 1 * $e(e), i = .95047 * $e(i), r = 1.08883 * $e(r), new te(Je(3.2404542 * i - 1.5371385 * e - .4985314 * r), Je(-.969266 * i + 1.8760108 * e + .041556 * r), Je(.0556434 * i - .2040259 * e + 1.0572252 * r), t.alpha) } function ei(t, e, i) { var r = e - t; return t + i * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) } var ii = { forward: Qe, reverse: ti, interpolate: function (t, e, i) { return { l: Ge(t.l, e.l, i), a: Ge(t.a, e.a, i), b: Ge(t.b, e.b, i), alpha: Ge(t.alpha, e.alpha, i) } } }, ri = { forward: function (t) { var e = Qe(t), i = e.l, r = e.a, n = e.b, a = Math.atan2(n, r) * Ke; return { h: a < 0 ? a + 360 : a, c: Math.sqrt(r * r + n * n), l: i, alpha: t.a } }, reverse: function (t) { var e = t.h * We, i = t.c; return ti({ l: t.l, a: Math.cos(e) * i, b: Math.sin(e) * i, alpha: t.alpha }) }, interpolate: function (t, e, i) { return { h: ei(t.h, e.h, i), c: Ge(t.c, e.c, i), l: Ge(t.l, e.l, i), alpha: Ge(t.alpha, e.alpha, i) } } }, ni = Object.freeze({ __proto__: null, lab: ii, hcl: ri }), ai = function (t, e, i, r, n) { this.type = t, this.operator = e, this.interpolation = i, this.input = r, this.labels = [], this.outputs = []; for (var a = 0, o = n; a < o.length; a += 1) { var s = o[a], l = s[1]; this.labels.push(s[0]), this.outputs.push(l) } }; function oi(t, e, i, r) { var n = r - i, a = t - i; return 0 === n ? 0 : 1 === e ? a / n : (Math.pow(e, a) - 1) / (Math.pow(e, n) - 1) } ai.interpolationFactor = function (t, e, r, n) { var a = 0; if ("exponential" === t.name) a = oi(e, t.base, r, n); else if ("linear" === t.name) a = oi(e, 1, r, n); else if ("cubic-bezier" === t.name) { var o = t.controlPoints; a = new i(o[0], o[1], o[2], o[3]).solve(oi(e, 1, r, n)) } return a }, ai.parse = function (t, e) { var i = t[0], r = t[1], n = t[2], a = t.slice(3); if (!Array.isArray(r) || 0 === r.length) return e.error("Expected an interpolation type expression.", 1); if ("linear" === r[0]) r = { name: "linear" }; else if ("exponential" === r[0]) { var o = r[1]; if ("number" != typeof o) return e.error("Exponential interpolation requires a numeric base.", 1, 1); r = { name: "exponential", base: o } } else { if ("cubic-bezier" !== r[0]) return e.error("Unknown interpolation type " + String(r[0]), 1, 0); var s = r.slice(1); if (4 !== s.length || s.some((function (t) { return "number" != typeof t || t < 0 || t > 1 }))) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); r = { name: "cubic-bezier", controlPoints: s } } if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); if (!(n = e.parse(n, 2, Ft))) return null; var l = [], u = null; "interpolate-hcl" === i || "interpolate-lab" === i ? u = Vt : e.expectedType && "value" !== e.expectedType.kind && (u = e.expectedType); for (var h = 0; h < a.length; h += 2) { var c = a[h], p = a[h + 1], f = h + 3, d = h + 4; if ("number" != typeof c) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f); if (l.length && l[l.length - 1][0] >= c) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f); var m = e.parse(p, d, u); if (!m) return null; u = u || m.type, l.push([c, m]) } return "number" === u.kind || "color" === u.kind || "array" === u.kind && "number" === u.itemType.kind && "number" == typeof u.N ? new ai(u, i, r, n, l) : e.error("Type " + Kt(u) + " is not interpolatable.") }, ai.prototype.evaluate = function (t) { var e = this.labels, i = this.outputs; if (1 === e.length) return i[0].evaluate(t); var r = this.input.evaluate(t); if (r <= e[0]) return i[0].evaluate(t); var n = e.length; if (r >= e[n - 1]) return i[n - 1].evaluate(t); var a = je(e, r), o = ai.interpolationFactor(this.interpolation, r, e[a], e[a + 1]), s = i[a].evaluate(t), l = i[a + 1].evaluate(t); return "interpolate" === this.operator ? Ze[this.type.kind.toLowerCase()](s, l, o) : "interpolate-hcl" === this.operator ? ri.reverse(ri.interpolate(ri.forward(s), ri.forward(l), o)) : ii.reverse(ii.interpolate(ii.forward(s), ii.forward(l), o)) }, ai.prototype.eachChild = function (t) { t(this.input); for (var e = 0, i = this.outputs; e < i.length; e += 1)t(i[e]) }, ai.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) }, ai.prototype.serialize = function () { var t; t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints); for (var e = [this.operator, t, this.input.serialize()], i = 0; i < this.labels.length; i++)e.push(this.labels[i], this.outputs[i].serialize()); return e }; var si = function (t, e) { this.type = t, this.args = e }; si.parse = function (t, e) { if (t.length < 2) return e.error("Expectected at least one argument."); var i = null, r = e.expectedType; r && "value" !== r.kind && (i = r); for (var n = [], a = 0, o = t.slice(1); a < o.length; a += 1) { var s = e.parse(o[a], 1 + n.length, i, void 0, { typeAnnotation: "omit" }); if (!s) return null; i = i || s.type, n.push(s) } var l = r && n.some((function (t) { return $t(r, t.type) })); return new si(l ? qt : i, n) }, si.prototype.evaluate = function (t) { for (var e, i = null, r = 0, n = 0, a = this.args; n < a.length && (r++, (i = a[n].evaluate(t)) && i instanceof ne && !i.available && (e || (e = i.name), i = null, r === this.args.length && (i = e)), null === i); n += 1); return i }, si.prototype.eachChild = function (t) { this.args.forEach(t) }, si.prototype.outputDefined = function () { return this.args.every((function (t) { return t.outputDefined() })) }, si.prototype.serialize = function () { var t = ["coalesce"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var li = function (t, e) { this.type = e.type, this.bindings = [].concat(t), this.result = e }; li.prototype.evaluate = function (t) { return this.result.evaluate(t) }, li.prototype.eachChild = function (t) { for (var e = 0, i = this.bindings; e < i.length; e += 1)t(i[e][1]); t(this.result) }, li.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead."); for (var i = [], r = 1; r < t.length - 1; r += 2) { var n = t[r]; if ("string" != typeof n) return e.error("Expected string, but found " + typeof n + " instead.", r); if (/[^a-zA-Z0-9_]/.test(n)) return e.error("Variable names must contain only alphanumeric characters or '_'.", r); var a = e.parse(t[r + 1], r + 1); if (!a) return null; i.push([n, a]) } var o = e.parse(t[t.length - 1], t.length - 1, e.expectedType, i); return o ? new li(i, o) : null }, li.prototype.outputDefined = function () { return this.result.outputDefined() }, li.prototype.serialize = function () { for (var t = ["let"], e = 0, i = this.bindings; e < i.length; e += 1) { var r = i[e]; t.push(r[0], r[1].serialize()) } return t.push(this.result.serialize()), t }; var ui = function (t, e, i) { this.type = t, this.index = e, this.input = i }; ui.parse = function (t, e) { if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead."); var i = e.parse(t[1], 1, Ft), r = e.parse(t[2], 2, Wt(e.expectedType || qt)); return i && r ? new ui(r.type.itemType, i, r) : null }, ui.prototype.evaluate = function (t) { var e = this.index.evaluate(t), i = this.input.evaluate(t); if (e < 0) throw new he("Array index out of bounds: " + e + " < 0."); if (e >= i.length) throw new he("Array index out of bounds: " + e + " > " + (i.length - 1) + "."); if (e !== Math.floor(e)) throw new he("Array index must be an integer, but found " + e + " instead."); return i[e] }, ui.prototype.eachChild = function (t) { t(this.index), t(this.input) }, ui.prototype.outputDefined = function () { return !1 }, ui.prototype.serialize = function () { return ["at", this.index.serialize(), this.input.serialize()] }; var hi = function (t, e) { this.type = Nt, this.needle = t, this.haystack = e }; hi.parse = function (t, e) { if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead."); var i = e.parse(t[1], 1, qt), r = e.parse(t[2], 2, qt); return i && r ? Jt(i.type, [Nt, Ut, Ft, Ot, qt]) ? new hi(i, r) : e.error("Expected first argument to be of type boolean, string, number or null, but found " + Kt(i.type) + " instead") : null }, hi.prototype.evaluate = function (t) { var e = this.needle.evaluate(t), i = this.haystack.evaluate(t); if (!i) return !1; if (!Yt(e, ["boolean", "string", "number", "null"])) throw new he("Expected first argument to be of type boolean, string, number or null, but found " + Kt(se(e)) + " instead."); if (!Yt(i, ["string", "array"])) throw new he("Expected second argument to be of type array or string, but found " + Kt(se(i)) + " instead."); return i.indexOf(e) >= 0 }, hi.prototype.eachChild = function (t) { t(this.needle), t(this.haystack) }, hi.prototype.outputDefined = function () { return !0 }, hi.prototype.serialize = function () { return ["in", this.needle.serialize(), this.haystack.serialize()] }; var ci = function (t, e, i) { this.type = Ft, this.needle = t, this.haystack = e, this.fromIndex = i }; ci.parse = function (t, e) { if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead."); var i = e.parse(t[1], 1, qt), r = e.parse(t[2], 2, qt); if (!i || !r) return null; if (!Jt(i.type, [Nt, Ut, Ft, Ot, qt])) return e.error("Expected first argument to be of type boolean, string, number or null, but found " + Kt(i.type) + " instead"); if (4 === t.length) { var n = e.parse(t[3], 3, Ft); return n ? new ci(i, r, n) : null } return new ci(i, r) }, ci.prototype.evaluate = function (t) { var e = this.needle.evaluate(t), i = this.haystack.evaluate(t); if (!Yt(e, ["boolean", "string", "number", "null"])) throw new he("Expected first argument to be of type boolean, string, number or null, but found " + Kt(se(e)) + " instead."); if (!Yt(i, ["string", "array"])) throw new he("Expected second argument to be of type array or string, but found " + Kt(se(i)) + " instead."); if (this.fromIndex) { var r = this.fromIndex.evaluate(t); return i.indexOf(e, r) } return i.indexOf(e) }, ci.prototype.eachChild = function (t) { t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex) }, ci.prototype.outputDefined = function () { return !1 }, ci.prototype.serialize = function () { if (null != this.fromIndex && void 0 !== this.fromIndex) { var t = this.fromIndex.serialize(); return ["index-of", this.needle.serialize(), this.haystack.serialize(), t] } return ["index-of", this.needle.serialize(), this.haystack.serialize()] }; var pi = function (t, e, i, r, n, a) { this.inputType = t, this.type = e, this.input = i, this.cases = r, this.outputs = n, this.otherwise = a }; pi.parse = function (t, e) { if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 1) return e.error("Expected an even number of arguments."); var i, r; e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType); for (var n = {}, a = [], o = 2; o < t.length - 1; o += 2) { var s = t[o], l = t[o + 1]; Array.isArray(s) || (s = [s]); var u = e.concat(o); if (0 === s.length) return u.error("Expected at least one branch label."); for (var h = 0, c = s; h < c.length; h += 1) { var p = c[h]; if ("number" != typeof p && "string" != typeof p) return u.error("Branch labels must be numbers or strings."); if ("number" == typeof p && Math.abs(p) > Number.MAX_SAFE_INTEGER) return u.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + "."); if ("number" == typeof p && Math.floor(p) !== p) return u.error("Numeric branch labels must be integer values."); if (i) { if (u.checkSubtype(i, se(p))) return null } else i = se(p); if (void 0 !== n[String(p)]) return u.error("Branch labels must be unique."); n[String(p)] = a.length } var f = e.parse(l, o, r); if (!f) return null; r = r || f.type, a.push(f) } var d = e.parse(t[1], 1, qt); if (!d) return null; var m = e.parse(t[t.length - 1], t.length - 1, r); return m ? "value" !== d.type.kind && e.concat(1).checkSubtype(i, d.type) ? null : new pi(i, r, d, n, a, m) : null }, pi.prototype.evaluate = function (t) { var e = this.input.evaluate(t); return (se(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t) }, pi.prototype.eachChild = function (t) { t(this.input), this.outputs.forEach(t), t(this.otherwise) }, pi.prototype.outputDefined = function () { return this.outputs.every((function (t) { return t.outputDefined() })) && this.otherwise.outputDefined() }, pi.prototype.serialize = function () { for (var t = this, e = ["match", this.input.serialize()], i = [], r = {}, n = 0, a = Object.keys(this.cases).sort(); n < a.length; n += 1) { var o = a[n]; void 0 === (c = r[this.cases[o]]) ? (r[this.cases[o]] = i.length, i.push([this.cases[o], [o]])) : i[c][1].push(o) } for (var s = function (e) { return "number" === t.inputType.kind ? Number(e) : e }, l = 0, u = i; l < u.length; l += 1) { var h = u[l], c = h[0], p = h[1]; e.push(1 === p.length ? s(p[0]) : p.map(s)), e.push(this.outputs[outputIndex$1].serialize()) } return e.push(this.otherwise.serialize()), e }; var fi = function (t, e, i) { this.type = t, this.branches = e, this.otherwise = i }; fi.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 0) return e.error("Expected an odd number of arguments."); var i; e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType); for (var r = [], n = 1; n < t.length - 1; n += 2) { var a = e.parse(t[n], n, Nt); if (!a) return null; var o = e.parse(t[n + 1], n + 1, i); if (!o) return null; r.push([a, o]), i = i || o.type } var s = e.parse(t[t.length - 1], t.length - 1, i); return s ? new fi(i, r, s) : null }, fi.prototype.evaluate = function (t) { for (var e = 0, i = this.branches; e < i.length; e += 1) { var r = i[e], n = r[1]; if (r[0].evaluate(t)) return n.evaluate(t) } return this.otherwise.evaluate(t) }, fi.prototype.eachChild = function (t) { for (var e = 0, i = this.branches; e < i.length; e += 1) { var r = i[e], n = r[1]; t(r[0]), t(n) } t(this.otherwise) }, fi.prototype.outputDefined = function () { return this.branches.every((function (t) { return t[1].outputDefined() })) && this.otherwise.outputDefined() }, fi.prototype.serialize = function () { var t = ["case"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var di = function (t, e, i, r) { this.type = t, this.input = e, this.beginIndex = i, this.endIndex = r }; function mi(t, e) { return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind } function yi(t, e, i, r) { return 0 === r.compare(e, i) } function gi(t, e, i) { var r = "==" !== t && "!=" !== t; return function () { function n(t, e, i) { this.type = Nt, this.lhs = t, this.rhs = e, this.collator = i, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind } return n.parse = function (t, e) { if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments."); var i = t[0], a = e.parse(t[1], 1, qt); if (!a) return null; if (!mi(i, a.type)) return e.concat(1).error('"' + i + "\" comparisons are not supported for type '" + Kt(a.type) + "'."); var o = e.parse(t[2], 2, qt); if (!o) return null; if (!mi(i, o.type)) return e.concat(2).error('"' + i + "\" comparisons are not supported for type '" + Kt(o.type) + "'."); if (a.type.kind !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot compare types '" + Kt(a.type) + "' and '" + Kt(o.type) + "'."); r && ("value" === a.type.kind && "value" !== o.type.kind ? a = new pe(o.type, [a]) : "value" !== a.type.kind && "value" === o.type.kind && (o = new pe(a.type, [o]))); var s = null; if (4 === t.length) { if ("string" !== a.type.kind && "string" !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot use collator to compare non-string types."); if (!(s = e.parse(t[3], 3, Gt))) return null } return new n(a, o, s) }, n.prototype.evaluate = function (n) { var a = this.lhs.evaluate(n), o = this.rhs.evaluate(n); if (r && this.hasUntypedArgument) { var s = se(a), l = se(o); if (s.kind !== l.kind || "string" !== s.kind && "number" !== s.kind) throw new he('Expected arguments for "' + t + '" to be (string, string) or (number, number), but found (' + s.kind + ", " + l.kind + ") instead.") } if (this.collator && !r && this.hasUntypedArgument) { var u = se(a), h = se(o); if ("string" !== u.kind || "string" !== h.kind) return e(n, a, o) } return this.collator ? i(n, a, o, this.collator.evaluate(n)) : e(n, a, o) }, n.prototype.eachChild = function (t) { t(this.lhs), t(this.rhs), this.collator && t(this.collator) }, n.prototype.outputDefined = function () { return !0 }, n.prototype.serialize = function () { var e = [t]; return this.eachChild((function (t) { e.push(t.serialize()) })), e }, n }() } di.parse = function (t, e) { if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead."); var i = e.parse(t[1], 1, qt), r = e.parse(t[2], 2, Ft); if (!i || !r) return null; if (!Jt(i.type, [Wt(qt), Ut, qt])) return e.error("Expected first argument to be of type array or string, but found " + Kt(i.type) + " instead"); if (4 === t.length) { var n = e.parse(t[3], 3, Ft); return n ? new di(i.type, i, r, n) : null } return new di(i.type, i, r) }, di.prototype.evaluate = function (t) { var e = this.input.evaluate(t), i = this.beginIndex.evaluate(t); if (!Yt(e, ["string", "array"])) throw new he("Expected first argument to be of type array or string, but found " + Kt(se(e)) + " instead."); if (this.endIndex) { var r = this.endIndex.evaluate(t); return e.slice(i, r) } return e.slice(i) }, di.prototype.eachChild = function (t) { t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex) }, di.prototype.outputDefined = function () { return !1 }, di.prototype.serialize = function () { if (null != this.endIndex && void 0 !== this.endIndex) { var t = this.endIndex.serialize(); return ["slice", this.input.serialize(), this.beginIndex.serialize(), t] } return ["slice", this.input.serialize(), this.beginIndex.serialize()] }; var _i = gi("==", (function (t, e, i) { return e === i }), yi), vi = gi("!=", (function (t, e, i) { return e !== i }), (function (t, e, i, r) { return !yi(0, e, i, r) })), xi = gi("<", (function (t, e, i) { return e < i }), (function (t, e, i, r) { return r.compare(e, i) < 0 })), bi = gi(">", (function (t, e, i) { return e > i }), (function (t, e, i, r) { return r.compare(e, i) > 0 })), wi = gi("<=", (function (t, e, i) { return e <= i }), (function (t, e, i, r) { return r.compare(e, i) <= 0 })), Mi = gi(">=", (function (t, e, i) { return e >= i }), (function (t, e, i, r) { return r.compare(e, i) >= 0 })), Si = function (t, e, i, r, n) { this.type = Ut, this.number = t, this.locale = e, this.currency = i, this.minFractionDigits = r, this.maxFractionDigits = n }; Si.parse = function (t, e) { if (3 !== t.length) return e.error("Expected two arguments."); var i = e.parse(t[1], 1, Ft); if (!i) return null; var r = t[2]; if ("object" != typeof r || Array.isArray(r)) return e.error("NumberFormat options argument must be an object."); var n = null; if (r.locale && !(n = e.parse(r.locale, 1, Ut))) return null; var a = null; if (r.currency && !(a = e.parse(r.currency, 1, Ut))) return null; var o = null; if (r["min-fraction-digits"] && !(o = e.parse(r["min-fraction-digits"], 1, Ft))) return null; var s = null; return r["max-fraction-digits"] && !(s = e.parse(r["max-fraction-digits"], 1, Ft)) ? null : new Si(i, n, a, o, s) }, Si.prototype.evaluate = function (t) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t)) }, Si.prototype.eachChild = function (t) { t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits) }, Si.prototype.outputDefined = function () { return !1 }, Si.prototype.serialize = function () { var t = {}; return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t] }; var Ei = function (t) { this.type = Ft, this.input = t }; Ei.parse = function (t, e) { if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead."); var i = e.parse(t[1], 1); return i ? "array" !== i.type.kind && "string" !== i.type.kind && "value" !== i.type.kind ? e.error("Expected argument of type string or array, but found " + Kt(i.type) + " instead.") : new Ei(i) : null }, Ei.prototype.evaluate = function (t) { var e = this.input.evaluate(t); if ("string" == typeof e) return e.length; if (Array.isArray(e)) return e.length; throw new he("Expected value to be of type string or array, but found " + Kt(se(e)) + " instead.") }, Ei.prototype.eachChild = function (t) { t(this.input) }, Ei.prototype.outputDefined = function () { return !1 }, Ei.prototype.serialize = function () { var t = ["length"]; return this.eachChild((function (e) { t.push(e.serialize()) })), t }; var Ii = { "==": _i, "!=": vi, ">": bi, "<": xi, ">=": Mi, "<=": wi, array: pe, at: ui, boolean: pe, case: fi, coalesce: si, collator: xe, format: fe, image: de, in: hi, "index-of": ci, interpolate: ai, "interpolate-hcl": ai, "interpolate-lab": ai, length: Ei, let: li, literal: ue, match: pi, number: pe, "number-format": Si, object: pe, slice: di, step: qe, string: pe, "to-boolean": ye, "to-color": ye, "to-number": ye, "to-string": ye, var: Ne, within: Be }; function Ti(t, e) { var i = e[0], r = e[1], n = e[2], a = e[3]; i = i.evaluate(t), r = r.evaluate(t), n = n.evaluate(t); var o = a ? a.evaluate(t) : 1, s = ae(i, r, n, o); if (s) throw new he(s); return new te(i / 255 * o, r / 255 * o, n / 255 * o, o) } function Ai(t, e) { return t in e } function Pi(t, e) { var i = e[t]; return void 0 === i ? null : i } function Ci(t) { return { type: t } } function zi(t) { return { result: "success", value: t } } function ki(t) { return { result: "error", value: t } } function Li(t) { return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"] } function Di(t) { return !!t.expression && t.expression.parameters.indexOf("zoom") > -1 } function Ri(t) { return !!t.expression && t.expression.interpolated } function Bi(t) { return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t } function Oi(t) { return "object" == typeof t && null !== t && !Array.isArray(t) } function Fi(t) { return t } function Ui(t, e, i) { return void 0 !== t ? t : void 0 !== e ? e : void 0 !== i ? i : void 0 } function Ni(t, e, i, r, n) { return Ui(typeof i === n ? r[i] : void 0, t.default, e.default) } function Vi(t, e, i) { if ("number" !== Bi(i)) return Ui(t.default, e.default); var r = t.stops.length; if (1 === r) return t.stops[0][1]; if (i <= t.stops[0][0]) return t.stops[0][1]; if (i >= t.stops[r - 1][0]) return t.stops[r - 1][1]; var n = je(t.stops.map((function (t) { return t[0] })), i); return t.stops[n][1] } function ji(t, e, i) { var r = void 0 !== t.base ? t.base : 1; if ("number" !== Bi(i)) return Ui(t.default, e.default); var n = t.stops.length; if (1 === n) return t.stops[0][1]; if (i <= t.stops[0][0]) return t.stops[0][1]; if (i >= t.stops[n - 1][0]) return t.stops[n - 1][1]; var a = je(t.stops.map((function (t) { return t[0] })), i), o = function (t, e, i, r) { var n = r - i, a = t - i; return 0 === n ? 0 : 1 === e ? a / n : (Math.pow(e, a) - 1) / (Math.pow(e, n) - 1) }(i, r, t.stops[a][0], t.stops[a + 1][0]), s = t.stops[a][1], l = t.stops[a + 1][1], u = Ze[e.type] || Fi; if (t.colorSpace && "rgb" !== t.colorSpace) { var h = ni[t.colorSpace]; u = function (t, e) { return h.reverse(h.interpolate(h.forward(t), h.forward(e), o)) } } return "function" == typeof s.evaluate ? { evaluate: function () { for (var t = [], e = arguments.length; e--;)t[e] = arguments[e]; var i = s.evaluate.apply(void 0, t), r = l.evaluate.apply(void 0, t); if (void 0 !== i && void 0 !== r) return u(i, r, o) } } : u(s, l, o) } function qi(t, e, i) { return "color" === e.type ? i = te.parse(i) : "formatted" === e.type ? i = re.fromString(i.toString()) : "resolvedImage" === e.type ? i = ne.fromString(i.toString()) : Bi(i) === e.type || "enum" === e.type && e.values[i] || (i = void 0), Ui(i, t.default, e.default) } ve.register(Ii, { error: [{ kind: "error" }, [Ut], function (t, e) { throw new he(e[0].evaluate(t)) }], typeof: [Ut, [qt], function (t, e) { return Kt(se(e[0].evaluate(t))) }], "to-rgba": [Wt(Ft, 4), [Vt], function (t, e) { return e[0].evaluate(t).toArray() }], rgb: [Vt, [Ft, Ft, Ft], Ti], rgba: [Vt, [Ft, Ft, Ft, Ft], Ti], has: { type: Nt, overloads: [[[Ut], function (t, e) { return Ai(e[0].evaluate(t), t.properties()) }], [[Ut, jt], function (t, e) { var i = e[1]; return Ai(e[0].evaluate(t), i.evaluate(t)) }]] }, get: { type: qt, overloads: [[[Ut], function (t, e) { return Pi(e[0].evaluate(t), t.properties()) }], [[Ut, jt], function (t, e) { var i = e[1]; return Pi(e[0].evaluate(t), i.evaluate(t)) }]] }, "feature-state": [qt, [Ut], function (t, e) { return Pi(e[0].evaluate(t), t.featureState || {}) }], properties: [jt, [], function (t) { return t.properties() }], "geometry-type": [Ut, [], function (t) { return t.geometryType() }], id: [qt, [], function (t) { return t.id() }], zoom: [Ft, [], function (t) { return t.globals.zoom }], "heatmap-density": [Ft, [], function (t) { return t.globals.heatmapDensity || 0 }], "line-progress": [Ft, [], function (t) { return t.globals.lineProgress || 0 }], accumulated: [qt, [], function (t) { return void 0 === t.globals.accumulated ? null : t.globals.accumulated }], "+": [Ft, Ci(Ft), function (t, e) { for (var i = 0, r = 0, n = e; r < n.length; r += 1)i += n[r].evaluate(t); return i }], "*": [Ft, Ci(Ft), function (t, e) { for (var i = 1, r = 0, n = e; r < n.length; r += 1)i *= n[r].evaluate(t); return i }], "-": { type: Ft, overloads: [[[Ft, Ft], function (t, e) { var i = e[1]; return e[0].evaluate(t) - i.evaluate(t) }], [[Ft], function (t, e) { return -e[0].evaluate(t) }]] }, "/": [Ft, [Ft, Ft], function (t, e) { var i = e[1]; return e[0].evaluate(t) / i.evaluate(t) }], "%": [Ft, [Ft, Ft], function (t, e) { var i = e[1]; return e[0].evaluate(t) % i.evaluate(t) }], ln2: [Ft, [], function () { return Math.LN2 }], pi: [Ft, [], function () { return Math.PI }], e: [Ft, [], function () { return Math.E }], "^": [Ft, [Ft, Ft], function (t, e) { var i = e[1]; return Math.pow(e[0].evaluate(t), i.evaluate(t)) }], sqrt: [Ft, [Ft], function (t, e) { return Math.sqrt(e[0].evaluate(t)) }], log10: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) / Math.LN10 }], ln: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) }], log2: [Ft, [Ft], function (t, e) { return Math.log(e[0].evaluate(t)) / Math.LN2 }], sin: [Ft, [Ft], function (t, e) { return Math.sin(e[0].evaluate(t)) }], cos: [Ft, [Ft], function (t, e) { return Math.cos(e[0].evaluate(t)) }], tan: [Ft, [Ft], function (t, e) { return Math.tan(e[0].evaluate(t)) }], asin: [Ft, [Ft], function (t, e) { return Math.asin(e[0].evaluate(t)) }], acos: [Ft, [Ft], function (t, e) { return Math.acos(e[0].evaluate(t)) }], atan: [Ft, [Ft], function (t, e) { return Math.atan(e[0].evaluate(t)) }], min: [Ft, Ci(Ft), function (t, e) { return Math.min.apply(Math, e.map((function (e) { return e.evaluate(t) }))) }], max: [Ft, Ci(Ft), function (t, e) { return Math.max.apply(Math, e.map((function (e) { return e.evaluate(t) }))) }], abs: [Ft, [Ft], function (t, e) { return Math.abs(e[0].evaluate(t)) }], round: [Ft, [Ft], function (t, e) { var i = e[0].evaluate(t); return i < 0 ? -Math.round(-i) : Math.round(i) }], floor: [Ft, [Ft], function (t, e) { return Math.floor(e[0].evaluate(t)) }], ceil: [Ft, [Ft], function (t, e) { return Math.ceil(e[0].evaluate(t)) }], "filter-==": [Nt, [Ut, qt], function (t, e) { var i = e[0], r = e[1]; return t.properties()[i.value] === r.value }], "filter-id-==": [Nt, [qt], function (t, e) { var i = e[0]; return t.id() === i.value }], "filter-type-==": [Nt, [Ut], function (t, e) { var i = e[0]; return t.geometryType() === i.value }], "filter-<": [Nt, [Ut, qt], function (t, e) { var i = e[0], r = e[1], n = t.properties()[i.value], a = r.value; return typeof n == typeof a && n < a }], "filter-id-<": [Nt, [qt], function (t, e) { var i = e[0], r = t.id(), n = i.value; return typeof r == typeof n && r < n }], "filter->": [Nt, [Ut, qt], function (t, e) { var i = e[0], r = e[1], n = t.properties()[i.value], a = r.value; return typeof n == typeof a && n > a }], "filter-id->": [Nt, [qt], function (t, e) { var i = e[0], r = t.id(), n = i.value; return typeof r == typeof n && r > n }], "filter-<=": [Nt, [Ut, qt], function (t, e) { var i = e[0], r = e[1], n = t.properties()[i.value], a = r.value; return typeof n == typeof a && n <= a }], "filter-id-<=": [Nt, [qt], function (t, e) { var i = e[0], r = t.id(), n = i.value; return typeof r == typeof n && r <= n }], "filter->=": [Nt, [Ut, qt], function (t, e) { var i = e[0], r = e[1], n = t.properties()[i.value], a = r.value; return typeof n == typeof a && n >= a }], "filter-id->=": [Nt, [qt], function (t, e) { var i = e[0], r = t.id(), n = i.value; return typeof r == typeof n && r >= n }], "filter-has": [Nt, [qt], function (t, e) { return e[0].value in t.properties() }], "filter-has-id": [Nt, [], function (t) { return null !== t.id() && void 0 !== t.id() }], "filter-type-in": [Nt, [Wt(Ut)], function (t, e) { return e[0].value.indexOf(t.geometryType()) >= 0 }], "filter-id-in": [Nt, [Wt(qt)], function (t, e) { return e[0].value.indexOf(t.id()) >= 0 }], "filter-in-small": [Nt, [Ut, Wt(qt)], function (t, e) { var i = e[0]; return e[1].value.indexOf(t.properties()[i.value]) >= 0 }], "filter-in-large": [Nt, [Ut, Wt(qt)], function (t, e) { var i = e[0], r = e[1]; return function (t, e, i, r) { for (; i <= r;) { var n = i + r >> 1; if (e[n] === t) return !0; e[n] > t ? r = n - 1 : i = n + 1 } return !1 }(t.properties()[i.value], r.value, 0, r.value.length - 1) }], all: { type: Nt, overloads: [[[Nt, Nt], function (t, e) { var i = e[1]; return e[0].evaluate(t) && i.evaluate(t) }], [Ci(Nt), function (t, e) { for (var i = 0, r = e; i < r.length; i += 1)if (!r[i].evaluate(t)) return !1; return !0 }]] }, any: { type: Nt, overloads: [[[Nt, Nt], function (t, e) { var i = e[1]; return e[0].evaluate(t) || i.evaluate(t) }], [Ci(Nt), function (t, e) { for (var i = 0, r = e; i < r.length; i += 1)if (r[i].evaluate(t)) return !0; return !1 }]] }, "!": [Nt, [Nt], function (t, e) { return !e[0].evaluate(t) }], "is-supported-script": [Nt, [Ut], function (t, e) { var i = t.globals && t.globals.isSupportedScript; return !i || i(e[0].evaluate(t)) }], upcase: [Ut, [Ut], function (t, e) { return e[0].evaluate(t).toUpperCase() }], downcase: [Ut, [Ut], function (t, e) { return e[0].evaluate(t).toLowerCase() }], concat: [Ut, Ci(qt), function (t, e) { return e.map((function (e) { return le(e.evaluate(t)) })).join("") }], "resolved-locale": [Ut, [Gt], function (t, e) { return e[0].evaluate(t).resolvedLocale() }] }); var Gi = function (t, e) { this.expression = t, this._warningHistory = {}, this._evaluator = new _e, this._defaultValue = e ? function (t) { return "color" === t.type && Oi(t.default) ? new te(0, 0, 0, 0) : "color" === t.type ? te.parse(t.default) || null : void 0 === t.default ? null : t.default }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null }; function Zi(t) { return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in Ii } function Xi(t, e) { var i = new Ve(Ii, [], e ? function (t) { var e = { color: Vt, string: Ut, number: Ft, enum: Ut, boolean: Nt, formatted: Zt, resolvedImage: Xt }; return "array" === t.type ? Wt(e[t.value] || qt, t.length) : e[t.type] }(e) : void 0), r = i.parse(t, void 0, void 0, void 0, e && "string" === e.type ? { typeAnnotation: "coerce" } : void 0); return r ? zi(new Gi(r, e)) : ki(i.errors) } Gi.prototype.evaluateWithoutErrorHandling = function (t, e, i, r, n, a) { return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = i, this._evaluator.canonical = r, this._evaluator.availableImages = n || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator) }, Gi.prototype.evaluate = function (t, e, i, r, n, a) { this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = i || null, this._evaluator.canonical = r, this._evaluator.availableImages = n || null, this._evaluator.formattedSection = a || null; try { var o = this.expression.evaluate(this._evaluator); if (null == o || "number" == typeof o && o != o) return this._defaultValue; if (this._enumValues && !(o in this._enumValues)) throw new he("Expected value to be one of " + Object.keys(this._enumValues).map((function (t) { return JSON.stringify(t) })).join(", ") + ", but found " + JSON.stringify(o) + " instead."); return o } catch (t) { return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue } }; var Wi = function (t, e) { this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Fe(e.expression) }; Wi.prototype.evaluateWithoutErrorHandling = function (t, e, i, r, n, a) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, a) }, Wi.prototype.evaluate = function (t, e, i, r, n, a) { return this._styleExpression.evaluate(t, e, i, r, n, a) }; var Ki = function (t, e, i, r) { this.kind = t, this.zoomStops = i, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Fe(e.expression), this.interpolationType = r }; function Hi(t, e) { if ("error" === (t = Xi(t, e)).result) return t; var i = t.value.expression, r = Oe(i); if (!r && !Li(e)) return ki([new Rt("", "data expressions not supported")]); var n = Ue(i, ["zoom"]); if (!n && !Di(e)) return ki([new Rt("", "zoom expressions not supported")]); var a = function t(e) { var i = null; if (e instanceof li) i = t(e.result); else if (e instanceof si) for (var r = 0, n = e.args; r < n.length && !(i = t(n[r])); r += 1); else (e instanceof qe || e instanceof ai) && e.input instanceof ve && "zoom" === e.input.name && (i = e); return i instanceof Rt || e.eachChild((function (e) { var r = t(e); r instanceof Rt ? i = r : !i && r ? i = new Rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : i && r && i !== r && (i = new Rt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) })), i }(i); return a || n ? a instanceof Rt ? ki([a]) : a instanceof ai && !Ri(e) ? ki([new Rt("", '"interpolate" expressions cannot be used with this property')]) : zi(a ? new Ki(r ? "camera" : "composite", t.value, a.labels, a instanceof ai ? a.interpolation : void 0) : new Wi(r ? "constant" : "source", t.value)) : ki([new Rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } Ki.prototype.evaluateWithoutErrorHandling = function (t, e, i, r, n, a) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, a) }, Ki.prototype.evaluate = function (t, e, i, r, n, a) { return this._styleExpression.evaluate(t, e, i, r, n, a) }, Ki.prototype.interpolationFactor = function (t, e, i) { return this.interpolationType ? ai.interpolationFactor(this.interpolationType, t, e, i) : 0 }; var $i = function (t, e) { this._parameters = t, this._specification = e, kt(this, function t(e, i) { var r, n, a, o = "color" === i.type, s = e.stops && "object" == typeof e.stops[0][0], l = s || !(s || void 0 !== e.property), u = e.type || (Ri(i) ? "exponential" : "interval"); if (o && ((e = kt({}, e)).stops && (e.stops = e.stops.map((function (t) { return [t[0], te.parse(t[1])] }))), e.default = te.parse(e.default ? e.default : i.default)), e.colorSpace && "rgb" !== e.colorSpace && !ni[e.colorSpace]) throw new Error("Unknown color space: " + e.colorSpace); if ("exponential" === u) r = ji; else if ("interval" === u) r = Vi; else if ("categorical" === u) { r = Ni, n = Object.create(null); for (var h = 0, c = e.stops; h < c.length; h += 1) { var p = c[h]; n[p[0]] = p[1] } a = typeof e.stops[0][0] } else { if ("identity" !== u) throw new Error('Unknown function type "' + u + '"'); r = qi } if (s) { for (var f = {}, d = [], m = 0; m < e.stops.length; m++) { var y = e.stops[m], g = y[0].zoom; void 0 === f[g] && (f[g] = { zoom: g, type: e.type, property: e.property, default: e.default, stops: [] }, d.push(g)), f[g].stops.push([y[0].value, y[1]]) } for (var _ = [], v = 0, x = d; v < x.length; v += 1) { var b = x[v]; _.push([f[b].zoom, t(f[b], i)]) } var w = { name: "linear" }; return { kind: "composite", interpolationType: w, interpolationFactor: ai.interpolationFactor.bind(void 0, w), zoomStops: _.map((function (t) { return t[0] })), evaluate: function (t, r) { var n = t.zoom; return ji({ stops: _, base: e.base }, i, n).evaluate(n, r) } } } if (l) { var M = "exponential" === u ? { name: "exponential", base: void 0 !== e.base ? e.base : 1 } : null; return { kind: "camera", interpolationType: M, interpolationFactor: ai.interpolationFactor.bind(void 0, M), zoomStops: e.stops.map((function (t) { return t[0] })), evaluate: function (t) { return r(e, i, t.zoom, n, a) } } } return { kind: "source", evaluate: function (t, o) { var s = o && o.properties ? o.properties[e.property] : void 0; return void 0 === s ? Ui(e.default, i.default) : r(e, i, s, n, a) } } }(this._parameters, this._specification)) }; function Ji(t) { var e = t.key, i = t.value, r = t.valueSpec || {}, n = t.objectElementValidators || {}, a = t.style, o = t.styleSpec, s = [], l = Bi(i); if ("object" !== l) return [new Ct(e, i, "object expected, " + l + " found")]; for (var u in i) { var h = u.split(".")[0], c = r[h] || r["*"], p = void 0; if (n[h]) p = n[h]; else if (r[h]) p = wr; else if (n["*"]) p = n["*"]; else { if (!r["*"]) { s.push(new Ct(e, i[u], 'unknown property "' + u + '"')); continue } p = wr } s = s.concat(p({ key: (e ? e + "." : e) + u, value: i[u], valueSpec: c, style: a, styleSpec: o, object: i, objectKey: u }, i)) } for (var f in r) n[f] || r[f].required && void 0 === r[f].default && void 0 === i[f] && s.push(new Ct(e, i, 'missing required property "' + f + '"')); return s } function Yi(t) { var e = t.value, i = t.valueSpec, r = t.style, n = t.styleSpec, a = t.key, o = t.arrayElementValidator || wr; if ("array" !== Bi(e)) return [new Ct(a, e, "array expected, " + Bi(e) + " found")]; if (i.length && e.length !== i.length) return [new Ct(a, e, "array length " + i.length + " expected, length " + e.length + " found")]; if (i["min-length"] && e.length < i["min-length"]) return [new Ct(a, e, "array length at least " + i["min-length"] + " expected, length " + e.length + " found")]; var s = { type: i.value, values: i.values }; n.$version < 7 && (s.function = i.function), "object" === Bi(i.value) && (s = i.value); for (var l = [], u = 0; u < e.length; u++)l = l.concat(o({ array: e, arrayIndex: u, value: e[u], valueSpec: s, style: r, styleSpec: n, key: a + "[" + u + "]" })); return l } function Qi(t) { var e = t.key, i = t.value, r = t.valueSpec, n = Bi(i); return "number" === n && i != i && (n = "NaN"), "number" !== n ? [new Ct(e, i, "number expected, " + n + " found")] : "minimum" in r && i < r.minimum ? [new Ct(e, i, i + " is less than the minimum value " + r.minimum)] : "maximum" in r && i > r.maximum ? [new Ct(e, i, i + " is greater than the maximum value " + r.maximum)] : [] } function tr(t) { var e, i, r, n = t.valueSpec, a = Lt(t.value.type), o = {}, s = "categorical" !== a && void 0 === t.value.property, l = !s, u = "array" === Bi(t.value.stops) && "array" === Bi(t.value.stops[0]) && "object" === Bi(t.value.stops[0][0]), h = Ji({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function (t) { if ("identity" === a) return [new Ct(t.key, t.value, 'identity function may not have a "stops" property')]; var e = [], i = t.value; return e = e.concat(Yi({ key: t.key, value: i, valueSpec: t.valueSpec, style: t.style, styleSpec: t.styleSpec, arrayElementValidator: c })), "array" === Bi(i) && 0 === i.length && e.push(new Ct(t.key, i, "array must have at least one stop")), e }, default: function (t) { return wr({ key: t.key, value: t.value, valueSpec: n, style: t.style, styleSpec: t.styleSpec }) } } }); return "identity" === a && s && h.push(new Ct(t.key, t.value, 'missing required property "property"')), "identity" === a || t.value.stops || h.push(new Ct(t.key, t.value, 'missing required property "stops"')), "exponential" === a && t.valueSpec.expression && !Ri(t.valueSpec) && h.push(new Ct(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !Li(t.valueSpec) ? h.push(new Ct(t.key, t.value, "property functions not supported")) : s && !Di(t.valueSpec) && h.push(new Ct(t.key, t.value, "zoom functions not supported"))), "categorical" !== a && !u || void 0 !== t.value.property || h.push(new Ct(t.key, t.value, '"property" property is required')), h; function c(t) { var e = [], a = t.value, s = t.key; if ("array" !== Bi(a)) return [new Ct(s, a, "array expected, " + Bi(a) + " found")]; if (2 !== a.length) return [new Ct(s, a, "array length 2 expected, length " + a.length + " found")]; if (u) { if ("object" !== Bi(a[0])) return [new Ct(s, a, "object expected, " + Bi(a[0]) + " found")]; if (void 0 === a[0].zoom) return [new Ct(s, a, "object stop key must have zoom")]; if (void 0 === a[0].value) return [new Ct(s, a, "object stop key must have value")]; if (r && r > Lt(a[0].zoom)) return [new Ct(s, a[0].zoom, "stop zoom values must appear in ascending order")]; Lt(a[0].zoom) !== r && (r = Lt(a[0].zoom), i = void 0, o = {}), e = e.concat(Ji({ key: s + "[0]", value: a[0], valueSpec: { zoom: {} }, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { zoom: Qi, value: p } })) } else e = e.concat(p({ key: s + "[0]", value: a[0], valueSpec: {}, style: t.style, styleSpec: t.styleSpec }, a)); return Zi(Dt(a[1])) ? e.concat([new Ct(s + "[1]", a[1], "expressions are not allowed in function stops.")]) : e.concat(wr({ key: s + "[1]", value: a[1], valueSpec: n, style: t.style, styleSpec: t.styleSpec })) } function p(t, r) { var s = Bi(t.value), l = Lt(t.value), u = null !== t.value ? t.value : r; if (e) { if (s !== e) return [new Ct(t.key, u, s + " stop domain type must match previous stop domain type " + e)] } else e = s; if ("number" !== s && "string" !== s && "boolean" !== s) return [new Ct(t.key, u, "stop domain value must be a number, string, or boolean")]; if ("number" !== s && "categorical" !== a) { var h = "number expected, " + s + " found"; return Li(n) && void 0 === a && (h += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ct(t.key, u, h)] } return "categorical" !== a || "number" !== s || isFinite(l) && Math.floor(l) === l ? "categorical" !== a && "number" === s && void 0 !== i && l < i ? [new Ct(t.key, u, "stop domain values must appear in ascending order")] : (i = l, "categorical" === a && l in o ? [new Ct(t.key, u, "stop domain values must be unique")] : (o[l] = !0, [])) : [new Ct(t.key, u, "integer expected, found " + l)] } } function er(t) { var e = ("property" === t.expressionContext ? Hi : Xi)(Dt(t.value), t.valueSpec); if ("error" === e.result) return e.value.map((function (e) { return new Ct("" + t.key + e.key, t.value, e.message) })); var i = e.value.expression || e.value._styleExpression.expression; if ("property" === t.expressionContext && "text-font" === t.propertyKey && !i.outputDefined()) return [new Ct(t.key, t.value, 'Invalid data expression for "' + t.propertyKey + '". Output values must be contained as literals within the expression.')]; if ("property" === t.expressionContext && "layout" === t.propertyType && !Fe(i)) return [new Ct(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')]; if ("filter" === t.expressionContext && !Fe(i)) return [new Ct(t.key, t.value, '"feature-state" data expressions are not supported with filters.')]; if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) { if (!Ue(i, ["zoom", "feature-state"])) return [new Ct(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if ("cluster-initial" === t.expressionContext && !Oe(i)) return [new Ct(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function ir(t) { var e = t.key, i = t.value, r = t.valueSpec, n = []; return Array.isArray(r.values) ? -1 === r.values.indexOf(Lt(i)) && n.push(new Ct(e, i, "expected one of [" + r.values.join(", ") + "], " + JSON.stringify(i) + " found")) : -1 === Object.keys(r.values).indexOf(Lt(i)) && n.push(new Ct(e, i, "expected one of [" + Object.keys(r.values).join(", ") + "], " + JSON.stringify(i) + " found")), n } function rr(t) { if (!0 === t || !1 === t) return !0; if (!Array.isArray(t) || 0 === t.length) return !1; switch (t[0]) { case "has": return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1]; case "in": return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]); case "any": case "all": for (var e = 0, i = t.slice(1); e < i.length; e += 1) { var r = i[e]; if (!rr(r) && "boolean" != typeof r) return !1 } return !0; default: return !0 } } $i.deserialize = function (t) { return new $i(t._parameters, t._specification) }, $i.serialize = function (t) { return { _parameters: t._parameters, _specification: t._specification } }; var nr = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function ar(t) { if (null == t) return { filter: function () { return !0 }, needGeometry: !1 }; rr(t) || (t = sr(t)); var e = Xi(t, nr); if ("error" === e.result) throw new Error(e.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); return { filter: function (t, i, r) { return e.value.evaluate(t, i, {}, r) }, needGeometry: function t(e) { if (!Array.isArray(e)) return !1; if ("within" === e[0]) return !0; for (var i = 1; i < e.length; i++)if (t(e[i])) return !0; return !1 }(t) } } function or(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function sr(t) { if (!t) return !0; var e, i = t[0]; return t.length <= 1 ? "any" !== i : "==" === i ? lr(t[1], t[2], "==") : "!=" === i ? cr(lr(t[1], t[2], "==")) : "<" === i || ">" === i || "<=" === i || ">=" === i ? lr(t[1], t[2], i) : "any" === i ? (e = t.slice(1), ["any"].concat(e.map(sr))) : "all" === i ? ["all"].concat(t.slice(1).map(sr)) : "none" === i ? ["all"].concat(t.slice(1).map(sr).map(cr)) : "in" === i ? ur(t[1], t.slice(2)) : "!in" === i ? cr(ur(t[1], t.slice(2))) : "has" === i ? hr(t[1]) : "!has" === i ? cr(hr(t[1])) : "within" !== i || t } function lr(t, e, i) { switch (t) { case "$type": return ["filter-type-" + i, e]; case "$id": return ["filter-id-" + i, e]; default: return ["filter-" + i, t, e] } } function ur(t, e) { if (0 === e.length) return !1; switch (t) { case "$type": return ["filter-type-in", ["literal", e]]; case "$id": return ["filter-id-in", ["literal", e]]; default: return e.length > 200 && !e.some((function (t) { return typeof t != typeof e[0] })) ? ["filter-in-large", t, ["literal", e.sort(or)]] : ["filter-in-small", t, ["literal", e]] } } function hr(t) { switch (t) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", t] } } function cr(t) { return ["!", t] } function pr(t) { return rr(Dt(t.value)) ? er(kt({}, t, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t(e) { var i = e.value, r = e.key; if ("array" !== Bi(i)) return [new Ct(r, i, "array expected, " + Bi(i) + " found")]; var n, a = e.styleSpec, o = []; if (i.length < 1) return [new Ct(r, i, "filter array must have at least 1 element")]; switch (o = o.concat(ir({ key: r + "[0]", value: i[0], valueSpec: a.filter_operator, style: e.style, styleSpec: e.styleSpec })), Lt(i[0])) { case "<": case "<=": case ">": case ">=": i.length >= 2 && "$type" === Lt(i[1]) && o.push(new Ct(r, i, '"$type" cannot be use with operator "' + i[0] + '"')); case "==": case "!=": 3 !== i.length && o.push(new Ct(r, i, 'filter array for operator "' + i[0] + '" must have 3 elements')); case "in": case "!in": i.length >= 2 && "string" !== (n = Bi(i[1])) && o.push(new Ct(r + "[1]", i[1], "string expected, " + n + " found")); for (var s = 2; s < i.length; s++)n = Bi(i[s]), "$type" === Lt(i[1]) ? o = o.concat(ir({ key: r + "[" + s + "]", value: i[s], valueSpec: a.geometry_type, style: e.style, styleSpec: e.styleSpec })) : "string" !== n && "number" !== n && "boolean" !== n && o.push(new Ct(r + "[" + s + "]", i[s], "string, number, or boolean expected, " + n + " found")); break; case "any": case "all": case "none": for (var l = 1; l < i.length; l++)o = o.concat(t({ key: r + "[" + l + "]", value: i[l], style: e.style, styleSpec: e.styleSpec })); break; case "has": case "!has": n = Bi(i[1]), 2 !== i.length ? o.push(new Ct(r, i, 'filter array for "' + i[0] + '" operator must have 2 elements')) : "string" !== n && o.push(new Ct(r + "[1]", i[1], "string expected, " + n + " found")); break; case "within": n = Bi(i[1]), 2 !== i.length ? o.push(new Ct(r, i, 'filter array for "' + i[0] + '" operator must have 2 elements')) : "object" !== n && o.push(new Ct(r + "[1]", i[1], "object expected, " + n + " found")) }return o }(t) } function fr(t, e) { var i = t.key, r = t.style, n = t.styleSpec, a = t.value, o = t.objectKey, s = n[e + "_" + t.layerType]; if (!s) return []; var l = o.match(/^(.*)-transition$/); if ("paint" === e && l && s[l[1]] && s[l[1]].transition) return wr({ key: i, value: a, valueSpec: n.transition, style: r, styleSpec: n }); var u, h = t.valueSpec || s[o]; if (!h) return [new Ct(i, a, 'unknown property "' + o + '"')]; if ("string" === Bi(a) && Li(h) && !h.tokens && (u = /^{([^}]+)}$/.exec(a))) return [new Ct(i, a, '"' + o + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(u[1]) + " }`.")]; var c = []; return "symbol" === t.layerType && ("text-field" === o && r && !r.glyphs && c.push(new Ct(i, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o && Oi(Dt(a)) && "identity" === Lt(a.type) && c.push(new Ct(i, a, '"text-font" does not support identity functions'))), c.concat(wr({ key: t.key, value: a, valueSpec: h, style: r, styleSpec: n, expressionContext: "property", propertyType: e, propertyKey: o })) } function dr(t) { return fr(t, "paint") } function mr(t) { return fr(t, "layout") } function yr(t) { var e = [], i = t.value, r = t.key, n = t.style, a = t.styleSpec; i.type || i.ref || e.push(new Ct(r, i, 'either "type" or "ref" is required')); var o, s = Lt(i.type), l = Lt(i.ref); if (i.id) for (var u = Lt(i.id), h = 0; h < t.arrayIndex; h++) { var c = n.layers[h]; Lt(c.id) === u && e.push(new Ct(r, i.id, 'duplicate layer id "' + i.id + '", previously used at line ' + c.id.__line__)) } if ("ref" in i) ["type", "source", "source-layer", "filter", "layout"].forEach((function (t) { t in i && e.push(new Ct(r, i[t], '"' + t + '" is prohibited for ref layers')) })), n.layers.forEach((function (t) { Lt(t.id) === l && (o = t) })), o ? o.ref ? e.push(new Ct(r, i.ref, "ref cannot reference another ref layer")) : s = Lt(o.type) : e.push(new Ct(r, i.ref, 'ref layer "' + l + '" not found')); else if ("background" !== s) if (i.source) { var p = n.sources && n.sources[i.source], f = p && Lt(p.type); p ? "vector" === f && "raster" === s ? e.push(new Ct(r, i.source, 'layer "' + i.id + '" requires a raster source')) : "raster" === f && "raster" !== s ? e.push(new Ct(r, i.source, 'layer "' + i.id + '" requires a vector source')) : "vector" !== f || i["source-layer"] ? "raster-dem" === f && "hillshade" !== s ? e.push(new Ct(r, i.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !i.paint || !i.paint["line-gradient"] || "geojson" === f && p.lineMetrics || e.push(new Ct(r, i, 'layer "' + i.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e.push(new Ct(r, i, 'layer "' + i.id + '" must specify a "source-layer"')) : e.push(new Ct(r, i.source, 'source "' + i.source + '" not found')) } else e.push(new Ct(r, i, 'missing required property "source"')); return e = e.concat(Ji({ key: r, value: i, valueSpec: a.layer, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function () { return [] }, type: function () { return wr({ key: r + ".type", value: i.type, valueSpec: a.layer.type, style: t.style, styleSpec: t.styleSpec, object: i, objectKey: "type" }) }, filter: pr, layout: function (t) { return Ji({ layer: i, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return mr(kt({ layerType: s }, t)) } } }) }, paint: function (t) { return Ji({ layer: i, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return dr(kt({ layerType: s }, t)) } } }) } } })) } function gr(t) { var e = t.value, i = t.key, r = Bi(e); return "string" !== r ? [new Ct(i, e, "string expected, " + r + " found")] : [] } var _r = { promoteId: function (t) { var e = t.key, i = t.value; if ("string" === Bi(i)) return gr({ key: e, value: i }); var r = []; for (var n in i) r.push.apply(r, gr({ key: e + "." + n, value: i[n] })); return r } }; function vr(t) { var e = t.value, i = t.key, r = t.styleSpec, n = t.style; if (!e.type) return [new Ct(i, e, '"type" is required')]; var a, o = Lt(e.type); switch (o) { case "vector": case "raster": case "raster-dem": return Ji({ key: i, value: e, valueSpec: r["source_" + o.replace("-", "_")], style: t.style, styleSpec: r, objectElementValidators: _r }); case "geojson": if (a = Ji({ key: i, value: e, valueSpec: r.source_geojson, style: n, styleSpec: r, objectElementValidators: _r }), e.cluster) for (var s in e.clusterProperties) { var l = e.clusterProperties[s], u = l[0], h = "string" == typeof u ? [u, ["accumulated"], ["get", s]] : u; a.push.apply(a, er({ key: i + "." + s + ".map", value: l[1], expressionContext: "cluster-map" })), a.push.apply(a, er({ key: i + "." + s + ".reduce", value: h, expressionContext: "cluster-reduce" })) } return a; case "video": return Ji({ key: i, value: e, valueSpec: r.source_video, style: n, styleSpec: r }); case "image": return Ji({ key: i, value: e, valueSpec: r.source_image, style: n, styleSpec: r }); case "canvas": return [new Ct(i, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return ir({ key: i + ".type", value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: n, styleSpec: r }) } } function xr(t) { var e = t.value, i = t.styleSpec, r = i.light, n = t.style, a = [], o = Bi(e); if (void 0 === e) return a; if ("object" !== o) return a.concat([new Ct("light", e, "object expected, " + o + " found")]); for (var s in e) { var l = s.match(/^(.*)-transition$/); a = a.concat(l && r[l[1]] && r[l[1]].transition ? wr({ key: s, value: e[s], valueSpec: i.transition, style: n, styleSpec: i }) : r[s] ? wr({ key: s, value: e[s], valueSpec: r[s], style: n, styleSpec: i }) : [new Ct(s, e[s], 'unknown property "' + s + '"')]) } return a } var br = { "*": function () { return [] }, array: Yi, boolean: function (t) { var e = t.value, i = t.key, r = Bi(e); return "boolean" !== r ? [new Ct(i, e, "boolean expected, " + r + " found")] : [] }, number: Qi, color: function (t) { var e = t.key, i = t.value, r = Bi(i); return "string" !== r ? [new Ct(e, i, "color expected, " + r + " found")] : null === Qt(i) ? [new Ct(e, i, 'color expected, "' + i + '" found')] : [] }, constants: zt, enum: ir, filter: pr, function: tr, layer: yr, object: Ji, source: vr, light: xr, string: gr, formatted: function (t) { return 0 === gr(t).length ? [] : er(t) }, resolvedImage: function (t) { return 0 === gr(t).length ? [] : er(t) } }; function wr(t) { var e = t.value, i = t.valueSpec, r = t.styleSpec; return i.expression && Oi(Lt(e)) ? tr(t) : i.expression && Zi(Dt(e)) ? er(t) : i.type && br[i.type] ? br[i.type](t) : Ji(kt({}, t, { valueSpec: i.type ? r[i.type] : i })) } function Mr(t) { var e = t.value, i = t.key, r = gr(t); return r.length || (-1 === e.indexOf("{fontstack}") && r.push(new Ct(i, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && r.push(new Ct(i, e, '"glyphs" url must include a "{range}" token'))), r } function Sr(t, e) { void 0 === e && (e = Pt); var i = []; return i = i.concat(wr({ key: "", value: t, valueSpec: e.$root, styleSpec: e, style: t, objectElementValidators: { glyphs: Mr, "*": function () { return [] } } })), t.constants && (i = i.concat(zt({ key: "constants", value: t.constants, style: t, styleSpec: e }))), Er(i) } function Er(t) { return [].concat(t).sort((function (t, e) { return t.line - e.line })) } function Ir(t) { return function () { for (var e = [], i = arguments.length; i--;)e[i] = arguments[i]; return Er(t.apply(this, e)) } } Sr.source = Ir(vr), Sr.light = Ir(xr), Sr.layer = Ir(yr), Sr.filter = Ir(pr), Sr.paintProperty = Ir(dr), Sr.layoutProperty = Ir(mr); var Tr = Sr, Ar = Tr.light, Pr = Tr.paintProperty, Cr = Tr.layoutProperty; function zr(t, e) { var i = !1; if (e && e.length) for (var r = 0, n = e; r < n.length; r += 1)t.fire(new Tt(new Error(n[r].message))), i = !0; return i } var kr = Lr; function Lr(t, e, i) { var r = this.cells = []; if (t instanceof ArrayBuffer) { this.arrayBuffer = t; var n = new Int32Array(this.arrayBuffer); t = n[0], this.d = (e = n[1]) + 2 * (i = n[2]); for (var a = 0; a < this.d * this.d; a++) { var o = n[3 + a], s = n[3 + a + 1]; r.push(o === s ? null : n.subarray(o, s)) } var l = n[3 + r.length + 1]; this.keys = n.subarray(n[3 + r.length], l), this.bboxes = n.subarray(l), this.insert = this._insertReadonly } else { this.d = e + 2 * i; for (var u = 0; u < this.d * this.d; u++)r.push([]); this.keys = [], this.bboxes = [] } this.n = e, this.extent = t, this.padding = i, this.scale = e / t, this.uid = 0; var h = i / e * t; this.min = -h, this.max = t + h } Lr.prototype.insert = function (t, e, i, r, n) { this._forEachCell(e, i, r, n, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(r), this.bboxes.push(n) }, Lr.prototype._insertReadonly = function () { throw "Cannot insert into a GridIndex created from an ArrayBuffer." }, Lr.prototype._insertCell = function (t, e, i, r, n, a) { this.cells[n].push(a) }, Lr.prototype.query = function (t, e, i, r, n) { var a = this.min, o = this.max; if (t <= a && e <= a && o <= i && o <= r && !n) return Array.prototype.slice.call(this.keys); var s = []; return this._forEachCell(t, e, i, r, this._queryCell, s, {}, n), s }, Lr.prototype._queryCell = function (t, e, i, r, n, a, o, s) { var l = this.cells[n]; if (null !== l) for (var u = this.keys, h = this.bboxes, c = 0; c < l.length; c++) { var p = l[c]; if (void 0 === o[p]) { var f = 4 * p; (s ? s(h[f + 0], h[f + 1], h[f + 2], h[f + 3]) : t <= h[f + 2] && e <= h[f + 3] && i >= h[f + 0] && r >= h[f + 1]) ? (o[p] = !0, a.push(u[p])) : o[p] = !1 } } }, Lr.prototype._forEachCell = function (t, e, i, r, n, a, o, s) { for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), h = this._convertToCellCoord(i), c = this._convertToCellCoord(r), p = l; p <= h; p++)for (var f = u; f <= c; f++) { var d = this.d * f + p; if ((!s || s(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && n.call(this, t, e, i, r, d, a, o, s)) return } }, Lr.prototype._convertFromCellCoord = function (t) { return (t - this.padding) / this.scale }, Lr.prototype._convertToCellCoord = function (t) { return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)) }, Lr.prototype.toArrayBuffer = function () { if (this.arrayBuffer) return this.arrayBuffer; for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, i = 0, r = 0; r < this.cells.length; r++)i += this.cells[r].length; var n = new Int32Array(e + i + this.keys.length + this.bboxes.length); n[0] = this.extent, n[1] = this.n, n[2] = this.padding; for (var a = e, o = 0; o < t.length; o++) { var s = t[o]; n[3 + o] = a, n.set(s, a), a += s.length } return n[3 + t.length] = a, n.set(this.keys, a), n[3 + t.length + 1] = a += this.keys.length, n.set(this.bboxes, a), a += this.bboxes.length, n.buffer }; var Dr = o.ImageData, Rr = o.ImageBitmap, Br = {}; function Or(t, e, i) { void 0 === i && (i = {}), Object.defineProperty(e, "_classRegistryKey", { value: t, writeable: !1 }), Br[t] = { klass: e, omit: i.omit || [], shallow: i.shallow || [] } } for (var Fr in Or("Object", Object), kr.serialize = function (t, e) { var i = t.toArrayBuffer(); return e && e.push(i), { buffer: i } }, kr.deserialize = function (t) { return new kr(t.buffer) }, Or("Grid", kr), Or("Color", te), Or("Error", Error), Or("ResolvedImage", ne), Or("StylePropertyFunction", $i), Or("StyleExpression", Gi, { omit: ["_evaluator"] }), Or("ZoomDependentExpression", Ki), Or("ZoomConstantExpression", Wi), Or("CompoundExpression", ve, { omit: ["_evaluate"] }), Ii) Ii[Fr]._classRegistryKey || Or("Expression_" + Fr, Ii[Fr]); function Ur(t) { return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name) } function Nr(t) { return Rr && t instanceof Rr } function Vr(t, e) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t; if (Ur(t) || Nr(t)) return e && e.push(t), t; if (ArrayBuffer.isView(t)) { var i = t; return e && e.push(i.buffer), i } if (t instanceof Dr) return e && e.push(t.data.buffer), t; if (Array.isArray(t)) { for (var r = [], n = 0, a = t; n < a.length; n += 1)r.push(Vr(a[n], e)); return r } if ("object" == typeof t) { var o = t.constructor, s = o._classRegistryKey; if (!s) throw new Error("can't serialize object of unregistered class"); var l = o.serialize ? o.serialize(t, e) : {}; if (!o.serialize) { for (var u in t) if (t.hasOwnProperty(u) && !(Br[s].omit.indexOf(u) >= 0)) { var h = t[u]; l[u] = Br[s].shallow.indexOf(u) >= 0 ? h : Vr(h, e) } t instanceof Error && (l.message = t.message) } if (l.$name) throw new Error("$name property is reserved for worker serialization logic."); return "Object" !== s && (l.$name = s), l } throw new Error("can't serialize object of type " + typeof t) } function jr(t) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Ur(t) || Nr(t) || ArrayBuffer.isView(t) || t instanceof Dr) return t; if (Array.isArray(t)) return t.map(jr); if ("object" == typeof t) { var e = t.$name || "Object", i = Br[e].klass; if (!i) throw new Error("can't deserialize unregistered class " + e); if (i.deserialize) return i.deserialize(t); for (var r = Object.create(i.prototype), n = 0, a = Object.keys(t); n < a.length; n += 1) { var o = a[n]; if ("$name" !== o) { var s = t[o]; r[o] = Br[e].shallow.indexOf(o) >= 0 ? s : jr(s) } } return r } throw new Error("can't deserialize object of type " + typeof t) } var qr = function () { this.first = !0 }; qr.prototype.update = function (t, e) { var i = Math.floor(t); return this.first ? (this.first = !1, this.lastIntegerZoom = i, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = i, !0) : (this.lastFloorZoom > i ? (this.lastIntegerZoom = i + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < i && (this.lastIntegerZoom = i, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = i, !0)) }; var Gr = { "Latin-1 Supplement": function (t) { return t >= 128 && t <= 255 }, Arabic: function (t) { return t >= 1536 && t <= 1791 }, "Arabic Supplement": function (t) { return t >= 1872 && t <= 1919 }, "Arabic Extended-A": function (t) { return t >= 2208 && t <= 2303 }, "Hangul Jamo": function (t) { return t >= 4352 && t <= 4607 }, "Unified Canadian Aboriginal Syllabics": function (t) { return t >= 5120 && t <= 5759 }, Khmer: function (t) { return t >= 6016 && t <= 6143 }, "Unified Canadian Aboriginal Syllabics Extended": function (t) { return t >= 6320 && t <= 6399 }, "General Punctuation": function (t) { return t >= 8192 && t <= 8303 }, "Letterlike Symbols": function (t) { return t >= 8448 && t <= 8527 }, "Number Forms": function (t) { return t >= 8528 && t <= 8591 }, "Miscellaneous Technical": function (t) { return t >= 8960 && t <= 9215 }, "Control Pictures": function (t) { return t >= 9216 && t <= 9279 }, "Optical Character Recognition": function (t) { return t >= 9280 && t <= 9311 }, "Enclosed Alphanumerics": function (t) { return t >= 9312 && t <= 9471 }, "Geometric Shapes": function (t) { return t >= 9632 && t <= 9727 }, "Miscellaneous Symbols": function (t) { return t >= 9728 && t <= 9983 }, "Miscellaneous Symbols and Arrows": function (t) { return t >= 11008 && t <= 11263 }, "CJK Radicals Supplement": function (t) { return t >= 11904 && t <= 12031 }, "Kangxi Radicals": function (t) { return t >= 12032 && t <= 12255 }, "Ideographic Description Characters": function (t) { return t >= 12272 && t <= 12287 }, "CJK Symbols and Punctuation": function (t) { return t >= 12288 && t <= 12351 }, Hiragana: function (t) { return t >= 12352 && t <= 12447 }, Katakana: function (t) { return t >= 12448 && t <= 12543 }, Bopomofo: function (t) { return t >= 12544 && t <= 12591 }, "Hangul Compatibility Jamo": function (t) { return t >= 12592 && t <= 12687 }, Kanbun: function (t) { return t >= 12688 && t <= 12703 }, "Bopomofo Extended": function (t) { return t >= 12704 && t <= 12735 }, "CJK Strokes": function (t) { return t >= 12736 && t <= 12783 }, "Katakana Phonetic Extensions": function (t) { return t >= 12784 && t <= 12799 }, "Enclosed CJK Letters and Months": function (t) { return t >= 12800 && t <= 13055 }, "CJK Compatibility": function (t) { return t >= 13056 && t <= 13311 }, "CJK Unified Ideographs Extension A": function (t) { return t >= 13312 && t <= 19903 }, "Yijing Hexagram Symbols": function (t) { return t >= 19904 && t <= 19967 }, "CJK Unified Ideographs": function (t) { return t >= 19968 && t <= 40959 }, "Yi Syllables": function (t) { return t >= 40960 && t <= 42127 }, "Yi Radicals": function (t) { return t >= 42128 && t <= 42191 }, "Hangul Jamo Extended-A": function (t) { return t >= 43360 && t <= 43391 }, "Hangul Syllables": function (t) { return t >= 44032 && t <= 55215 }, "Hangul Jamo Extended-B": function (t) { return t >= 55216 && t <= 55295 }, "Private Use Area": function (t) { return t >= 57344 && t <= 63743 }, "CJK Compatibility Ideographs": function (t) { return t >= 63744 && t <= 64255 }, "Arabic Presentation Forms-A": function (t) { return t >= 64336 && t <= 65023 }, "Vertical Forms": function (t) { return t >= 65040 && t <= 65055 }, "CJK Compatibility Forms": function (t) { return t >= 65072 && t <= 65103 }, "Small Form Variants": function (t) { return t >= 65104 && t <= 65135 }, "Arabic Presentation Forms-B": function (t) { return t >= 65136 && t <= 65279 }, "Halfwidth and Fullwidth Forms": function (t) { return t >= 65280 && t <= 65519 } }; function Zr(t) { for (var e = 0, i = t; e < i.length; e += 1)if (Xr(i[e].charCodeAt(0))) return !0; return !1 } function Xr(t) { return !(746 !== t && 747 !== t && (t < 4352 || !(Gr["Bopomofo Extended"](t) || Gr.Bopomofo(t) || Gr["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Gr["CJK Compatibility Ideographs"](t) || Gr["CJK Compatibility"](t) || Gr["CJK Radicals Supplement"](t) || Gr["CJK Strokes"](t) || !(!Gr["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Gr["CJK Unified Ideographs Extension A"](t) || Gr["CJK Unified Ideographs"](t) || Gr["Enclosed CJK Letters and Months"](t) || Gr["Hangul Compatibility Jamo"](t) || Gr["Hangul Jamo Extended-A"](t) || Gr["Hangul Jamo Extended-B"](t) || Gr["Hangul Jamo"](t) || Gr["Hangul Syllables"](t) || Gr.Hiragana(t) || Gr["Ideographic Description Characters"](t) || Gr.Kanbun(t) || Gr["Kangxi Radicals"](t) || Gr["Katakana Phonetic Extensions"](t) || Gr.Katakana(t) && 12540 !== t || !(!Gr["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Gr["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Gr["Unified Canadian Aboriginal Syllabics"](t) || Gr["Unified Canadian Aboriginal Syllabics Extended"](t) || Gr["Vertical Forms"](t) || Gr["Yijing Hexagram Symbols"](t) || Gr["Yi Syllables"](t) || Gr["Yi Radicals"](t)))) } function Wr(t) { return !(Xr(t) || function (t) { return !!(Gr["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Gr["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Gr["Letterlike Symbols"](t) || Gr["Number Forms"](t) || Gr["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Gr["Control Pictures"](t) && 9251 !== t || Gr["Optical Character Recognition"](t) || Gr["Enclosed Alphanumerics"](t) || Gr["Geometric Shapes"](t) || Gr["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Gr["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Gr["CJK Symbols and Punctuation"](t) || Gr.Katakana(t) || Gr["Private Use Area"](t) || Gr["CJK Compatibility Forms"](t) || Gr["Small Form Variants"](t) || Gr["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t) }(t)) } function Kr(t) { return t >= 1424 && t <= 2303 || Gr["Arabic Presentation Forms-A"](t) || Gr["Arabic Presentation Forms-B"](t) } function Hr(t, e) { return !(!e && Kr(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Gr.Khmer(t)) } function $r(t) { for (var e = 0, i = t; e < i.length; e += 1)if (Kr(i[e].charCodeAt(0))) return !0; return !1 } var Jr = null, Yr = "unavailable", Qr = null, tn = function (t) { t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Yr = "error"), Jr && Jr(t) }; function en() { rn.fire(new It("pluginStateChange", { pluginStatus: Yr, pluginURL: Qr })) } var rn = new At, nn = function () { return Yr }, an = function () { if ("deferred" !== Yr || !Qr) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified"); Yr = "loading", en(), Qr && xt({ url: Qr }, (function (t) { t ? tn(t) : (Yr = "loaded", en()) })) }, on = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function () { return "loaded" === Yr || null != on.applyArabicShaping }, isLoading: function () { return "loading" === Yr }, setState: function (t) { Yr = t.pluginStatus, Qr = t.pluginURL }, isParsed: function () { return null != on.applyArabicShaping && null != on.processBidirectionalText && null != on.processStyledBidirectionalText }, getPluginURL: function () { return Qr } }, sn = function (t, e) { this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new qr, this.transition = {}) }; sn.prototype.isSupportedScript = function (t) { return function (t, e) { for (var i = 0, r = t; i < r.length; i += 1)if (!Hr(r[i].charCodeAt(0), e)) return !1; return !0 }(t, on.isLoaded()) }, sn.prototype.crossFadingFactor = function () { return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) }, sn.prototype.getCrossfadeParameters = function () { var t = this.zoom, e = t - Math.floor(t), i = this.crossFadingFactor(); return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e + (1 - e) * i } : { fromScale: .5, toScale: 1, t: 1 - (1 - i) * e } }; var ln = function (t, e) { this.property = t, this.value = e, this.expression = function (t, e) { if (Oi(t)) return new $i(t, e); if (Zi(t)) { var i = Hi(t, e); if ("error" === i.result) throw new Error(i.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); return i.value } var r = t; return "string" == typeof t && "color" === e.type && (r = te.parse(t)), { kind: "constant", evaluate: function () { return r } } }(void 0 === e ? t.specification.default : e, t.specification) }; ln.prototype.isDataDriven = function () { return "source" === this.expression.kind || "composite" === this.expression.kind }, ln.prototype.possiblyEvaluate = function (t, e, i) { return this.property.possiblyEvaluate(this, t, e, i) }; var un = function (t) { this.property = t, this.value = new ln(t, void 0) }; un.prototype.transitioned = function (t, e) { return new cn(this.property, this.value, e, p({}, t.transition, this.transition), t.now) }, un.prototype.untransitioned = function () { return new cn(this.property, this.value, null, {}, 0) }; var hn = function (t) { this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues) }; hn.prototype.getValue = function (t) { return b(this._values[t].value.value) }, hn.prototype.setValue = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new un(this._values[t].property)), this._values[t].value = new ln(this._values[t].property, null === e ? void 0 : b(e)) }, hn.prototype.getTransition = function (t) { return b(this._values[t].transition) }, hn.prototype.setTransition = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new un(this._values[t].property)), this._values[t].transition = b(e) || void 0 }, hn.prototype.serialize = function () { for (var t = {}, e = 0, i = Object.keys(this._values); e < i.length; e += 1) { var r = i[e], n = this.getValue(r); void 0 !== n && (t[r] = n); var a = this.getTransition(r); void 0 !== a && (t[r + "-transition"] = a) } return t }, hn.prototype.transitioned = function (t, e) { for (var i = new pn(this._properties), r = 0, n = Object.keys(this._values); r < n.length; r += 1) { var a = n[r]; i._values[a] = this._values[a].transitioned(t, e._values[a]) } return i }, hn.prototype.untransitioned = function () { for (var t = new pn(this._properties), e = 0, i = Object.keys(this._values); e < i.length; e += 1) { var r = i[e]; t._values[r] = this._values[r].untransitioned() } return t }; var cn = function (t, e, i, r, n) { this.property = t, this.value = e, this.begin = n + r.delay || 0, this.end = this.begin + r.duration || 0, t.specification.transition && (r.delay || r.duration) && (this.prior = i) }; cn.prototype.possiblyEvaluate = function (t, e, i) { var r = t.now || 0, n = this.value.possiblyEvaluate(t, e, i), a = this.prior; if (a) { if (r > this.end) return this.prior = null, n; if (this.value.isDataDriven()) return this.prior = null, n; if (r < this.begin) return a.possiblyEvaluate(t, e, i); var o = (r - this.begin) / (this.end - this.begin); return this.property.interpolate(a.possiblyEvaluate(t, e, i), n, function (t) { if (t <= 0) return 0; if (t >= 1) return 1; var e = t * t, i = e * t; return 4 * (t < .5 ? i : 3 * (t - e) + i - .75) }(o)) } return n }; var pn = function (t) { this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues) }; pn.prototype.possiblyEvaluate = function (t, e, i) { for (var r = new mn(this._properties), n = 0, a = Object.keys(this._values); n < a.length; n += 1) { var o = a[n]; r._values[o] = this._values[o].possiblyEvaluate(t, e, i) } return r }, pn.prototype.hasTransition = function () { for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1)if (this._values[e[t]].prior) return !0; return !1 }; var fn = function (t) { this._properties = t, this._values = Object.create(t.defaultPropertyValues) }; fn.prototype.getValue = function (t) { return b(this._values[t].value) }, fn.prototype.setValue = function (t, e) { this._values[t] = new ln(this._values[t].property, null === e ? void 0 : b(e)) }, fn.prototype.serialize = function () { for (var t = {}, e = 0, i = Object.keys(this._values); e < i.length; e += 1) { var r = i[e], n = this.getValue(r); void 0 !== n && (t[r] = n) } return t }, fn.prototype.possiblyEvaluate = function (t, e, i) { for (var r = new mn(this._properties), n = 0, a = Object.keys(this._values); n < a.length; n += 1) { var o = a[n]; r._values[o] = this._values[o].possiblyEvaluate(t, e, i) } return r }; var dn = function (t, e, i) { this.property = t, this.value = e, this.parameters = i }; dn.prototype.isConstant = function () { return "constant" === this.value.kind }, dn.prototype.constantOr = function (t) { return "constant" === this.value.kind ? this.value.value : t }, dn.prototype.evaluate = function (t, e, i, r) { return this.property.evaluate(this.value, this.parameters, t, e, i, r) }; var mn = function (t) { this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues) }; mn.prototype.get = function (t) { return this._values[t] }; var yn = function (t) { this.specification = t }; yn.prototype.possiblyEvaluate = function (t, e) { return t.expression.evaluate(e) }, yn.prototype.interpolate = function (t, e, i) { var r = Ze[this.specification.type]; return r ? r(t, e, i) : t }; var gn = function (t, e) { this.specification = t, this.overrides = e }; gn.prototype.possiblyEvaluate = function (t, e, i, r) { return new dn(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? { kind: "constant", value: t.expression.evaluate(e, null, {}, i, r) } : t.expression, e) }, gn.prototype.interpolate = function (t, e, i) { if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t; if (void 0 === t.value.value || void 0 === e.value.value) return new dn(this, { kind: "constant", value: void 0 }, t.parameters); var r = Ze[this.specification.type]; return r ? new dn(this, { kind: "constant", value: r(t.value.value, e.value.value, i) }, t.parameters) : t }, gn.prototype.evaluate = function (t, e, i, r, n, a) { return "constant" === t.kind ? t.value : t.evaluate(e, i, r, n, a) }; var _n = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (t, e, i, r) { if (void 0 === t.value) return new dn(this, { kind: "constant", value: void 0 }, e); if ("constant" === t.expression.kind) { var n = t.expression.evaluate(e, null, {}, i, r), a = "resolvedImage" === t.property.specification.type && "string" != typeof n ? n.name : n, o = this._calculate(a, a, a, e); return new dn(this, { kind: "constant", value: o }, e) } if ("camera" === t.expression.kind) { var s = this._calculate(t.expression.evaluate({ zoom: e.zoom - 1 }), t.expression.evaluate({ zoom: e.zoom }), t.expression.evaluate({ zoom: e.zoom + 1 }), e); return new dn(this, { kind: "constant", value: s }, e) } return new dn(this, t.expression, e) }, e.prototype.evaluate = function (t, e, i, r, n, a) { if ("source" === t.kind) { var o = t.evaluate(e, i, r, n, a); return this._calculate(o, o, o, e) } return "composite" === t.kind ? this._calculate(t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, i, r), t.evaluate({ zoom: Math.floor(e.zoom) }, i, r), t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, i, r), e) : t.value }, e.prototype._calculate = function (t, e, i, r) { return r.zoom > r.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: i, to: e } }, e.prototype.interpolate = function (t) { return t }, e }(gn), vn = function (t) { this.specification = t }; vn.prototype.possiblyEvaluate = function (t, e, i, r) { if (void 0 !== t.value) { if ("constant" === t.expression.kind) { var n = t.expression.evaluate(e, null, {}, i, r); return this._calculate(n, n, n, e) } return this._calculate(t.expression.evaluate(new sn(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new sn(Math.floor(e.zoom), e)), t.expression.evaluate(new sn(Math.floor(e.zoom + 1), e)), e) } }, vn.prototype._calculate = function (t, e, i, r) { return r.zoom > r.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: i, to: e } }, vn.prototype.interpolate = function (t) { return t }; var xn = function (t) { this.specification = t }; xn.prototype.possiblyEvaluate = function (t, e, i, r) { return !!t.expression.evaluate(e, null, {}, i, r) }, xn.prototype.interpolate = function () { return !1 }; var bn = function (t) { for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t) { var i = t[e]; i.specification.overridable && this.overridableProperties.push(e); var r = this.defaultPropertyValues[e] = new ln(i, void 0), n = this.defaultTransitionablePropertyValues[e] = new un(i); this.defaultTransitioningPropertyValues[e] = n.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = r.possiblyEvaluate({}) } }; Or("DataDrivenProperty", gn), Or("DataConstantProperty", yn), Or("CrossFadedDataDrivenProperty", _n), Or("CrossFadedProperty", vn), Or("ColorRampProperty", xn); var wn = function (t) { function e(e, i) { if (t.call(this), this.id = e.id, this.type = e.type, this._featureFilter = { filter: function () { return !0 }, needGeometry: !1 }, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), i.layout && (this._unevaluatedLayout = new fn(i.layout)), i.paint)) { for (var r in this._transitionablePaint = new hn(i.paint), e.paint) this.setPaintProperty(r, e.paint[r], { validate: !1 }); for (var n in e.layout) this.setLayoutProperty(n, e.layout[n], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mn(i.paint) } } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getCrossfadeParameters = function () { return this._crossfadeParameters }, e.prototype.getLayoutProperty = function (t) { return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t) }, e.prototype.setLayoutProperty = function (t, e, i) { void 0 === i && (i = {}), null != e && this._validate(Cr, "layers." + this.id + ".layout." + t, t, e, i) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e) }, e.prototype.getPaintProperty = function (t) { return _(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t) }, e.prototype.setPaintProperty = function (t, e, i) { if (void 0 === i && (i = {}), null != e && this._validate(Pr, "layers." + this.id + ".paint." + t, t, e, i)) return !1; if (_(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1; var r = this._transitionablePaint._values[t], n = "cross-faded-data-driven" === r.property.specification["property-type"], a = r.value.isDataDriven(), o = r.value; this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t); var s = this._transitionablePaint._values[t].value; return s.isDataDriven() || a || n || this._handleOverridablePaintPropertyUpdate(t, o, s) }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, e, i) { return !1 }, e.prototype.isHidden = function (t) { return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility }, e.prototype.updateTransitions = function (t) { this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint) }, e.prototype.hasTransition = function () { return this._transitioningPaint.hasTransition() }, e.prototype.recalculate = function (t, e) { t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e) }, e.prototype.serialize = function () { var t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), x(t, (function (t, e) { return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length) })) }, e.prototype._validate = function (t, e, i, r, n) { return void 0 === n && (n = {}), (!n || !1 !== n.validate) && zr(this, t.call(Tr, { key: e, layerType: this.type, objectKey: i, value: r, styleSpec: Pt, style: { glyphs: !0, sprite: !0 } })) }, e.prototype.is3D = function () { return !1 }, e.prototype.isTileClipped = function () { return !1 }, e.prototype.hasOffscreenPass = function () { return !1 }, e.prototype.resize = function () { }, e.prototype.isStateDependent = function () { for (var t in this.paint._values) { var e = this.paint.get(t); if (e instanceof dn && Li(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0 } return !1 }, e }(At), Mn = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Sn = function (t, e) { this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 }, En = function () { this.isTransferred = !1, this.capacity = -1, this.resize(0) }; function In(t, e) { void 0 === e && (e = 1); var i = 0, r = 0; return { members: t.map((function (t) { var n = Mn[t.type].BYTES_PER_ELEMENT, a = i = Tn(i, Math.max(e, n)), o = t.components || 1; return r = Math.max(r, n), i += n * o, { name: t.name, type: t.type, components: o, offset: a } })), size: Tn(i, Math.max(r, e)), alignment: e } } function Tn(t, e) { return Math.ceil(t / e) * e } En.serialize = function (t, e) { return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer } }, En.deserialize = function (t) { var e = Object.create(this.prototype); return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e }, En.prototype._trim = function () { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) }, En.prototype.clear = function () { this.length = 0 }, En.prototype.resize = function (t) { this.reserve(t), this.length = t }, En.prototype.reserve = function (t) { if (t > this.capacity) { this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); var e = this.uint8; this._refreshViews(), e && this.uint8.set(e) } }, En.prototype._refreshViews = function () { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") }; var An = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e) }, e.prototype.emplace = function (t, e, i) { var r = 2 * t; return this.int16[r + 0] = e, this.int16[r + 1] = i, t }, e }(En); An.prototype.bytesPerElement = 4, Or("StructArrayLayout2i4", An); var Pn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e, i, r) }, e.prototype.emplace = function (t, e, i, r, n) { var a = 4 * t; return this.int16[a + 0] = e, this.int16[a + 1] = i, this.int16[a + 2] = r, this.int16[a + 3] = n, t }, e }(En); Pn.prototype.bytesPerElement = 8, Or("StructArrayLayout4i8", Pn); var Cn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a) { var o = this.length; return this.resize(o + 1), this.emplace(o, t, e, i, r, n, a) }, e.prototype.emplace = function (t, e, i, r, n, a, o) { var s = 6 * t; return this.int16[s + 0] = e, this.int16[s + 1] = i, this.int16[s + 2] = r, this.int16[s + 3] = n, this.int16[s + 4] = a, this.int16[s + 5] = o, t }, e }(En); Cn.prototype.bytesPerElement = 12, Or("StructArrayLayout2i4i12", Cn); var zn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a) { var o = this.length; return this.resize(o + 1), this.emplace(o, t, e, i, r, n, a) }, e.prototype.emplace = function (t, e, i, r, n, a, o) { var s = 4 * t, l = 8 * t; return this.int16[s + 0] = e, this.int16[s + 1] = i, this.uint8[l + 4] = r, this.uint8[l + 5] = n, this.uint8[l + 6] = a, this.uint8[l + 7] = o, t }, e }(En); zn.prototype.bytesPerElement = 8, Or("StructArrayLayout2i4ub8", zn); var kn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e) }, e.prototype.emplace = function (t, e, i) { var r = 2 * t; return this.float32[r + 0] = e, this.float32[r + 1] = i, t }, e }(En); kn.prototype.bytesPerElement = 8, Or("StructArrayLayout2f8", kn); var Ln = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a, o, s, l, u) { var h = this.length; return this.resize(h + 1), this.emplace(h, t, e, i, r, n, a, o, s, l, u) }, e.prototype.emplace = function (t, e, i, r, n, a, o, s, l, u, h) { var c = 10 * t; return this.uint16[c + 0] = e, this.uint16[c + 1] = i, this.uint16[c + 2] = r, this.uint16[c + 3] = n, this.uint16[c + 4] = a, this.uint16[c + 5] = o, this.uint16[c + 6] = s, this.uint16[c + 7] = l, this.uint16[c + 8] = u, this.uint16[c + 9] = h, t }, e }(En); Ln.prototype.bytesPerElement = 20, Or("StructArrayLayout10ui20", Ln); var Dn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a, o, s, l, u, h, c) { var p = this.length; return this.resize(p + 1), this.emplace(p, t, e, i, r, n, a, o, s, l, u, h, c) }, e.prototype.emplace = function (t, e, i, r, n, a, o, s, l, u, h, c, p) { var f = 12 * t; return this.int16[f + 0] = e, this.int16[f + 1] = i, this.int16[f + 2] = r, this.int16[f + 3] = n, this.uint16[f + 4] = a, this.uint16[f + 5] = o, this.uint16[f + 6] = s, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = h, this.int16[f + 10] = c, this.int16[f + 11] = p, t }, e }(En); Dn.prototype.bytesPerElement = 24, Or("StructArrayLayout4i4ui4i24", Dn); var Rn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, i) }, e.prototype.emplace = function (t, e, i, r) { var n = 3 * t; return this.float32[n + 0] = e, this.float32[n + 1] = i, this.float32[n + 2] = r, t }, e }(En); Rn.prototype.bytesPerElement = 12, Or("StructArrayLayout3f12", Rn); var Bn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.uint32[1 * t + 0] = e, t }, e }(En); Bn.prototype.bytesPerElement = 4, Or("StructArrayLayout1ul4", Bn); var On = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a, o, s, l) { var u = this.length; return this.resize(u + 1), this.emplace(u, t, e, i, r, n, a, o, s, l) }, e.prototype.emplace = function (t, e, i, r, n, a, o, s, l, u) { var h = 10 * t, c = 5 * t; return this.int16[h + 0] = e, this.int16[h + 1] = i, this.int16[h + 2] = r, this.int16[h + 3] = n, this.int16[h + 4] = a, this.int16[h + 5] = o, this.uint32[c + 3] = s, this.uint16[h + 8] = l, this.uint16[h + 9] = u, t }, e }(En); On.prototype.bytesPerElement = 20, Or("StructArrayLayout6i1ul2ui20", On); var Fn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a) { var o = this.length; return this.resize(o + 1), this.emplace(o, t, e, i, r, n, a) }, e.prototype.emplace = function (t, e, i, r, n, a, o) { var s = 6 * t; return this.int16[s + 0] = e, this.int16[s + 1] = i, this.int16[s + 2] = r, this.int16[s + 3] = n, this.int16[s + 4] = a, this.int16[s + 5] = o, t }, e }(En); Fn.prototype.bytesPerElement = 12, Or("StructArrayLayout2i2i2i12", Fn); var Un = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n) { var a = this.length; return this.resize(a + 1), this.emplace(a, t, e, i, r, n) }, e.prototype.emplace = function (t, e, i, r, n, a) { var o = 4 * t, s = 8 * t; return this.float32[o + 0] = e, this.float32[o + 1] = i, this.float32[o + 2] = r, this.int16[s + 6] = n, this.int16[s + 7] = a, t }, e }(En); Un.prototype.bytesPerElement = 16, Or("StructArrayLayout2f1f2i16", Un); var Nn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e, i, r) }, e.prototype.emplace = function (t, e, i, r, n) { var a = 12 * t, o = 3 * t; return this.uint8[a + 0] = e, this.uint8[a + 1] = i, this.float32[o + 1] = r, this.float32[o + 2] = n, t }, e }(En); Nn.prototype.bytesPerElement = 12, Or("StructArrayLayout2ub2f12", Nn); var Vn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, i) }, e.prototype.emplace = function (t, e, i, r) { var n = 3 * t; return this.uint16[n + 0] = e, this.uint16[n + 1] = i, this.uint16[n + 2] = r, t }, e }(En); Vn.prototype.bytesPerElement = 6, Or("StructArrayLayout3ui6", Vn); var jn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y) { var g = this.length; return this.resize(g + 1), this.emplace(g, t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y) }, e.prototype.emplace = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g) { var _ = 24 * t, v = 12 * t, x = 48 * t; return this.int16[_ + 0] = e, this.int16[_ + 1] = i, this.uint16[_ + 2] = r, this.uint16[_ + 3] = n, this.uint32[v + 2] = a, this.uint32[v + 3] = o, this.uint32[v + 4] = s, this.uint16[_ + 10] = l, this.uint16[_ + 11] = u, this.uint16[_ + 12] = h, this.float32[v + 7] = c, this.float32[v + 8] = p, this.uint8[x + 36] = f, this.uint8[x + 37] = d, this.uint8[x + 38] = m, this.uint32[v + 10] = y, this.int16[_ + 22] = g, t }, e }(En); jn.prototype.bytesPerElement = 48, Or("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", jn); var qn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, M, S, E, I, T) { var A = this.length; return this.resize(A + 1), this.emplace(A, t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, M, S, E, I, T) }, e.prototype.emplace = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, M, S, E, I, T, A) { var P = 34 * t, C = 17 * t; return this.int16[P + 0] = e, this.int16[P + 1] = i, this.int16[P + 2] = r, this.int16[P + 3] = n, this.int16[P + 4] = a, this.int16[P + 5] = o, this.int16[P + 6] = s, this.int16[P + 7] = l, this.uint16[P + 8] = u, this.uint16[P + 9] = h, this.uint16[P + 10] = c, this.uint16[P + 11] = p, this.uint16[P + 12] = f, this.uint16[P + 13] = d, this.uint16[P + 14] = m, this.uint16[P + 15] = y, this.uint16[P + 16] = g, this.uint16[P + 17] = _, this.uint16[P + 18] = v, this.uint16[P + 19] = x, this.uint16[P + 20] = b, this.uint16[P + 21] = w, this.uint16[P + 22] = M, this.uint32[C + 12] = S, this.float32[C + 13] = E, this.float32[C + 14] = I, this.float32[C + 15] = T, this.float32[C + 16] = A, t }, e }(En); qn.prototype.bytesPerElement = 68, Or("StructArrayLayout8i15ui1ul4f68", qn); var Gn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.float32[1 * t + 0] = e, t }, e }(En); Gn.prototype.bytesPerElement = 4, Or("StructArrayLayout1f4", Gn); var Zn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, i) }, e.prototype.emplace = function (t, e, i, r) { var n = 3 * t; return this.int16[n + 0] = e, this.int16[n + 1] = i, this.int16[n + 2] = r, t }, e }(En); Zn.prototype.bytesPerElement = 6, Or("StructArrayLayout3i6", Zn); var Xn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i) { var r = this.length; return this.resize(r + 1), this.emplace(r, t, e, i) }, e.prototype.emplace = function (t, e, i, r) { var n = 4 * t; return this.uint32[2 * t + 0] = e, this.uint16[n + 2] = i, this.uint16[n + 3] = r, t }, e }(En); Xn.prototype.bytesPerElement = 8, Or("StructArrayLayout1ul2ui8", Xn); var Wn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e) { var i = this.length; return this.resize(i + 1), this.emplace(i, t, e) }, e.prototype.emplace = function (t, e, i) { var r = 2 * t; return this.uint16[r + 0] = e, this.uint16[r + 1] = i, t }, e }(En); Wn.prototype.bytesPerElement = 4, Or("StructArrayLayout2ui4", Wn); var Kn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t) { var e = this.length; return this.resize(e + 1), this.emplace(e, t) }, e.prototype.emplace = function (t, e) { return this.uint16[1 * t + 0] = e, t }, e }(En); Kn.prototype.bytesPerElement = 2, Or("StructArrayLayout1ui2", Kn); var Hn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, e.prototype.emplaceBack = function (t, e, i, r) { var n = this.length; return this.resize(n + 1), this.emplace(n, t, e, i, r) }, e.prototype.emplace = function (t, e, i, r, n) { var a = 4 * t; return this.float32[a + 0] = e, this.float32[a + 1] = i, this.float32[a + 2] = r, this.float32[a + 3] = n, t }, e }(En); Hn.prototype.bytesPerElement = 16, Or("StructArrayLayout4f16", Hn); var $n = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var i = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } }; return i.anchorPointX.get = function () { return this._structArray.int16[this._pos2 + 0] }, i.anchorPointY.get = function () { return this._structArray.int16[this._pos2 + 1] }, i.x1.get = function () { return this._structArray.int16[this._pos2 + 2] }, i.y1.get = function () { return this._structArray.int16[this._pos2 + 3] }, i.x2.get = function () { return this._structArray.int16[this._pos2 + 4] }, i.y2.get = function () { return this._structArray.int16[this._pos2 + 5] }, i.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, i.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 8] }, i.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 9] }, i.anchorPoint.get = function () { return new n(this.anchorPointX, this.anchorPointY) }, Object.defineProperties(e.prototype, i), e }(Sn); $n.prototype.size = 20; var Jn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new $n(this, t) }, e }(On); Or("CollisionBoxArray", Jn); var Yn = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var i = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } }; return i.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0] }, i.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1] }, i.glyphStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, i.numGlyphs.get = function () { return this._structArray.uint16[this._pos2 + 3] }, i.vertexStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 2] }, i.lineStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, i.lineLength.get = function () { return this._structArray.uint32[this._pos4 + 4] }, i.segment.get = function () { return this._structArray.uint16[this._pos2 + 10] }, i.lowerSize.get = function () { return this._structArray.uint16[this._pos2 + 11] }, i.upperSize.get = function () { return this._structArray.uint16[this._pos2 + 12] }, i.lineOffsetX.get = function () { return this._structArray.float32[this._pos4 + 7] }, i.lineOffsetY.get = function () { return this._structArray.float32[this._pos4 + 8] }, i.writingMode.get = function () { return this._structArray.uint8[this._pos1 + 36] }, i.placedOrientation.get = function () { return this._structArray.uint8[this._pos1 + 37] }, i.placedOrientation.set = function (t) { this._structArray.uint8[this._pos1 + 37] = t }, i.hidden.get = function () { return this._structArray.uint8[this._pos1 + 38] }, i.hidden.set = function (t) { this._structArray.uint8[this._pos1 + 38] = t }, i.crossTileID.get = function () { return this._structArray.uint32[this._pos4 + 10] }, i.crossTileID.set = function (t) { this._structArray.uint32[this._pos4 + 10] = t }, i.associatedIconIndex.get = function () { return this._structArray.int16[this._pos2 + 22] }, Object.defineProperties(e.prototype, i), e }(Sn); Yn.prototype.size = 48; var Qn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new Yn(this, t) }, e }(jn); Or("PlacedSymbolArray", Qn); var ta = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var i = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } }; return i.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0] }, i.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1] }, i.rightJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 2] }, i.centerJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 3] }, i.leftJustifiedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 4] }, i.verticalPlacedTextSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 5] }, i.placedIconSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 6] }, i.verticalPlacedIconSymbolIndex.get = function () { return this._structArray.int16[this._pos2 + 7] }, i.key.get = function () { return this._structArray.uint16[this._pos2 + 8] }, i.textBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 9] }, i.textBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 10] }, i.verticalTextBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 11] }, i.verticalTextBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 12] }, i.iconBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 13] }, i.iconBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 14] }, i.verticalIconBoxStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 15] }, i.verticalIconBoxEndIndex.get = function () { return this._structArray.uint16[this._pos2 + 16] }, i.featureIndex.get = function () { return this._structArray.uint16[this._pos2 + 17] }, i.numHorizontalGlyphVertices.get = function () { return this._structArray.uint16[this._pos2 + 18] }, i.numVerticalGlyphVertices.get = function () { return this._structArray.uint16[this._pos2 + 19] }, i.numIconVertices.get = function () { return this._structArray.uint16[this._pos2 + 20] }, i.numVerticalIconVertices.get = function () { return this._structArray.uint16[this._pos2 + 21] }, i.useRuntimeCollisionCircles.get = function () { return this._structArray.uint16[this._pos2 + 22] }, i.crossTileID.get = function () { return this._structArray.uint32[this._pos4 + 12] }, i.crossTileID.set = function (t) { this._structArray.uint32[this._pos4 + 12] = t }, i.textBoxScale.get = function () { return this._structArray.float32[this._pos4 + 13] }, i.textOffset0.get = function () { return this._structArray.float32[this._pos4 + 14] }, i.textOffset1.get = function () { return this._structArray.float32[this._pos4 + 15] }, i.collisionCircleDiameter.get = function () { return this._structArray.float32[this._pos4 + 16] }, Object.defineProperties(e.prototype, i), e }(Sn); ta.prototype.size = 68; var ea = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new ta(this, t) }, e }(qn); Or("SymbolInstanceArray", ea); var ia = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getoffsetX = function (t) { return this.float32[1 * t + 0] }, e }(Gn); Or("GlyphOffsetArray", ia); var ra = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getx = function (t) { return this.int16[3 * t + 0] }, e.prototype.gety = function (t) { return this.int16[3 * t + 1] }, e.prototype.gettileUnitDistanceFromAnchor = function (t) { return this.int16[3 * t + 2] }, e }(Zn); Or("SymbolLineVertexArray", ra); var na = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var i = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } }; return i.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 0] }, i.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, i.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 3] }, Object.defineProperties(e.prototype, i), e }(Sn); na.prototype.size = 8; var aa = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) { return new na(this, t) }, e }(Xn); Or("FeatureIndexArray", aa); var oa = In([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, sa = function (t) { void 0 === t && (t = []), this.segments = t }; function la(t, e) { return 256 * (t = h(Math.floor(t), 0, 255)) + h(Math.floor(e), 0, 255) } sa.prototype.prepareSegment = function (t, e, i, r) { var n = this.segments[this.segments.length - 1]; return t > sa.MAX_VERTEX_ARRAY_LENGTH && M("Max vertices per segment is " + sa.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!n || n.vertexLength + t > sa.MAX_VERTEX_ARRAY_LENGTH || n.sortKey !== r) && (n = { vertexOffset: e.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== r && (n.sortKey = r), this.segments.push(n)), n }, sa.prototype.get = function () { return this.segments }, sa.prototype.destroy = function () { for (var t = 0, e = this.segments; t < e.length; t += 1) { var i = e[t]; for (var r in i.vaos) i.vaos[r].destroy() } }, sa.simpleSegment = function (t, e, i, r) { return new sa([{ vertexOffset: t, primitiveOffset: e, vertexLength: i, primitiveLength: r, vaos: {}, sortKey: 0 }]) }, sa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Or("SegmentVector", sa); var ua = In([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), ha = e((function (t) { t.exports = function (t, e) { var i, r, n, a, o, s, l, u; for (r = t.length - (i = 3 & t.length), n = e, o = 3432918353, s = 461845907, u = 0; u < r;)l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, n = 27492 + (65535 & (a = 5 * (65535 & (n = (n ^= l = (65535 & (l = (l = (65535 & l) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 13 | n >>> 19)) + ((5 * (n >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16); switch (l = 0, i) { case 3: l ^= (255 & t.charCodeAt(u + 2)) << 16; case 2: l ^= (255 & t.charCodeAt(u + 1)) << 8; case 1: n ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295 }return n ^= t.length, n = 2246822507 * (65535 & (n ^= n >>> 16)) + ((2246822507 * (n >>> 16) & 65535) << 16) & 4294967295, n = 3266489909 * (65535 & (n ^= n >>> 13)) + ((3266489909 * (n >>> 16) & 65535) << 16) & 4294967295, (n ^= n >>> 16) >>> 0 } })), ca = e((function (t) { t.exports = function (t, e) { for (var i, r = t.length, n = e ^ r, a = 0; r >= 4;)i = 1540483477 * (65535 & (i = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24)) + ((1540483477 * (i >>> 16) & 65535) << 16), n = 1540483477 * (65535 & n) + ((1540483477 * (n >>> 16) & 65535) << 16) ^ (i = 1540483477 * (65535 & (i ^= i >>> 24)) + ((1540483477 * (i >>> 16) & 65535) << 16)), r -= 4, ++a; switch (r) { case 3: n ^= (255 & t.charCodeAt(a + 2)) << 16; case 2: n ^= (255 & t.charCodeAt(a + 1)) << 8; case 1: n = 1540483477 * (65535 & (n ^= 255 & t.charCodeAt(a))) + ((1540483477 * (n >>> 16) & 65535) << 16) }return n = 1540483477 * (65535 & (n ^= n >>> 13)) + ((1540483477 * (n >>> 16) & 65535) << 16), (n ^= n >>> 15) >>> 0 } })), pa = ha, fa = ca; pa.murmur3 = ha, pa.murmur2 = fa; var da = function () { this.ids = [], this.positions = [], this.indexed = !1 }; da.prototype.add = function (t, e, i, r) { this.ids.push(ya(t)), this.positions.push(e, i, r) }, da.prototype.getPositions = function (t) { for (var e = ya(t), i = 0, r = this.ids.length - 1; i < r;) { var n = i + r >> 1; this.ids[n] >= e ? r = n : i = n + 1 } for (var a = []; this.ids[i] === e;)a.push({ index: this.positions[3 * i], start: this.positions[3 * i + 1], end: this.positions[3 * i + 2] }), i++; return a }, da.serialize = function (t, e) { var i = new Float64Array(t.ids), r = new Uint32Array(t.positions); return function t(e, i, r, n) { for (; r < n;) { for (var a = e[r + n >> 1], o = r - 1, s = n + 1; ;) { do { o++ } while (e[o] < a); do { s-- } while (e[s] > a); if (o >= s) break; ga(e, o, s), ga(i, 3 * o, 3 * s), ga(i, 3 * o + 1, 3 * s + 1), ga(i, 3 * o + 2, 3 * s + 2) } s - r < n - s ? (t(e, i, r, s), r = s + 1) : (t(e, i, s + 1, n), n = s) } }(i, r, 0, i.length - 1), e && e.push(i.buffer, r.buffer), { ids: i, positions: r } }, da.deserialize = function (t) { var e = new da; return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e }; var ma = Math.pow(2, 53) - 1; function ya(t) { var e = +t; return !isNaN(e) && e <= ma ? e : pa(String(t)) } function ga(t, e, i) { var r = t[e]; t[e] = t[i], t[i] = r } Or("FeaturePositionMap", da); var _a = function (t, e) { this.gl = t.gl, this.location = e }, va = function (t) { function e(e, i) { t.call(this, e, i), this.current = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t)) }, e }(_a), xa = function (t) { function e(e, i) { t.call(this, e, i), this.current = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t)) }, e }(_a), ba = function (t) { function e(e, i) { t.call(this, e, i), this.current = [0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1])) }, e }(_a), wa = function (t) { function e(e, i) { t.call(this, e, i), this.current = [0, 0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2])) }, e }(_a), Ma = function (t) { function e(e, i) { t.call(this, e, i), this.current = [0, 0, 0, 0] } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3])) }, e }(_a), Sa = function (t) { function e(e, i) { t.call(this, e, i), this.current = te.transparent } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a)) }, e }(_a), Ea = new Float32Array(16), Ia = function (t) { function e(e, i) { t.call(this, e, i), this.current = Ea } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t); for (var e = 1; e < 16; e++)if (t[e] !== this.current[e]) { this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t); break } }, e }(_a); function Ta(t) { return [la(255 * t.r, 255 * t.g), la(255 * t.b, 255 * t.a)] } var Aa = function (t, e, i) { this.value = t, this.uniformNames = e.map((function (t) { return "u_" + t })), this.type = i }; Aa.prototype.setUniform = function (t, e, i) { t.set(i.constantOr(this.value)) }, Aa.prototype.getBinding = function (t, e, i) { return "color" === this.type ? new Sa(t, e) : new xa(t, e) }; var Pa = function (t, e) { this.uniformNames = e.map((function (t) { return "u_" + t })), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1 }; Pa.prototype.setConstantPatternPositions = function (t, e) { this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr }, Pa.prototype.setUniform = function (t, e, i, r) { var n = "u_pattern_to" === r ? this.patternTo : "u_pattern_from" === r ? this.patternFrom : "u_pixel_ratio_to" === r ? this.pixelRatioTo : "u_pixel_ratio_from" === r ? this.pixelRatioFrom : null; n && t.set(n) }, Pa.prototype.getBinding = function (t, e, i) { return "u_pattern" === i.substr(0, 9) ? new Ma(t, e) : new xa(t, e) }; var Ca = function (t, e, i, r) { this.expression = t, this.type = i, this.maxValue = 0, this.paintVertexAttributes = e.map((function (t) { return { name: "a_" + t, type: "Float32", components: "color" === i ? 2 : 1, offset: 0 } })), this.paintVertexArray = new r }; Ca.prototype.populatePaintArray = function (t, e, i, r, n) { var a = this.paintVertexArray.length, o = this.expression.evaluate(new sn(0), e, {}, r, [], n); this.paintVertexArray.resize(t), this._setPaintValue(a, t, o) }, Ca.prototype.updatePaintArray = function (t, e, i, r) { var n = this.expression.evaluate({ zoom: 0 }, i, r); this._setPaintValue(t, e, n) }, Ca.prototype._setPaintValue = function (t, e, i) { if ("color" === this.type) for (var r = Ta(i), n = t; n < e; n++)this.paintVertexArray.emplace(n, r[0], r[1]); else { for (var a = t; a < e; a++)this.paintVertexArray.emplace(a, i); this.maxValue = Math.max(this.maxValue, Math.abs(i)) } }, Ca.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, Ca.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }; var za = function (t, e, i, r, n, a) { this.expression = t, this.uniformNames = e.map((function (t) { return "u_" + t + "_t" })), this.type = i, this.useIntegerZoom = r, this.zoom = n, this.maxValue = 0, this.paintVertexAttributes = e.map((function (t) { return { name: "a_" + t, type: "Float32", components: "color" === i ? 4 : 2, offset: 0 } })), this.paintVertexArray = new a }; za.prototype.populatePaintArray = function (t, e, i, r, n) { var a = this.expression.evaluate(new sn(this.zoom), e, {}, r, [], n), o = this.expression.evaluate(new sn(this.zoom + 1), e, {}, r, [], n), s = this.paintVertexArray.length; this.paintVertexArray.resize(t), this._setPaintValue(s, t, a, o) }, za.prototype.updatePaintArray = function (t, e, i, r) { var n = this.expression.evaluate({ zoom: this.zoom }, i, r), a = this.expression.evaluate({ zoom: this.zoom + 1 }, i, r); this._setPaintValue(t, e, n, a) }, za.prototype._setPaintValue = function (t, e, i, r) { if ("color" === this.type) for (var n = Ta(i), a = Ta(r), o = t; o < e; o++)this.paintVertexArray.emplace(o, n[0], n[1], a[0], a[1]); else { for (var s = t; s < e; s++)this.paintVertexArray.emplace(s, i, r); this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(r)) } }, za.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, za.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }, za.prototype.setUniform = function (t, e) { var i = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom, r = h(this.expression.interpolationFactor(i, this.zoom, this.zoom + 1), 0, 1); t.set(r) }, za.prototype.getBinding = function (t, e, i) { return new xa(t, e) }; var ka = function (t, e, i, r, n, a) { this.expression = t, this.type = e, this.useIntegerZoom = i, this.zoom = r, this.layerId = a, this.zoomInPaintVertexArray = new n, this.zoomOutPaintVertexArray = new n }; ka.prototype.populatePaintArray = function (t, e, i) { var r = this.zoomInPaintVertexArray.length; this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(r, t, e.patterns && e.patterns[this.layerId], i) }, ka.prototype.updatePaintArray = function (t, e, i, r, n) { this._setPaintValues(t, e, i.patterns && i.patterns[this.layerId], n) }, ka.prototype._setPaintValues = function (t, e, i, r) { if (r && i) { var n = r[i.min], a = r[i.mid], o = r[i.max]; if (n && a && o) for (var s = t; s < e; s++)this.zoomInPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], n.tl[0], n.tl[1], n.br[0], n.br[1], a.pixelRatio, n.pixelRatio), this.zoomOutPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], a.pixelRatio, o.pixelRatio) } }, ka.prototype.upload = function (t) { this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, ua.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, ua.members, this.expression.isStateDependent)) }, ka.prototype.destroy = function () { this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy() }; var La = function (t, e, i) { this.binders = {}, this._buffers = []; var r = []; for (var n in t.paint._values) if (i(n)) { var a = t.paint.get(n); if (a instanceof dn && Li(a.property.specification)) { var o = Ra(n, t.type), s = a.value, l = a.property.specification.type, u = a.property.useIntegerZoom, h = a.property.specification["property-type"], c = "cross-faded" === h || "cross-faded-data-driven" === h; if ("constant" === s.kind) this.binders[n] = c ? new Pa(s.value, o) : new Aa(s.value, o, l), r.push("/u_" + n); else if ("source" === s.kind || c) { var p = Ba(n, l, "source"); this.binders[n] = c ? new ka(s, l, u, e, p, t.id) : new Ca(s, o, l, p), r.push("/a_" + n) } else { var f = Ba(n, l, "composite"); this.binders[n] = new za(s, o, l, u, e, f), r.push("/z_" + n) } } } this.cacheKey = r.sort().join("") }; La.prototype.getMaxValue = function (t) { var e = this.binders[t]; return e instanceof Ca || e instanceof za ? e.maxValue : 0 }, La.prototype.populatePaintArrays = function (t, e, i, r, n) { for (var a in this.binders) { var o = this.binders[a]; (o instanceof Ca || o instanceof za || o instanceof ka) && o.populatePaintArray(t, e, i, r, n) } }, La.prototype.setConstantPatternPositions = function (t, e) { for (var i in this.binders) { var r = this.binders[i]; r instanceof Pa && r.setConstantPatternPositions(t, e) } }, La.prototype.updatePaintArrays = function (t, e, i, r, n) { var a = !1; for (var o in t) for (var s = 0, l = e.getPositions(o); s < l.length; s += 1) { var u = l[s], h = i.feature(u.index); for (var c in this.binders) { var p = this.binders[c]; if ((p instanceof Ca || p instanceof za || p instanceof ka) && !0 === p.expression.isStateDependent) { var f = r.paint.get(c); p.expression = f.value, p.updatePaintArray(u.start, u.end, h, t[o], n), a = !0 } } } return a }, La.prototype.defines = function () { var t = []; for (var e in this.binders) { var i = this.binders[e]; (i instanceof Aa || i instanceof Pa) && t.push.apply(t, i.uniformNames.map((function (t) { return "#define HAS_UNIFORM_" + t }))) } return t }, La.prototype.getBinderAttributes = function () { var t = []; for (var e in this.binders) { var i = this.binders[e]; if (i instanceof Ca || i instanceof za) for (var r = 0; r < i.paintVertexAttributes.length; r++)t.push(i.paintVertexAttributes[r].name); else if (i instanceof ka) for (var n = 0; n < ua.members.length; n++)t.push(ua.members[n].name) } return t }, La.prototype.getBinderUniforms = function () { var t = []; for (var e in this.binders) { var i = this.binders[e]; if (i instanceof Aa || i instanceof Pa || i instanceof za) for (var r = 0, n = i.uniformNames; r < n.length; r += 1)t.push(n[r]) } return t }, La.prototype.getPaintVertexBuffers = function () { return this._buffers }, La.prototype.getUniforms = function (t, e) { var i = []; for (var r in this.binders) { var n = this.binders[r]; if (n instanceof Aa || n instanceof Pa || n instanceof za) for (var a = 0, o = n.uniformNames; a < o.length; a += 1) { var s = o[a]; if (e[s]) { var l = n.getBinding(t, e[s], s); i.push({ name: s, property: r, binding: l }) } } } return i }, La.prototype.setUniforms = function (t, e, i, r) { for (var n = 0, a = e; n < a.length; n += 1) { var o = a[n], s = o.name, l = o.property; this.binders[l].setUniform(o.binding, r, i.get(l), s) } }, La.prototype.updatePaintBuffers = function (t) { for (var e in this._buffers = [], this.binders) { var i = this.binders[e]; if (t && i instanceof ka) { var r = 2 === t.fromScale ? i.zoomInPaintVertexBuffer : i.zoomOutPaintVertexBuffer; r && this._buffers.push(r) } else (i instanceof Ca || i instanceof za) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer) } }, La.prototype.upload = function (t) { for (var e in this.binders) { var i = this.binders[e]; (i instanceof Ca || i instanceof za || i instanceof ka) && i.upload(t) } this.updatePaintBuffers() }, La.prototype.destroy = function () { for (var t in this.binders) { var e = this.binders[t]; (e instanceof Ca || e instanceof za || e instanceof ka) && e.destroy() } }; var Da = function (t, e, i) { void 0 === i && (i = function () { return !0 }), this.programConfigurations = {}; for (var r = 0, n = t; r < n.length; r += 1) { var a = n[r]; this.programConfigurations[a.id] = new La(a, e, i) } this.needsUpload = !1, this._featureMap = new da, this._bufferOffset = 0 }; function Ra(t, e) { return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t] || [t.replace(e + "-", "").replace(/-/g, "_")] } function Ba(t, e, i) { var r = { color: { source: kn, composite: Hn }, number: { source: Gn, composite: kn } }, n = function (t) { return { "line-pattern": { source: Ln, composite: Ln }, "fill-pattern": { source: Ln, composite: Ln }, "fill-extrusion-pattern": { source: Ln, composite: Ln } }[t] }(t); return n && n[i] || r[e][i] } Da.prototype.populatePaintArrays = function (t, e, i, r, n, a) { for (var o in this.programConfigurations) this.programConfigurations[o].populatePaintArrays(t, e, r, n, a); void 0 !== e.id && this._featureMap.add(e.id, i, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0 }, Da.prototype.updatePaintArrays = function (t, e, i, r) { for (var n = 0, a = i; n < a.length; n += 1) { var o = a[n]; this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, r) || this.needsUpload } }, Da.prototype.get = function (t) { return this.programConfigurations[t] }, Da.prototype.upload = function (t) { if (this.needsUpload) { for (var e in this.programConfigurations) this.programConfigurations[e].upload(t); this.needsUpload = !1 } }, Da.prototype.destroy = function () { for (var t in this.programConfigurations) this.programConfigurations[t].destroy() }, Or("ConstantBinder", Aa), Or("CrossFadedConstantBinder", Pa), Or("SourceExpressionBinder", Ca), Or("CrossFadedCompositeBinder", ka), Or("CompositeExpressionBinder", za), Or("ProgramConfiguration", La, { omit: ["_buffers"] }), Or("ProgramConfigurationSet", Da); var Oa = Math.pow(2, 14) - 1, Fa = -Oa - 1; function Ua(t) { for (var e = 8192 / t.extent, i = t.loadGeometry(), r = 0; r < i.length; r++)for (var n = i[r], a = 0; a < n.length; a++) { var o = n[a], s = Math.round(o.x * e), l = Math.round(o.y * e); o.x = h(s, Fa, Oa), o.y = h(l, Fa, Oa), (s < o.x || s > o.x + 1 || l < o.y || l > o.y + 1) && M("Geometry exceeds allowed extent, reduce your vector tile buffer size") } return i } function Na(t, e) { return { type: t.type, id: t.id, properties: t.properties, geometry: e ? Ua(t) : [] } } function Va(t, e, i, r, n) { t.emplaceBack(2 * e + (r + 1) / 2, 2 * i + (n + 1) / 2) } var ja = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new An, this.indexArray = new Vn, this.segments = new sa, this.programConfigurations = new Da(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; function qa(t, e) { for (var i = 0; i < t.length; i++)if (Ya(e, t[i])) return !0; for (var r = 0; r < e.length; r++)if (Ya(t, e[r])) return !0; return !!Wa(t, e) } function Ga(t, e, i) { return !!Ya(t, e) || !!Ha(e, t, i) } function Za(t, e) { if (1 === t.length) return Ja(e, t[0]); for (var i = 0; i < e.length; i++)for (var r = e[i], n = 0; n < r.length; n++)if (Ya(t, r[n])) return !0; for (var a = 0; a < t.length; a++)if (Ja(e, t[a])) return !0; for (var o = 0; o < e.length; o++)if (Wa(t, e[o])) return !0; return !1 } function Xa(t, e, i) { if (t.length > 1) { if (Wa(t, e)) return !0; for (var r = 0; r < e.length; r++)if (Ha(e[r], t, i)) return !0 } for (var n = 0; n < t.length; n++)if (Ha(t[n], e, i)) return !0; return !1 } function Wa(t, e) { if (0 === t.length || 0 === e.length) return !1; for (var i = 0; i < t.length - 1; i++)for (var r = t[i], n = t[i + 1], a = 0; a < e.length - 1; a++)if (Ka(r, n, e[a], e[a + 1])) return !0; return !1 } function Ka(t, e, i, r) { return S(t, i, r) !== S(e, i, r) && S(t, e, i) !== S(t, e, r) } function Ha(t, e, i) { var r = i * i; if (1 === e.length) return t.distSqr(e[0]) < r; for (var n = 1; n < e.length; n++)if ($a(t, e[n - 1], e[n]) < r) return !0; return !1 } function $a(t, e, i) { var r = e.distSqr(i); if (0 === r) return t.distSqr(e); var n = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / r; return t.distSqr(n < 0 ? e : n > 1 ? i : i.sub(e)._mult(n)._add(e)) } function Ja(t, e) { for (var i, r, n, a = !1, o = 0; o < t.length; o++)for (var s = 0, l = (i = t[o]).length - 1; s < i.length; l = s++)(r = i[s]).y > e.y != (n = i[l]).y > e.y && e.x < (n.x - r.x) * (e.y - r.y) / (n.y - r.y) + r.x && (a = !a); return a } function Ya(t, e) { for (var i = !1, r = 0, n = t.length - 1; r < t.length; n = r++) { var a = t[r], o = t[n]; a.y > e.y != o.y > e.y && e.x < (o.x - a.x) * (e.y - a.y) / (o.y - a.y) + a.x && (i = !i) } return i } function Qa(t, e, i) { var r = i[0], n = i[2]; if (t.x < r.x && e.x < r.x || t.x > n.x && e.x > n.x || t.y < r.y && e.y < r.y || t.y > n.y && e.y > n.y) return !1; var a = S(t, e, i[0]); return a !== S(t, e, i[1]) || a !== S(t, e, i[2]) || a !== S(t, e, i[3]) } function to(t, e, i) { var r = e.paint.get(t).value; return "constant" === r.kind ? r.value : i.programConfigurations.get(e.id).getMaxValue(t) } function eo(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function io(t, e, i, r, a) { if (!e[0] && !e[1]) return t; var o = n.convert(e)._mult(a); "viewport" === i && o._rotate(-r); for (var s = [], l = 0; l < t.length; l++)s.push(t[l].sub(o)); return s } ja.prototype.populate = function (t, e, i) { var r = this.layers[0], n = [], a = null; "circle" === r.type && (a = r.layout.get("circle-sort-key")); for (var o = 0, s = t; o < s.length; o += 1) { var l = s[o], u = l.feature, h = l.id, c = l.index, p = l.sourceLayerIndex, f = this.layers[0]._featureFilter.needGeometry, d = Na(u, f); if (this.layers[0]._featureFilter.filter(new sn(this.zoom), d, i)) { var m = a ? a.evaluate(d, {}, i) : void 0, y = { id: h, properties: u.properties, type: u.type, sourceLayerIndex: p, index: c, geometry: f ? d.geometry : Ua(u), patterns: {}, sortKey: m }; n.push(y) } } a && n.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var g = 0, _ = n; g < _.length; g += 1) { var v = _[g], x = v.geometry, b = v.index, w = v.sourceLayerIndex, M = t[b].feature; this.addFeature(v, x, b, i), e.featureIndex.insert(M, x, b, w, this.index) } }, ja.prototype.update = function (t, e, i) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i) }, ja.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, ja.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, ja.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, oa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, ja.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, ja.prototype.addFeature = function (t, e, i, r) { for (var n = 0, a = e; n < a.length; n += 1)for (var o = 0, s = a[n]; o < s.length; o += 1) { var l = s[o], u = l.x, h = l.y; if (!(u < 0 || u >= 8192 || h < 0 || h >= 8192)) { var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), p = c.vertexLength; Va(this.layoutVertexArray, u, h, -1, -1), Va(this.layoutVertexArray, u, h, 1, -1), Va(this.layoutVertexArray, u, h, 1, 1), Va(this.layoutVertexArray, u, h, -1, 1), this.indexArray.emplaceBack(p, p + 1, p + 2), this.indexArray.emplaceBack(p, p + 3, p + 2), c.vertexLength += 4, c.primitiveLength += 2 } } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, {}, r) }, Or("CircleBucket", ja, { omit: ["layers"] }); var ro = new bn({ "circle-sort-key": new gn(Pt.layout_circle["circle-sort-key"]) }), no = { paint: new bn({ "circle-radius": new gn(Pt.paint_circle["circle-radius"]), "circle-color": new gn(Pt.paint_circle["circle-color"]), "circle-blur": new gn(Pt.paint_circle["circle-blur"]), "circle-opacity": new gn(Pt.paint_circle["circle-opacity"]), "circle-translate": new yn(Pt.paint_circle["circle-translate"]), "circle-translate-anchor": new yn(Pt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new yn(Pt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new yn(Pt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new gn(Pt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new gn(Pt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new gn(Pt.paint_circle["circle-stroke-opacity"]) }), layout: ro }, ao = "undefined" != typeof Float32Array ? Float32Array : Array; function oo(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function so(t, e, i) { var r = e[0], n = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6], h = e[7], c = e[8], p = e[9], f = e[10], d = e[11], m = e[12], y = e[13], g = e[14], _ = e[15], v = i[0], x = i[1], b = i[2], w = i[3]; return t[0] = v * r + x * s + b * c + w * m, t[1] = v * n + x * l + b * p + w * y, t[2] = v * a + x * u + b * f + w * g, t[3] = v * o + x * h + b * d + w * _, t[4] = (v = i[4]) * r + (x = i[5]) * s + (b = i[6]) * c + (w = i[7]) * m, t[5] = v * n + x * l + b * p + w * y, t[6] = v * a + x * u + b * f + w * g, t[7] = v * o + x * h + b * d + w * _, t[8] = (v = i[8]) * r + (x = i[9]) * s + (b = i[10]) * c + (w = i[11]) * m, t[9] = v * n + x * l + b * p + w * y, t[10] = v * a + x * u + b * f + w * g, t[11] = v * o + x * h + b * d + w * _, t[12] = (v = i[12]) * r + (x = i[13]) * s + (b = i[14]) * c + (w = i[15]) * m, t[13] = v * n + x * l + b * p + w * y, t[14] = v * a + x * u + b * f + w * g, t[15] = v * o + x * h + b * d + w * _, t } Math.hypot || (Math.hypot = function () { for (var t = arguments, e = 0, i = arguments.length; i--;)e += t[i] * t[i]; return Math.sqrt(e) }); var lo, uo = so; function ho(t, e, i) { var r = e[0], n = e[1], a = e[2], o = e[3]; return t[0] = i[0] * r + i[4] * n + i[8] * a + i[12] * o, t[1] = i[1] * r + i[5] * n + i[9] * a + i[13] * o, t[2] = i[2] * r + i[6] * n + i[10] * a + i[14] * o, t[3] = i[3] * r + i[7] * n + i[11] * a + i[15] * o, t } lo = new ao(3), ao != Float32Array && (lo[0] = 0, lo[1] = 0, lo[2] = 0), function () { var t = new ao(4); ao != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0) }(); var co = (function () { var t = new ao(2); ao != Float32Array && (t[0] = 0, t[1] = 0) }(), function (t) { function e(e) { t.call(this, e, no) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new ja(t) }, e.prototype.queryRadius = function (t) { var e = t; return to("circle-radius", this, e) + to("circle-stroke-width", this, e) + eo(this.paint.get("circle-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, i, r, n, a, o, s) { for (var l = io(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, o), u = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i), h = "map" === this.paint.get("circle-pitch-alignment"), c = h ? l : function (t, e) { return t.map((function (t) { return po(t, e) })) }(l, s), p = h ? u * o : u, f = 0, d = r; f < d.length; f += 1)for (var m = 0, y = d[f]; m < y.length; m += 1) { var g = y[m], _ = h ? g : po(g, s), v = p, x = ho([], [g.x, g.y, 0, 1], s); if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? v *= x[3] / a.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (v *= a.cameraToCenterDistance / x[3]), Ga(c, _, v)) return !0 } return !1 }, e }(wn)); function po(t, e) { var i = ho([], [t.x, t.y, 0, 1], e); return new n(i[0] / i[3], i[1] / i[3]) } var fo = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(ja); function mo(t, e, i, r) { var n = e.width, a = e.height; if (r) { if (r instanceof Uint8ClampedArray) r = new Uint8Array(r.buffer); else if (r.length !== n * a * i) throw new RangeError("mismatched image size") } else r = new Uint8Array(n * a * i); return t.width = n, t.height = a, t.data = r, t } function yo(t, e, i) { var r = e.width, n = e.height; if (r !== t.width || n !== t.height) { var a = mo({}, { width: r, height: n }, i); go(t, a, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, r), height: Math.min(t.height, n) }, i), t.width = r, t.height = n, t.data = a.data } } function go(t, e, i, r, n, a) { if (0 === n.width || 0 === n.height) return e; if (n.width > t.width || n.height > t.height || i.x > t.width - n.width || i.y > t.height - n.height) throw new RangeError("out of range source coordinates for image copy"); if (n.width > e.width || n.height > e.height || r.x > e.width - n.width || r.y > e.height - n.height) throw new RangeError("out of range destination coordinates for image copy"); for (var o = t.data, s = e.data, l = 0; l < n.height; l++)for (var u = ((i.y + l) * t.width + i.x) * a, h = ((r.y + l) * e.width + r.x) * a, c = 0; c < n.width * a; c++)s[h + c] = o[u + c]; return e } Or("HeatmapBucket", fo, { omit: ["layers"] }); var _o = function (t, e) { mo(this, t, 1, e) }; _o.prototype.resize = function (t) { yo(this, t, 1) }, _o.prototype.clone = function () { return new _o({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, _o.copy = function (t, e, i, r, n) { go(t, e, i, r, n, 1) }; var vo = function (t, e) { mo(this, t, 4, e) }; vo.prototype.resize = function (t) { yo(this, t, 4) }, vo.prototype.replace = function (t, e) { e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t }, vo.prototype.clone = function () { return new vo({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, vo.copy = function (t, e, i, r, n) { go(t, e, i, r, n, 4) }, Or("AlphaImage", _o), Or("RGBAImage", vo); var xo = { paint: new bn({ "heatmap-radius": new gn(Pt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new gn(Pt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new yn(Pt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new xn(Pt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new yn(Pt.paint_heatmap["heatmap-opacity"]) }) }; function bo(t) { var e = {}, i = t.resolution || 256, r = t.clips ? t.clips.length : 1, n = t.image || new vo({ width: i, height: r }), a = function (i, r, a) { e[t.evaluationKey] = a; var o = t.expression.evaluate(e); n.data[i + r + 0] = Math.floor(255 * o.r / o.a), n.data[i + r + 1] = Math.floor(255 * o.g / o.a), n.data[i + r + 2] = Math.floor(255 * o.b / o.a), n.data[i + r + 3] = Math.floor(255 * o.a) }; if (t.clips) for (var o = 0, s = 0; o < r; ++o, s += 4 * i)for (var l = 0, u = 0; l < i; l++, u += 4) { var h = l / (i - 1), c = t.clips[o]; a(s, u, c.start * (1 - h) + c.end * h) } else for (var p = 0, f = 0; p < i; p++, f += 4)a(0, f, p / (i - 1)); return n } var wo = function (t) { function e(e) { t.call(this, e, xo), this._updateColorRamp() } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new fo(t) }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { "heatmap-color" === t && this._updateColorRamp() }, e.prototype._updateColorRamp = function () { this.colorRamp = bo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null }, e.prototype.resize = function () { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null) }, e.prototype.queryRadius = function () { return 0 }, e.prototype.queryIntersectsFeature = function () { return !1 }, e.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility }, e }(wn), Mo = { paint: new bn({ "hillshade-illumination-direction": new yn(Pt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new yn(Pt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new yn(Pt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new yn(Pt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new yn(Pt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new yn(Pt.paint_hillshade["hillshade-accent-color"]) }) }, So = function (t) { function e(e) { t.call(this, e, Mo) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility }, e }(wn), Eo = In([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Io = Ao, To = Ao; function Ao(t, e, i) { i = i || 2; var r, n, a, o, s, l, u, h = e && e.length, c = h ? e[0] * i : t.length, p = Po(t, 0, c, i, !0), f = []; if (!p || p.next === p.prev) return f; if (h && (p = function (t, e, i, r) { var n, a, o, s = []; for (n = 0, a = e.length; n < a; n++)(o = Po(t, e[n] * r, n < a - 1 ? e[n + 1] * r : t.length, r, !1)) === o.next && (o.steiner = !0), s.push(No(o)); for (s.sort(Bo), n = 0; n < s.length; n++)Oo(s[n], i), i = Co(i, i.next); return i }(t, e, p, i)), t.length > 80 * i) { r = a = t[0], n = o = t[1]; for (var d = i; d < c; d += i)(s = t[d]) < r && (r = s), (l = t[d + 1]) < n && (n = l), s > a && (a = s), l > o && (o = l); u = 0 !== (u = Math.max(a - r, o - n)) ? 1 / u : 0 } return zo(p, f, i, r, n, u), f } function Po(t, e, i, r, n) { var a, o; if (n === Qo(t, e, i, r) > 0) for (a = e; a < i; a += r)o = $o(a, t[a], t[a + 1], o); else for (a = i - r; a >= e; a -= r)o = $o(a, t[a], t[a + 1], o); return o && Go(o, o.next) && (Jo(o), o = o.next), o } function Co(t, e) { if (!t) return t; e || (e = t); var i, r = t; do { if (i = !1, r.steiner || !Go(r, r.next) && 0 !== qo(r.prev, r, r.next)) r = r.next; else { if (Jo(r), (r = e = r.prev) === r.next) break; i = !0 } } while (i || r !== e); return e } function zo(t, e, i, r, n, a, o) { if (t) { !o && a && function (t, e, i, r) { var n = t; do { null === n.z && (n.z = Uo(n.x, n.y, e, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t); n.prevZ.nextZ = null, n.prevZ = null, function (t) { var e, i, r, n, a, o, s, l, u = 1; do { for (i = t, t = null, a = null, o = 0; i;) { for (o++, r = i, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++); for (l = u; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || i.z <= r.z) ? (n = i, i = i.nextZ, s--) : (n = r, r = r.nextZ, l--), a ? a.nextZ = n : t = n, n.prevZ = a, a = n; i = r } a.nextZ = null, u *= 2 } while (o > 1) }(n) }(t, r, n, a); for (var s, l, u = t; t.prev !== t.next;)if (s = t.prev, l = t.next, a ? Lo(t, r, n, a) : ko(t)) e.push(s.i / i), e.push(t.i / i), e.push(l.i / i), Jo(t), t = l.next, u = l.next; else if ((t = l) === u) { o ? 1 === o ? zo(t = Do(Co(t), e, i), e, i, r, n, a, 2) : 2 === o && Ro(t, e, i, r, n, a) : zo(Co(t), e, i, r, n, a, 1); break } } } function ko(t) { var e = t.prev, i = t, r = t.next; if (qo(e, i, r) >= 0) return !1; for (var n = t.next.next; n !== t.prev;) { if (Vo(e.x, e.y, i.x, i.y, r.x, r.y, n.x, n.y) && qo(n.prev, n, n.next) >= 0) return !1; n = n.next } return !0 } function Lo(t, e, i, r) { var n = t.prev, a = t, o = t.next; if (qo(n, a, o) >= 0) return !1; for (var s = n.x > a.x ? n.x > o.x ? n.x : o.x : a.x > o.x ? a.x : o.x, l = n.y > a.y ? n.y > o.y ? n.y : o.y : a.y > o.y ? a.y : o.y, u = Uo(n.x < a.x ? n.x < o.x ? n.x : o.x : a.x < o.x ? a.x : o.x, n.y < a.y ? n.y < o.y ? n.y : o.y : a.y < o.y ? a.y : o.y, e, i, r), h = Uo(s, l, e, i, r), c = t.prevZ, p = t.nextZ; c && c.z >= u && p && p.z <= h;) { if (c !== t.prev && c !== t.next && Vo(n.x, n.y, a.x, a.y, o.x, o.y, c.x, c.y) && qo(c.prev, c, c.next) >= 0) return !1; if (c = c.prevZ, p !== t.prev && p !== t.next && Vo(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && qo(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } for (; c && c.z >= u;) { if (c !== t.prev && c !== t.next && Vo(n.x, n.y, a.x, a.y, o.x, o.y, c.x, c.y) && qo(c.prev, c, c.next) >= 0) return !1; c = c.prevZ } for (; p && p.z <= h;) { if (p !== t.prev && p !== t.next && Vo(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && qo(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } return !0 } function Do(t, e, i) { var r = t; do { var n = r.prev, a = r.next.next; !Go(n, a) && Zo(n, r, r.next, a) && Ko(n, a) && Ko(a, n) && (e.push(n.i / i), e.push(r.i / i), e.push(a.i / i), Jo(r), Jo(r.next), r = t = a), r = r.next } while (r !== t); return Co(r) } function Ro(t, e, i, r, n, a) { var o = t; do { for (var s = o.next.next; s !== o.prev;) { if (o.i !== s.i && jo(o, s)) { var l = Ho(o, s); return o = Co(o, o.next), l = Co(l, l.next), zo(o, e, i, r, n, a), void zo(l, e, i, r, n, a) } s = s.next } o = o.next } while (o !== t) } function Bo(t, e) { return t.x - e.x } function Oo(t, e) { if (e = function (t, e) { var i, r = e, n = t.x, a = t.y, o = -1 / 0; do { if (a <= r.y && a >= r.next.y && r.next.y !== r.y) { var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= n && s > o) { if (o = s, s === n) { if (a === r.y) return r; if (a === r.next.y) return r.next } i = r.x < r.next.x ? r : r.next } } r = r.next } while (r !== e); if (!i) return null; if (n === o) return i; var l, u = i, h = i.x, c = i.y, p = 1 / 0; r = i; do { n >= r.x && r.x >= h && n !== r.x && Vo(a < c ? n : o, a, h, c, a < c ? o : n, a, r.x, r.y) && (l = Math.abs(a - r.y) / (n - r.x), Ko(r, t) && (l < p || l === p && (r.x > i.x || r.x === i.x && Fo(i, r))) && (i = r, p = l)), r = r.next } while (r !== u); return i }(t, e)) { var i = Ho(e, t); Co(e, e.next), Co(i, i.next) } } function Fo(t, e) { return qo(t.prev, t, e.prev) < 0 && qo(e.next, t, t.next) < 0 } function Uo(t, e, i, r, n) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function No(t) { var e = t, i = t; do { (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next } while (e !== t); return i } function Vo(t, e, i, r, n, a, o, s) { return (n - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (r - s) - (i - o) * (e - s) >= 0 && (i - o) * (a - s) - (n - o) * (r - s) >= 0 } function jo(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Zo(i, i.next, t, e)) return !0; i = i.next } while (i !== t); return !1 }(t, e) && (Ko(t, e) && Ko(e, t) && function (t, e) { var i = t, r = !1, n = (t.x + e.x) / 2, a = (t.y + e.y) / 2; do { i.y > a != i.next.y > a && i.next.y !== i.y && n < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next } while (i !== t); return r }(t, e) && (qo(t.prev, t, e.prev) || qo(t, e.prev, e)) || Go(t, e) && qo(t.prev, t, t.next) > 0 && qo(e.prev, e, e.next) > 0) } function qo(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) } function Go(t, e) { return t.x === e.x && t.y === e.y } function Zo(t, e, i, r) { var n = Wo(qo(t, e, i)), a = Wo(qo(t, e, r)), o = Wo(qo(i, r, t)), s = Wo(qo(i, r, e)); return n !== a && o !== s || !(0 !== n || !Xo(t, i, e)) || !(0 !== a || !Xo(t, r, e)) || !(0 !== o || !Xo(i, t, r)) || !(0 !== s || !Xo(i, e, r)) } function Xo(t, e, i) { return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y) } function Wo(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Ko(t, e) { return qo(t.prev, t, t.next) < 0 ? qo(t, e, t.next) >= 0 && qo(t, t.prev, e) >= 0 : qo(t, e, t.prev) < 0 || qo(t, t.next, e) < 0 } function Ho(t, e) { var i = new Yo(t.i, t.x, t.y), r = new Yo(e.i, e.x, e.y), n = t.next, a = e.prev; return t.next = e, e.prev = t, i.next = n, n.prev = i, r.next = i, i.prev = r, a.next = r, r.prev = a, r } function $o(t, e, i, r) { var n = new Yo(t, e, i); return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n } function Jo(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Yo(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function Qo(t, e, i, r) { for (var n = 0, a = e, o = i - r; a < i; a += r)n += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a; return n } function ts(t, e, i, r, n) { !function t(e, i, r, n, a) { for (; n > r;) { if (n - r > 600) { var o = n - r + 1, s = i - r + 1, l = Math.log(o), u = .5 * Math.exp(2 * l / 3), h = .5 * Math.sqrt(l * u * (o - u) / o) * (s - o / 2 < 0 ? -1 : 1); t(e, i, Math.max(r, Math.floor(i - s * u / o + h)), Math.min(n, Math.floor(i + (o - s) * u / o + h)), a) } var c = e[i], p = r, f = n; for (es(e, r, i), a(e[n], c) > 0 && es(e, r, n); p < f;) { for (es(e, p, f), p++, f--; a(e[p], c) < 0;)p++; for (; a(e[f], c) > 0;)f-- } 0 === a(e[r], c) ? es(e, r, f) : es(e, ++f, n), f <= i && (r = f + 1), i <= f && (n = f - 1) } }(t, e, i || 0, r || t.length - 1, n || is) } function es(t, e, i) { var r = t[e]; t[e] = t[i], t[i] = r } function is(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function rs(t, e) { var i = t.length; if (i <= 1) return [t]; for (var r, n, a = [], o = 0; o < i; o++) { var s = E(t[o]); 0 !== s && (t[o].area = Math.abs(s), void 0 === n && (n = s < 0), n === s < 0 ? (r && a.push(r), r = [t[o]]) : r.push(t[o])) } if (r && a.push(r), e > 1) for (var l = 0; l < a.length; l++)a[l].length <= e || (ts(a[l], e, 1, a[l].length - 1, ns), a[l] = a[l].slice(0, e)); return a } function ns(t, e) { return e.area - t.area } function as(t, e, i) { for (var r = i.patternDependencies, n = !1, a = 0, o = e; a < o.length; a += 1) { var s = o[a].paint.get(t + "-pattern"); s.isConstant() || (n = !0); var l = s.constantOr(null); l && (n = !0, r[l.to] = !0, r[l.from] = !0) } return n } function os(t, e, i, r, n) { for (var a = n.patternDependencies, o = 0, s = e; o < s.length; o += 1) { var l = s[o], u = l.paint.get(t + "-pattern").value; if ("constant" !== u.kind) { var h = u.evaluate({ zoom: r - 1 }, i, {}, n.availableImages), c = u.evaluate({ zoom: r }, i, {}, n.availableImages), p = u.evaluate({ zoom: r + 1 }, i, {}, n.availableImages); c = c && c.name ? c.name : c, p = p && p.name ? p.name : p, a[h = h && h.name ? h.name : h] = !0, a[c] = !0, a[p] = !0, i.patterns[l.id] = { min: h, mid: c, max: p } } } return i } Ao.deviation = function (t, e, i, r) { var n = e && e.length, a = Math.abs(Qo(t, 0, n ? e[0] * i : t.length, i)); if (n) for (var o = 0, s = e.length; o < s; o++)a -= Math.abs(Qo(t, e[o] * i, o < s - 1 ? e[o + 1] * i : t.length, i)); var l = 0; for (o = 0; o < r.length; o += 3) { var u = r[o] * i, h = r[o + 1] * i, c = r[o + 2] * i; l += Math.abs((t[u] - t[c]) * (t[h + 1] - t[u + 1]) - (t[u] - t[h]) * (t[c + 1] - t[u + 1])) } return 0 === a && 0 === l ? 0 : Math.abs((l - a) / a) }, Ao.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, r = 0, n = 0; n < t.length; n++) { for (var a = 0; a < t[n].length; a++)for (var o = 0; o < e; o++)i.vertices.push(t[n][a][o]); n > 0 && i.holes.push(r += t[n - 1].length) } return i }, Io.default = To; var ss = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new An, this.indexArray = new Vn, this.indexArray2 = new Wn, this.programConfigurations = new Da(t.layers, t.zoom), this.segments = new sa, this.segments2 = new sa, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; ss.prototype.populate = function (t, e, i) { this.hasPattern = as("fill", this.layers, e); for (var r = this.layers[0].layout.get("fill-sort-key"), n = [], a = 0, o = t; a < o.length; a += 1) { var s = o[a], l = s.feature, u = s.id, h = s.index, c = s.sourceLayerIndex, p = this.layers[0]._featureFilter.needGeometry, f = Na(l, p); if (this.layers[0]._featureFilter.filter(new sn(this.zoom), f, i)) { var d = r ? r.evaluate(f, {}, i, e.availableImages) : void 0, m = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: c, index: h, geometry: p ? f.geometry : Ua(l), patterns: {}, sortKey: d }; n.push(m) } } r && n.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var y = 0, g = n; y < g.length; y += 1) { var _ = g[y], v = _.geometry, x = _.index, b = _.sourceLayerIndex; if (this.hasPattern) { var w = os("fill", this.layers, _, this.zoom, e); this.patternFeatures.push(w) } else this.addFeature(_, v, x, i, {}); e.featureIndex.insert(t[x].feature, v, x, b, this.index) } }, ss.prototype.update = function (t, e, i) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i) }, ss.prototype.addFeatures = function (t, e, i) { for (var r = 0, n = this.patternFeatures; r < n.length; r += 1) { var a = n[r]; this.addFeature(a, a.geometry, a.index, e, i) } }, ss.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, ss.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, ss.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Eo), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0 }, ss.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) }, ss.prototype.addFeature = function (t, e, i, r, n) { for (var a = 0, o = rs(e, 500); a < o.length; a += 1) { for (var s = o[a], l = 0, u = 0, h = s; u < h.length; u += 1)l += h[u].length; for (var c = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray), p = c.vertexLength, f = [], d = [], m = 0, y = s; m < y.length; m += 1) { var g = y[m]; if (0 !== g.length) { g !== s[0] && d.push(f.length / 2); var _ = this.segments2.prepareSegment(g.length, this.layoutVertexArray, this.indexArray2), v = _.vertexLength; this.layoutVertexArray.emplaceBack(g[0].x, g[0].y), this.indexArray2.emplaceBack(v + g.length - 1, v), f.push(g[0].x), f.push(g[0].y); for (var x = 1; x < g.length; x++)this.layoutVertexArray.emplaceBack(g[x].x, g[x].y), this.indexArray2.emplaceBack(v + x - 1, v + x), f.push(g[x].x), f.push(g[x].y); _.vertexLength += g.length, _.primitiveLength += g.length } } for (var b = Io(f, d), w = 0; w < b.length; w += 3)this.indexArray.emplaceBack(p + b[w], p + b[w + 1], p + b[w + 2]); c.vertexLength += l, c.primitiveLength += b.length / 3 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, r) }, Or("FillBucket", ss, { omit: ["layers", "patternFeatures"] }); var ls = new bn({ "fill-sort-key": new gn(Pt.layout_fill["fill-sort-key"]) }), us = { paint: new bn({ "fill-antialias": new yn(Pt.paint_fill["fill-antialias"]), "fill-opacity": new gn(Pt.paint_fill["fill-opacity"]), "fill-color": new gn(Pt.paint_fill["fill-color"]), "fill-outline-color": new gn(Pt.paint_fill["fill-outline-color"]), "fill-translate": new yn(Pt.paint_fill["fill-translate"]), "fill-translate-anchor": new yn(Pt.paint_fill["fill-translate-anchor"]), "fill-pattern": new _n(Pt.paint_fill["fill-pattern"]) }), layout: ls }, hs = function (t) { function e(e) { t.call(this, e, us) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, i) { t.prototype.recalculate.call(this, e, i); var r = this.paint._values["fill-outline-color"]; "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) }, e.prototype.createBucket = function (t) { return new ss(t) }, e.prototype.queryRadius = function () { return eo(this.paint.get("fill-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, i, r, n, a, o) { return Za(io(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, o), r) }, e.prototype.isTileClipped = function () { return !0 }, e }(wn), cs = In([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, ps = fs; function fs(t, e, i, r, n) { this.properties = {}, this.extent = i, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = r, this._values = n, t.readFields(ds, this, e) } function ds(t, e, i) { 1 == t ? e.id = i.readVarint() : 2 == t ? function (t, e) { for (var i = t.readVarint() + t.pos; t.pos < i;) { var r = e._keys[t.readVarint()], n = e._values[t.readVarint()]; e.properties[r] = n } }(i, e) : 3 == t ? e.type = i.readVarint() : 4 == t && (e._geometry = i.pos) } function ms(t) { for (var e, i, r = 0, n = 0, a = t.length, o = a - 1; n < a; o = n++)r += ((i = t[o]).x - (e = t[n]).x) * (e.y + i.y); return r } fs.types = ["Unknown", "Point", "LineString", "Polygon"], fs.prototype.loadGeometry = function () { var t = this._pbf; t.pos = this._geometry; for (var e, i = t.readVarint() + t.pos, r = 1, a = 0, o = 0, s = 0, l = []; t.pos < i;) { if (a <= 0) { var u = t.readVarint(); r = 7 & u, a = u >> 3 } if (a--, 1 === r || 2 === r) o += t.readSVarint(), s += t.readSVarint(), 1 === r && (e && l.push(e), e = []), e.push(new n(o, s)); else { if (7 !== r) throw new Error("unknown command " + r); e && e.push(e[0].clone()) } } return e && l.push(e), l }, fs.prototype.bbox = function () { var t = this._pbf; t.pos = this._geometry; for (var e = t.readVarint() + t.pos, i = 1, r = 0, n = 0, a = 0, o = 1 / 0, s = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) { if (r <= 0) { var h = t.readVarint(); i = 7 & h, r = h >> 3 } if (r--, 1 === i || 2 === i) (n += t.readSVarint()) < o && (o = n), n > s && (s = n), (a += t.readSVarint()) < l && (l = a), a > u && (u = a); else if (7 !== i) throw new Error("unknown command " + i) } return [o, l, s, u] }, fs.prototype.toGeoJSON = function (t, e, i) { var r, n, a = this.extent * Math.pow(2, i), o = this.extent * t, s = this.extent * e, l = this.loadGeometry(), u = fs.types[this.type]; function h(t) { for (var e = 0; e < t.length; e++) { var i = t[e]; t[e] = [360 * (i.x + o) / a - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (i.y + s) / a) * Math.PI / 180)) - 90] } } switch (this.type) { case 1: var c = []; for (r = 0; r < l.length; r++)c[r] = l[r][0]; h(l = c); break; case 2: for (r = 0; r < l.length; r++)h(l[r]); break; case 3: for (l = function (t) { var e = t.length; if (e <= 1) return [t]; for (var i, r, n = [], a = 0; a < e; a++) { var o = ms(t[a]); 0 !== o && (void 0 === r && (r = o < 0), r === o < 0 ? (i && n.push(i), i = [t[a]]) : i.push(t[a])) } return i && n.push(i), n }(l), r = 0; r < l.length; r++)for (n = 0; n < l[r].length; n++)h(l[r][n]) }1 === l.length ? l = l[0] : u = "Multi" + u; var p = { type: "Feature", geometry: { type: u, coordinates: l }, properties: this.properties }; return "id" in this && (p.id = this.id), p }; var ys = gs; function gs(t, e) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(_s, this, e), this.length = this._features.length } function _s(t, e, i) { 15 === t ? e.version = i.readVarint() : 1 === t ? e.name = i.readString() : 5 === t ? e.extent = i.readVarint() : 2 === t ? e._features.push(i.pos) : 3 === t ? e._keys.push(i.readString()) : 4 === t && e._values.push(function (t) { for (var e = null, i = t.readVarint() + t.pos; t.pos < i;) { var r = t.readVarint() >> 3; e = 1 === r ? t.readString() : 2 === r ? t.readFloat() : 3 === r ? t.readDouble() : 4 === r ? t.readVarint64() : 5 === r ? t.readVarint() : 6 === r ? t.readSVarint() : 7 === r ? t.readBoolean() : null } return e }(i)) } function vs(t, e, i) { if (3 === t) { var r = new ys(i, i.readVarint() + i.pos); r.length && (e[r.name] = r) } } gs.prototype.feature = function (t) { if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[t]; var e = this._pbf.readVarint() + this._pbf.pos; return new ps(this._pbf, e, this.extent, this._keys, this._values) }; var xs = { VectorTile: function (t, e) { this.layers = t.readFields(vs, {}, e) }, VectorTileFeature: ps, VectorTileLayer: ys }, bs = xs.VectorTileFeature.types, ws = Math.pow(2, 13); function Ms(t, e, i, r, n, a, o, s) { t.emplaceBack(e, i, 2 * Math.floor(r * ws) + o, n * ws * 2, a * ws * 2, Math.round(s)) } var Ss = function (t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Cn, this.indexArray = new Vn, this.programConfigurations = new Da(t.layers, t.zoom), this.segments = new sa, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; function Es(t, e) { return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192) } Ss.prototype.populate = function (t, e, i) { this.features = [], this.hasPattern = as("fill-extrusion", this.layers, e); for (var r = 0, n = t; r < n.length; r += 1) { var a = n[r], o = a.feature, s = a.id, l = a.index, u = a.sourceLayerIndex, h = this.layers[0]._featureFilter.needGeometry, c = Na(o, h); if (this.layers[0]._featureFilter.filter(new sn(this.zoom), c, i)) { var p = { id: s, sourceLayerIndex: u, index: l, geometry: h ? c.geometry : Ua(o), properties: o.properties, type: o.type, patterns: {} }; this.hasPattern ? this.features.push(os("fill-extrusion", this.layers, p, this.zoom, e)) : this.addFeature(p, p.geometry, l, i, {}), e.featureIndex.insert(o, p.geometry, l, u, this.index, !0) } } }, Ss.prototype.addFeatures = function (t, e, i) { for (var r = 0, n = this.features; r < n.length; r += 1) { var a = n[r]; this.addFeature(a, a.geometry, a.index, e, i) } }, Ss.prototype.update = function (t, e, i) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i) }, Ss.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Ss.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Ss.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Ss.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Ss.prototype.addFeature = function (t, e, i, r, n) { for (var a = 0, o = rs(e, 500); a < o.length; a += 1) { for (var s = o[a], l = 0, u = 0, h = s; u < h.length; u += 1)l += h[u].length; for (var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), p = 0, f = s; p < f.length; p += 1) { var d = f[p]; if (0 !== d.length && !((k = d).every((function (t) { return t.x < 0 })) || k.every((function (t) { return t.x > 8192 })) || k.every((function (t) { return t.y < 0 })) || k.every((function (t) { return t.y > 8192 })))) for (var m = 0, y = 0; y < d.length; y++) { var g = d[y]; if (y >= 1) { var _ = d[y - 1]; if (!Es(g, _)) { c.vertexLength + 4 > sa.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); var v = g.sub(_)._perp()._unit(), x = _.dist(g); m + x > 32768 && (m = 0), Ms(this.layoutVertexArray, g.x, g.y, v.x, v.y, 0, 0, m), Ms(this.layoutVertexArray, g.x, g.y, v.x, v.y, 0, 1, m), Ms(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 0, m += x), Ms(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 1, m); var b = c.vertexLength; this.indexArray.emplaceBack(b, b + 2, b + 1), this.indexArray.emplaceBack(b + 1, b + 2, b + 3), c.vertexLength += 4, c.primitiveLength += 2 } } } } if (c.vertexLength + l > sa.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray)), "Polygon" === bs[t.type]) { for (var w = [], M = [], S = c.vertexLength, E = 0, I = s; E < I.length; E += 1) { var T = I[E]; if (0 !== T.length) { T !== s[0] && M.push(w.length / 2); for (var A = 0; A < T.length; A++) { var P = T[A]; Ms(this.layoutVertexArray, P.x, P.y, 0, 0, 1, 1, 0), w.push(P.x), w.push(P.y) } } } for (var C = Io(w, M), z = 0; z < C.length; z += 3)this.indexArray.emplaceBack(S + C[z], S + C[z + 2], S + C[z + 1]); c.primitiveLength += C.length / 3, c.vertexLength += l } } var k; this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, r) }, Or("FillExtrusionBucket", Ss, { omit: ["layers", "features"] }); var Is = { paint: new bn({ "fill-extrusion-opacity": new yn(Pt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new gn(Pt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new yn(Pt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new yn(Pt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new _n(Pt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new gn(Pt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new gn(Pt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new yn(Pt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, Ts = function (t) { function e(e) { t.call(this, e, Is) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) { return new Ss(t) }, e.prototype.queryRadius = function () { return eo(this.paint.get("fill-extrusion-translate")) }, e.prototype.is3D = function () { return !0 }, e.prototype.queryIntersectsFeature = function (t, e, i, r, a, o, s, l) { var u = io(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, s), h = this.paint.get("fill-extrusion-height").evaluate(e, i), c = this.paint.get("fill-extrusion-base").evaluate(e, i), p = function (t, e, i, r) { for (var a = [], o = 0, s = t; o < s.length; o += 1) { var l = s[o], u = [l.x, l.y, 0, 1]; ho(u, u, e), a.push(new n(u[0] / u[3], u[1] / u[3])) } return a }(u, l), f = function (t, e, i, r) { for (var a = [], o = [], s = r[8] * e, l = r[9] * e, u = r[10] * e, h = r[11] * e, c = r[8] * i, p = r[9] * i, f = r[10] * i, d = r[11] * i, m = 0, y = t; m < y.length; m += 1) { for (var g = [], _ = [], v = 0, x = y[m]; v < x.length; v += 1) { var b = x[v], w = b.x, M = b.y, S = r[0] * w + r[4] * M + r[12], E = r[1] * w + r[5] * M + r[13], I = r[2] * w + r[6] * M + r[14], T = r[3] * w + r[7] * M + r[15], A = I + u, P = T + h, C = S + c, z = E + p, k = I + f, L = T + d, D = new n((S + s) / P, (E + l) / P); D.z = A / P, g.push(D); var R = new n(C / L, z / L); R.z = k / L, _.push(R) } a.push(g), o.push(_) } return [a, o] }(r, c, h, l); return function (t, e, i) { var r = 1 / 0; Za(i, e) && (r = Ps(i, e[0])); for (var n = 0; n < e.length; n++)for (var a = e[n], o = t[n], s = 0; s < a.length - 1; s++) { var l = a[s], u = [l, a[s + 1], o[s + 1], o[s], l]; qa(i, u) && (r = Math.min(r, Ps(i, u))) } return r !== 1 / 0 && r }(f[0], f[1], p) }, e }(wn); function As(t, e) { return t.x * e.x + t.y * e.y } function Ps(t, e) { if (1 === t.length) { for (var i, r = 0, n = e[r++]; !i || n.equals(i);)if (!(i = e[r++])) return 1 / 0; for (; r < e.length; r++) { var a = e[r], o = t[0], s = i.sub(n), l = a.sub(n), u = o.sub(n), h = As(s, s), c = As(s, l), p = As(l, l), f = As(u, s), d = As(u, l), m = h * p - c * c, y = (p * f - c * d) / m, g = (h * d - c * f) / m, _ = n.z * (1 - y - g) + i.z * y + a.z * g; if (isFinite(_)) return _ } return 1 / 0 } for (var v = 1 / 0, x = 0, b = e; x < b.length; x += 1)v = Math.min(v, b[x].z); return v } var Cs = In([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, zs = In([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, ks = xs.VectorTileFeature.types, Ls = Math.cos(Math.PI / 180 * 37.5), Ds = Math.pow(2, 14) / .5, Rs = function (t) { var e = this; this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((function (t) { e.gradients[t.id] = {} })), this.layoutVertexArray = new zn, this.layoutVertexArray2 = new kn, this.indexArray = new Vn, this.programConfigurations = new Da(t.layers, t.zoom), this.segments = new sa, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })) }; Rs.prototype.populate = function (t, e, i) { this.hasPattern = as("line", this.layers, e); for (var r = this.layers[0].layout.get("line-sort-key"), n = [], a = 0, o = t; a < o.length; a += 1) { var s = o[a], l = s.feature, u = s.id, h = s.index, c = s.sourceLayerIndex, p = this.layers[0]._featureFilter.needGeometry, f = Na(l, p); if (this.layers[0]._featureFilter.filter(new sn(this.zoom), f, i)) { var d = r ? r.evaluate(f, {}, i) : void 0, m = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: c, index: h, geometry: p ? f.geometry : Ua(l), patterns: {}, sortKey: d }; n.push(m) } } r && n.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var y = 0, g = n; y < g.length; y += 1) { var _ = g[y], v = _.geometry, x = _.index, b = _.sourceLayerIndex; if (this.hasPattern) { var w = os("line", this.layers, _, this.zoom, e); this.patternFeatures.push(w) } else this.addFeature(_, v, x, i, {}); e.featureIndex.insert(t[x].feature, v, x, b, this.index) } }, Rs.prototype.update = function (t, e, i) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i) }, Rs.prototype.addFeatures = function (t, e, i) { for (var r = 0, n = this.patternFeatures; r < n.length; r += 1) { var a = n[r]; this.addFeature(a, a.geometry, a.index, e, i) } }, Rs.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Rs.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Rs.prototype.upload = function (t) { this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, zs)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Cs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Rs.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Rs.prototype.lineFeatureClips = function (t) { if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end } }, Rs.prototype.addFeature = function (t, e, i, r, n) { var a = this.layers[0].layout, o = a.get("line-join").evaluate(t, {}), s = a.get("line-cap"), l = a.get("line-miter-limit"), u = a.get("line-round-limit"); this.lineClips = this.lineFeatureClips(t); for (var h = 0, c = e; h < c.length; h += 1)this.addLine(c[h], t, o, s, l, u); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, n, r) }, Rs.prototype.addLine = function (t, e, i, r, n, a) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) { this.lineClipsArray.push(this.lineClips); for (var o = 0; o < t.length - 1; o++)this.totalDistance += t[o].dist(t[o + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance) } for (var s = "Polygon" === ks[e.type], l = t.length; l >= 2 && t[l - 1].equals(t[l - 2]);)l--; for (var u = 0; u < l - 1 && t[u].equals(t[u + 1]);)u++; if (!(l < (s ? 3 : 2))) { "bevel" === i && (n = 1.05); var h, c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p = this.segments.prepareSegment(10 * l, this.layoutVertexArray, this.indexArray), f = void 0, d = void 0, m = void 0, y = void 0; this.e1 = this.e2 = -1, s && (y = t[u].sub(h = t[l - 2])._unit()._perp()); for (var g = u; g < l; g++)if (!(d = g === l - 1 ? s ? t[u + 1] : void 0 : t[g + 1]) || !t[g].equals(d)) { y && (m = y), h && (f = h), h = t[g], y = d ? d.sub(h)._unit()._perp() : m; var _ = (m = m || y).add(y); 0 === _.x && 0 === _.y || _._unit(); var v = m.x * y.x + m.y * y.y, x = _.x * y.x + _.y * y.y, b = 0 !== x ? 1 / x : 1 / 0, w = 2 * Math.sqrt(2 - 2 * x), M = x < Ls && f && d, S = m.x * y.y - m.y * y.x > 0; if (M && g > u) { var E = h.dist(f); if (E > 2 * c) { var I = h.sub(h.sub(f)._mult(c / E)._round()); this.updateDistance(f, I), this.addCurrentVertex(I, m, 0, 0, p), f = I } } var T = f && d, A = T ? i : s ? "butt" : r; if (T && "round" === A && (b < a ? A = "miter" : b <= 2 && (A = "fakeround")), "miter" === A && b > n && (A = "bevel"), "bevel" === A && (b > 2 && (A = "flipbevel"), b < n && (A = "miter")), f && this.updateDistance(f, h), "miter" === A) _._mult(b), this.addCurrentVertex(h, _, 0, 0, p); else if ("flipbevel" === A) { if (b > 100) _ = y.mult(-1); else { var P = b * m.add(y).mag() / m.sub(y).mag(); _._perp()._mult(P * (S ? -1 : 1)) } this.addCurrentVertex(h, _, 0, 0, p), this.addCurrentVertex(h, _.mult(-1), 0, 0, p) } else if ("bevel" === A || "fakeround" === A) { var C = -Math.sqrt(b * b - 1), z = S ? C : 0, k = S ? 0 : C; if (f && this.addCurrentVertex(h, m, z, k, p), "fakeround" === A) for (var L = Math.round(180 * w / Math.PI / 20), D = 1; D < L; D++) { var R = D / L; if (.5 !== R) { var B = R - .5; R += R * B * (R - 1) * ((1.0904 + v * (v * (3.55645 - 1.43519 * v) - 3.2452)) * B * B + (.848013 + v * (.215638 * v - 1.06021))) } var O = y.sub(m)._mult(R)._add(m)._unit()._mult(S ? -1 : 1); this.addHalfVertex(h, O.x, O.y, !1, S, 0, p) } d && this.addCurrentVertex(h, y, -z, -k, p) } else if ("butt" === A) this.addCurrentVertex(h, _, 0, 0, p); else if ("square" === A) { var F = f ? 1 : -1; this.addCurrentVertex(h, _, F, F, p) } else "round" === A && (f && (this.addCurrentVertex(h, m, 0, 0, p), this.addCurrentVertex(h, m, 1, 1, p, !0)), d && (this.addCurrentVertex(h, y, -1, -1, p, !0), this.addCurrentVertex(h, y, 0, 0, p))); if (M && g < l - 1) { var U = h.dist(d); if (U > 2 * c) { var N = h.add(d.sub(h)._mult(c / U)._round()); this.updateDistance(h, N), this.addCurrentVertex(N, y, 0, 0, p), h = N } } } } }, Rs.prototype.addCurrentVertex = function (t, e, i, r, n, a) { void 0 === a && (a = !1); var o = e.y * r - e.x, s = -e.y - e.x * r; this.addHalfVertex(t, e.x + e.y * i, e.y - e.x * i, a, !1, i, n), this.addHalfVertex(t, o, s, a, !0, -r, n), this.distance > Ds / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, i, r, n, a)) }, Rs.prototype.addHalfVertex = function (t, e, i, r, n, a, o) { var s = .5 * (this.lineClips ? this.scaledDistance * (Ds - 1) : this.scaledDistance); this.layoutVertexArray.emplaceBack((t.x << 1) + (r ? 1 : 0), (t.y << 1) + (n ? 1 : 0), Math.round(63 * e) + 128, Math.round(63 * i) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & s) << 2, s >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length); var l = o.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), n ? this.e2 = l : this.e1 = l }, Rs.prototype.updateScaledDistance = function () { this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance }, Rs.prototype.updateDistance = function (t, e) { this.distance += t.dist(e), this.updateScaledDistance() }, Or("LineBucket", Rs, { omit: ["layers", "patternFeatures"] }); var Bs = new bn({ "line-cap": new yn(Pt.layout_line["line-cap"]), "line-join": new gn(Pt.layout_line["line-join"]), "line-miter-limit": new yn(Pt.layout_line["line-miter-limit"]), "line-round-limit": new yn(Pt.layout_line["line-round-limit"]), "line-sort-key": new gn(Pt.layout_line["line-sort-key"]) }), Os = { paint: new bn({ "line-opacity": new gn(Pt.paint_line["line-opacity"]), "line-color": new gn(Pt.paint_line["line-color"]), "line-translate": new yn(Pt.paint_line["line-translate"]), "line-translate-anchor": new yn(Pt.paint_line["line-translate-anchor"]), "line-width": new gn(Pt.paint_line["line-width"]), "line-gap-width": new gn(Pt.paint_line["line-gap-width"]), "line-offset": new gn(Pt.paint_line["line-offset"]), "line-blur": new gn(Pt.paint_line["line-blur"]), "line-dasharray": new vn(Pt.paint_line["line-dasharray"]), "line-pattern": new _n(Pt.paint_line["line-pattern"]), "line-gradient": new xn(Pt.paint_line["line-gradient"]) }), layout: Bs }, Fs = new (function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (e, i) { return i = new sn(Math.floor(i.zoom), { now: i.now, fadeDuration: i.fadeDuration, zoomHistory: i.zoomHistory, transition: i.transition }), t.prototype.possiblyEvaluate.call(this, e, i) }, e.prototype.evaluate = function (e, i, r, n) { return i = p({}, i, { zoom: Math.floor(i.zoom) }), t.prototype.evaluate.call(this, e, i, r, n) }, e }(gn))(Os.paint.properties["line-width"].specification); Fs.useIntegerZoom = !0; var Us = function (t) { function e(e) { t.call(this, e, Os), this.gradientVersion = 0 } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._handleSpecialPaintPropertyUpdate = function (t) { "line-gradient" === t && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof qe, this.gradientVersion = (this.gradientVersion + 1) % s) }, e.prototype.gradientExpression = function () { return this._transitionablePaint._values["line-gradient"].value.expression }, e.prototype.recalculate = function (e, i) { t.prototype.recalculate.call(this, e, i), this.paint._values["line-floorwidth"] = Fs.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e) }, e.prototype.createBucket = function (t) { return new Rs(t) }, e.prototype.queryRadius = function (t) { var e = t, i = Ns(to("line-width", this, e), to("line-gap-width", this, e)), r = to("line-offset", this, e); return i / 2 + Math.abs(r) + eo(this.paint.get("line-translate")) }, e.prototype.queryIntersectsFeature = function (t, e, i, r, a, o, s) { var l = io(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, s), u = s / 2 * Ns(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i)), h = this.paint.get("line-offset").evaluate(e, i); return h && (r = function (t, e) { for (var i = [], r = new n(0, 0), a = 0; a < t.length; a++) { for (var o = t[a], s = [], l = 0; l < o.length; l++) { var u = o[l], h = o[l + 1], c = 0 === l ? r : u.sub(o[l - 1])._unit()._perp(), p = l === o.length - 1 ? r : h.sub(u)._unit()._perp(), f = c._add(p)._unit(); f._mult(1 / (f.x * p.x + f.y * p.y)), s.push(f._mult(e)._add(u)) } i.push(s) } return i }(r, h * s)), function (t, e, i) { for (var r = 0; r < e.length; r++) { var n = e[r]; if (t.length >= 3) for (var a = 0; a < n.length; a++)if (Ya(t, n[a])) return !0; if (Xa(t, n, i)) return !0 } return !1 }(l, r, u) }, e.prototype.isTileClipped = function () { return !0 }, e }(wn); function Ns(t, e) { return e > 0 ? e + 2 * t : t } var Vs = In([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), js = In([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), qs = (In([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), In([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Gs = (In([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), In([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Zs = In([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); function Xs(t, e, i) { return t.sections.forEach((function (t) { t.text = function (t, e, i) { var r = e.layout.get("text-transform").evaluate(i, {}); return "uppercase" === r ? t = t.toLocaleUpperCase() : "lowercase" === r && (t = t.toLocaleLowerCase()), on.applyArabicShaping && (t = on.applyArabicShaping(t)), t }(t.text, e, i) })), t } In([{ name: "triangle", components: 3, type: "Uint16" }]), In([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), In([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), In([{ type: "Float32", name: "offsetX" }]), In([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]); var Ws = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }, Ks = function (t, e, i, r, n) { var a, o, s = 8 * n - r - 1, l = (1 << s) - 1, u = l >> 1, h = -7, c = i ? n - 1 : 0, p = i ? -1 : 1, f = t[e + c]; for (c += p, a = f & (1 << -h) - 1, f >>= -h, h += s; h > 0; a = 256 * a + t[e + c], c += p, h -= 8); for (o = a & (1 << -h) - 1, a >>= -h, h += r; h > 0; o = 256 * o + t[e + c], c += p, h -= 8); if (0 === a) a = 1 - u; else { if (a === l) return o ? NaN : 1 / 0 * (f ? -1 : 1); o += Math.pow(2, r), a -= u } return (f ? -1 : 1) * o * Math.pow(2, a - r) }, Hs = function (t, e, i, r, n, a) { var o, s, l, u = 8 * a - n - 1, h = (1 << u) - 1, c = h >> 1, p = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : a - 1, d = r ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = h) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (e += o + c >= 1 ? p / l : p * Math.pow(2, 1 - c)) * l >= 2 && (o++, l /= 2), o + c >= h ? (s = 0, o = h) : o + c >= 1 ? (s = (e * l - 1) * Math.pow(2, n), o += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, n), o = 0)); n >= 8; t[i + f] = 255 & s, f += d, s /= 256, n -= 8); for (o = o << n | s, u += n; u > 0; t[i + f] = 255 & o, f += d, o /= 256, u -= 8); t[i + f - d] |= 128 * m }, $s = Js; function Js(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } Js.Varint = 0, Js.Fixed64 = 1, Js.Bytes = 2, Js.Fixed32 = 5; var Ys = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8"); function Qs(t) { return t.type === Js.Bytes ? t.readVarint() + t.pos : t.pos + 1 } function tl(t, e, i) { return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0) } function el(t, e, i) { var r = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2)); i.realloc(r); for (var n = i.pos - 1; n >= t; n--)i.buf[n + r] = i.buf[n] } function il(t, e) { for (var i = 0; i < t.length; i++)e.writeVarint(t[i]) } function rl(t, e) { for (var i = 0; i < t.length; i++)e.writeSVarint(t[i]) } function nl(t, e) { for (var i = 0; i < t.length; i++)e.writeFloat(t[i]) } function al(t, e) { for (var i = 0; i < t.length; i++)e.writeDouble(t[i]) } function ol(t, e) { for (var i = 0; i < t.length; i++)e.writeBoolean(t[i]) } function sl(t, e) { for (var i = 0; i < t.length; i++)e.writeFixed32(t[i]) } function ll(t, e) { for (var i = 0; i < t.length; i++)e.writeSFixed32(t[i]) } function ul(t, e) { for (var i = 0; i < t.length; i++)e.writeFixed64(t[i]) } function hl(t, e) { for (var i = 0; i < t.length; i++)e.writeSFixed64(t[i]) } function cl(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3] } function pl(t, e, i) { t[i] = e, t[i + 1] = e >>> 8, t[i + 2] = e >>> 16, t[i + 3] = e >>> 24 } function fl(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24) } function dl(t, e, i) { 1 === t && i.readMessage(ml, e) } function ml(t, e, i) { if (3 === t) { var r = i.readMessage(yl, {}), n = r.width, a = r.height, o = r.left, s = r.top, l = r.advance; e.push({ id: r.id, bitmap: new _o({ width: n + 6, height: a + 6 }, r.bitmap), metrics: { width: n, height: a, left: o, top: s, advance: l } }) } } function yl(t, e, i) { 1 === t ? e.id = i.readVarint() : 2 === t ? e.bitmap = i.readBytes() : 3 === t ? e.width = i.readVarint() : 4 === t ? e.height = i.readVarint() : 5 === t ? e.left = i.readSVarint() : 6 === t ? e.top = i.readSVarint() : 7 === t && (e.advance = i.readVarint()) } function gl(t) { for (var e = 0, i = 0, r = 0, n = t; r < n.length; r += 1) { var a = n[r]; e += a.w * a.h, i = Math.max(i, a.w) } t.sort((function (t, e) { return e.h - t.h })); for (var o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), i), h: 1 / 0 }], s = 0, l = 0, u = 0, h = t; u < h.length; u += 1)for (var c = h[u], p = o.length - 1; p >= 0; p--) { var f = o[p]; if (!(c.w > f.w || c.h > f.h)) { if (c.x = f.x, c.y = f.y, l = Math.max(l, c.y + c.h), s = Math.max(s, c.x + c.w), c.w === f.w && c.h === f.h) { var d = o.pop(); p < o.length && (o[p] = d) } else c.h === f.h ? (f.x += c.w, f.w -= c.w) : c.w === f.w ? (f.y += c.h, f.h -= c.h) : (o.push({ x: f.x + c.w, y: f.y, w: f.w - c.w, h: c.h }), f.y += c.h, f.h -= c.h); break } } return { w: s, h: l, fill: e / (s * l) || 0 } } Js.prototype = { destroy: function () { this.buf = null }, readFields: function (t, e, i) { for (i = i || this.length; this.pos < i;) { var r = this.readVarint(), n = r >> 3, a = this.pos; this.type = 7 & r, t(n, e, this), this.pos === a && this.skip(r) } return e }, readMessage: function (t, e) { return this.readFields(t, e, this.readVarint() + this.pos) }, readFixed32: function () { var t = cl(this.buf, this.pos); return this.pos += 4, t }, readSFixed32: function () { var t = fl(this.buf, this.pos); return this.pos += 4, t }, readFixed64: function () { var t = cl(this.buf, this.pos) + 4294967296 * cl(this.buf, this.pos + 4); return this.pos += 8, t }, readSFixed64: function () { var t = cl(this.buf, this.pos) + 4294967296 * fl(this.buf, this.pos + 4); return this.pos += 8, t }, readFloat: function () { var t = Ks(this.buf, this.pos, !0, 23, 4); return this.pos += 4, t }, readDouble: function () { var t = Ks(this.buf, this.pos, !0, 52, 8); return this.pos += 8, t }, readVarint: function (t) { var e, i, r = this.buf; return e = 127 & (i = r[this.pos++]), i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 7, i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 14, i < 128 ? e : (e |= (127 & (i = r[this.pos++])) << 21, i < 128 ? e : function (t, e, i) { var r, n, a = i.buf; if (r = (112 & (n = a[i.pos++])) >> 4, n < 128) return tl(t, r, e); if (r |= (127 & (n = a[i.pos++])) << 3, n < 128) return tl(t, r, e); if (r |= (127 & (n = a[i.pos++])) << 10, n < 128) return tl(t, r, e); if (r |= (127 & (n = a[i.pos++])) << 17, n < 128) return tl(t, r, e); if (r |= (127 & (n = a[i.pos++])) << 24, n < 128) return tl(t, r, e); if (r |= (1 & (n = a[i.pos++])) << 31, n < 128) return tl(t, r, e); throw new Error("Expected varint not more than 10 bytes") }(e |= (15 & (i = r[this.pos])) << 28, t, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var t = this.readVarint(); return t % 2 == 1 ? (t + 1) / -2 : t / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var t = this.readVarint() + this.pos, e = this.pos; return this.pos = t, t - e >= 12 && Ys ? function (t, e, i) { return Ys.decode(t.subarray(e, i)) }(this.buf, e, t) : function (t, e, i) { for (var r = "", n = e; n < i;) { var a, o, s, l = t[n], u = null, h = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (n + h > i) break; 1 === h ? l < 128 && (u = l) : 2 === h ? 128 == (192 & (a = t[n + 1])) && (u = (31 & l) << 6 | 63 & a) <= 127 && (u = null) : 3 === h ? (o = t[n + 2], 128 == (192 & (a = t[n + 1])) && 128 == (192 & o) && ((u = (15 & l) << 12 | (63 & a) << 6 | 63 & o) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === h && (o = t[n + 2], s = t[n + 3], 128 == (192 & (a = t[n + 1])) && 128 == (192 & o) && 128 == (192 & s) && ((u = (15 & l) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, h = 1) : u > 65535 && (u -= 65536, r += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), r += String.fromCharCode(u), n += h } return r }(this.buf, e, t) }, readBytes: function () { var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e }, readPackedVarint: function (t, e) { if (this.type !== Js.Bytes) return t.push(this.readVarint(e)); var i = Qs(this); for (t = t || []; this.pos < i;)t.push(this.readVarint(e)); return t }, readPackedSVarint: function (t) { if (this.type !== Js.Bytes) return t.push(this.readSVarint()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readSVarint()); return t }, readPackedBoolean: function (t) { if (this.type !== Js.Bytes) return t.push(this.readBoolean()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readBoolean()); return t }, readPackedFloat: function (t) { if (this.type !== Js.Bytes) return t.push(this.readFloat()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readFloat()); return t }, readPackedDouble: function (t) { if (this.type !== Js.Bytes) return t.push(this.readDouble()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readDouble()); return t }, readPackedFixed32: function (t) { if (this.type !== Js.Bytes) return t.push(this.readFixed32()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readFixed32()); return t }, readPackedSFixed32: function (t) { if (this.type !== Js.Bytes) return t.push(this.readSFixed32()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed32()); return t }, readPackedFixed64: function (t) { if (this.type !== Js.Bytes) return t.push(this.readFixed64()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readFixed64()); return t }, readPackedSFixed64: function (t) { if (this.type !== Js.Bytes) return t.push(this.readSFixed64()); var e = Qs(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed64()); return t }, skip: function (t) { var e = 7 & t; if (e === Js.Varint) for (; this.buf[this.pos++] > 127;); else if (e === Js.Bytes) this.pos = this.readVarint() + this.pos; else if (e === Js.Fixed32) this.pos += 4; else { if (e !== Js.Fixed64) throw new Error("Unimplemented type: " + e); this.pos += 8 } }, writeTag: function (t, e) { this.writeVarint(t << 3 | e) }, realloc: function (t) { for (var e = this.length || 16; e < this.pos + t;)e *= 2; if (e !== this.length) { var i = new Uint8Array(e); i.set(this.buf), this.buf = i, this.length = e } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (t) { this.realloc(4), pl(this.buf, t, this.pos), this.pos += 4 }, writeSFixed32: function (t) { this.realloc(4), pl(this.buf, t, this.pos), this.pos += 4 }, writeFixed64: function (t) { this.realloc(8), pl(this.buf, -1 & t, this.pos), pl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeSFixed64: function (t) { this.realloc(8), pl(this.buf, -1 & t, this.pos), pl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeVarint: function (t) { (t = +t || 0) > 268435455 || t < 0 ? function (t, e) { var i, r; if (t >= 0 ? (i = t % 4294967296 | 0, r = t / 4294967296 | 0) : (r = ~(-t / 4294967296), 4294967295 ^ (i = ~(-t % 4294967296)) ? i = i + 1 | 0 : (i = 0, r = r + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); e.realloc(10), function (t, e, i) { i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, t >>>= 7, i.buf[i.pos++] = 127 & t | 128, i.buf[i.pos] = 127 & (t >>>= 7) }(i, 0, e), function (t, e) { var i = (7 & t) << 4; e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t))))) }(r, e) }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)))) }, writeSVarint: function (t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t) }, writeBoolean: function (t) { this.writeVarint(Boolean(t)) }, writeString: function (t) { t = String(t), this.realloc(4 * t.length), this.pos++; var e = this.pos; this.pos = function (t, e, i) { for (var r, n, a = 0; a < e.length; a++) { if ((r = e.charCodeAt(a)) > 55295 && r < 57344) { if (!n) { r > 56319 || a + 1 === e.length ? (t[i++] = 239, t[i++] = 191, t[i++] = 189) : n = r; continue } if (r < 56320) { t[i++] = 239, t[i++] = 191, t[i++] = 189, n = r; continue } r = n - 55296 << 10 | r - 56320 | 65536, n = null } else n && (t[i++] = 239, t[i++] = 191, t[i++] = 189, n = null); r < 128 ? t[i++] = r : (r < 2048 ? t[i++] = r >> 6 | 192 : (r < 65536 ? t[i++] = r >> 12 | 224 : (t[i++] = r >> 18 | 240, t[i++] = r >> 12 & 63 | 128), t[i++] = r >> 6 & 63 | 128), t[i++] = 63 & r | 128) } return i }(this.buf, t, this.pos); var i = this.pos - e; i >= 128 && el(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i }, writeFloat: function (t) { this.realloc(4), Hs(this.buf, t, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (t) { this.realloc(8), Hs(this.buf, t, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (t) { var e = t.length; this.writeVarint(e), this.realloc(e); for (var i = 0; i < e; i++)this.buf[this.pos++] = t[i] }, writeRawMessage: function (t, e) { this.pos++; var i = this.pos; t(e, this); var r = this.pos - i; r >= 128 && el(i, r, this), this.pos = i - 1, this.writeVarint(r), this.pos += r }, writeMessage: function (t, e, i) { this.writeTag(t, Js.Bytes), this.writeRawMessage(e, i) }, writePackedVarint: function (t, e) { e.length && this.writeMessage(t, il, e) }, writePackedSVarint: function (t, e) { e.length && this.writeMessage(t, rl, e) }, writePackedBoolean: function (t, e) { e.length && this.writeMessage(t, ol, e) }, writePackedFloat: function (t, e) { e.length && this.writeMessage(t, nl, e) }, writePackedDouble: function (t, e) { e.length && this.writeMessage(t, al, e) }, writePackedFixed32: function (t, e) { e.length && this.writeMessage(t, sl, e) }, writePackedSFixed32: function (t, e) { e.length && this.writeMessage(t, ll, e) }, writePackedFixed64: function (t, e) { e.length && this.writeMessage(t, ul, e) }, writePackedSFixed64: function (t, e) { e.length && this.writeMessage(t, hl, e) }, writeBytesField: function (t, e) { this.writeTag(t, Js.Bytes), this.writeBytes(e) }, writeFixed32Field: function (t, e) { this.writeTag(t, Js.Fixed32), this.writeFixed32(e) }, writeSFixed32Field: function (t, e) { this.writeTag(t, Js.Fixed32), this.writeSFixed32(e) }, writeFixed64Field: function (t, e) { this.writeTag(t, Js.Fixed64), this.writeFixed64(e) }, writeSFixed64Field: function (t, e) { this.writeTag(t, Js.Fixed64), this.writeSFixed64(e) }, writeVarintField: function (t, e) { this.writeTag(t, Js.Varint), this.writeVarint(e) }, writeSVarintField: function (t, e) { this.writeTag(t, Js.Varint), this.writeSVarint(e) }, writeStringField: function (t, e) { this.writeTag(t, Js.Bytes), this.writeString(e) }, writeFloatField: function (t, e) { this.writeTag(t, Js.Fixed32), this.writeFloat(e) }, writeDoubleField: function (t, e) { this.writeTag(t, Js.Fixed64), this.writeDouble(e) }, writeBooleanField: function (t, e) { this.writeVarintField(t, Boolean(e)) } }; var _l = function (t, e) { var i = e.pixelRatio, r = e.version, n = e.stretchX, a = e.stretchY, o = e.content; this.paddedRect = t, this.pixelRatio = i, this.stretchX = n, this.stretchY = a, this.content = o, this.version = r }, vl = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } }; vl.tl.get = function () { return [this.paddedRect.x + 1, this.paddedRect.y + 1] }, vl.br.get = function () { return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1] }, vl.tlbr.get = function () { return this.tl.concat(this.br) }, vl.displaySize.get = function () { return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio] }, Object.defineProperties(_l.prototype, vl); var xl = function (t, e) { var i = {}, r = {}; this.haveRenderCallbacks = []; var n = []; this.addImages(t, i, n), this.addImages(e, r, n); var a = gl(n), o = new vo({ width: a.w || 1, height: a.h || 1 }); for (var s in t) { var l = t[s], u = i[s].paddedRect; vo.copy(l.data, o, { x: 0, y: 0 }, { x: u.x + 1, y: u.y + 1 }, l.data) } for (var h in e) { var c = e[h], p = r[h].paddedRect, f = p.x + 1, d = p.y + 1, m = c.data.width, y = c.data.height; vo.copy(c.data, o, { x: 0, y: 0 }, { x: f, y: d }, c.data), vo.copy(c.data, o, { x: 0, y: y - 1 }, { x: f, y: d - 1 }, { width: m, height: 1 }), vo.copy(c.data, o, { x: 0, y: 0 }, { x: f, y: d + y }, { width: m, height: 1 }), vo.copy(c.data, o, { x: m - 1, y: 0 }, { x: f - 1, y: d }, { width: 1, height: y }), vo.copy(c.data, o, { x: 0, y: 0 }, { x: f + m, y: d }, { width: 1, height: y }) } this.image = o, this.iconPositions = i, this.patternPositions = r }; xl.prototype.addImages = function (t, e, i) { for (var r in t) { var n = t[r], a = { x: 0, y: 0, w: n.data.width + 2, h: n.data.height + 2 }; i.push(a), e[r] = new _l(a, n), n.hasRenderCallback && this.haveRenderCallbacks.push(r) } }, xl.prototype.patchUpdatedImages = function (t, e) { for (var i in t.dispatchRenderCallbacks(this.haveRenderCallbacks), t.updatedImages) this.patchUpdatedImage(this.iconPositions[i], t.getImage(i), e), this.patchUpdatedImage(this.patternPositions[i], t.getImage(i), e) }, xl.prototype.patchUpdatedImage = function (t, e, i) { if (t && e && t.version !== e.version) { t.version = e.version; var r = t.tl; i.update(e.data, void 0, { x: r[0], y: r[1] }) } }, Or("ImagePosition", _l), Or("ImageAtlas", xl); var bl = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, wl = function () { this.scale = 1, this.fontStack = "", this.imageName = null }; wl.forText = function (t, e) { var i = new wl; return i.scale = t || 1, i.fontStack = e, i }, wl.forImage = function (t) { var e = new wl; return e.imageName = t, e }; var Ml = function () { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null }; function Sl(t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m) { var y, g = Ml.fromFeature(t, n); c === bl.vertical && g.verticalizePunctuation(); var _ = on.processBidirectionalText, v = on.processStyledBidirectionalText; if (_ && 1 === g.sections.length) { y = []; for (var x = 0, b = _(g.toString(), zl(g, u, a, e, r, f, d)); x < b.length; x += 1) { var w = b[x], M = new Ml; M.text = w, M.sections = g.sections; for (var S = 0; S < w.length; S++)M.sectionIndex.push(0); y.push(M) } } else if (v) { y = []; for (var E = 0, I = v(g.text, g.sectionIndex, zl(g, u, a, e, r, f, d)); E < I.length; E += 1) { var T = I[E], A = new Ml; A.text = T[0], A.sectionIndex = T[1], A.sections = g.sections, y.push(A) } } else y = function (t, e) { for (var i = [], r = t.text, n = 0, a = 0, o = e; a < o.length; a += 1) { var s = o[a]; i.push(t.substring(n, s)), n = s } return n < r.length && i.push(t.substring(n, r.length)), i }(g, zl(g, u, a, e, r, f, d)); var P = [], C = { positionedLines: P, text: g.toString(), top: h[1], bottom: h[1], left: h[0], right: h[0], writingMode: c, iconsInText: !1, verticalizable: !1 }; return function (t, e, i, r, n, a, o, s, l, u, h, c) { for (var p = 0, f = -17, d = 0, m = 0, y = "right" === s ? 1 : "left" === s ? 0 : .5, g = 0, _ = 0, v = n; _ < v.length; _ += 1) { var x = v[_]; x.trim(); var b = x.getMaxScale(), w = 24 * (b - 1), M = { positionedGlyphs: [], lineOffset: 0 }; t.positionedLines[g] = M; var S = M.positionedGlyphs, E = 0; if (x.length()) { for (var I = 0; I < x.length(); I++) { var T = x.getSection(I), A = x.getSectionIndex(I), P = x.getCharCode(I), C = 0, z = null, k = null, L = null, D = 24, R = !(l === bl.horizontal || !h && !Xr(P) || h && (El[P] || (G = P, Gr.Arabic(G) || Gr["Arabic Supplement"](G) || Gr["Arabic Extended-A"](G) || Gr["Arabic Presentation Forms-A"](G) || Gr["Arabic Presentation Forms-B"](G)))); if (T.imageName) { var B = r[T.imageName]; if (!B) continue; L = T.imageName, t.iconsInText = t.iconsInText || !0, k = B.paddedRect; var O = B.displaySize; T.scale = 24 * T.scale / c, C = w + (24 - O[1] * T.scale), D = (z = { width: O[0], height: O[1], left: 1, top: -3, advance: R ? O[1] : O[0] }).advance; var F = R ? O[0] * T.scale - 24 * b : O[1] * T.scale - 24 * b; F > 0 && F > E && (E = F) } else { var U = i[T.fontStack], N = U && U[P]; if (N && N.rect) k = N.rect, z = N.metrics; else { var V = e[T.fontStack], j = V && V[P]; if (!j) continue; z = j.metrics } C = 24 * (b - T.scale) } R ? (t.verticalizable = !0, S.push({ glyph: P, imageName: L, x: p, y: f + C, vertical: R, scale: T.scale, fontStack: T.fontStack, sectionIndex: A, metrics: z, rect: k }), p += D * T.scale + u) : (S.push({ glyph: P, imageName: L, x: p, y: f + C, vertical: R, scale: T.scale, fontStack: T.fontStack, sectionIndex: A, metrics: z, rect: k }), p += z.advance * T.scale + u) } 0 !== S.length && (d = Math.max(p - u, d), Ll(S, 0, S.length - 1, y, E)), p = 0; var q = a * b + E; M.lineOffset = Math.max(E, w), f += q, m = Math.max(q, m), ++g } else f += a, ++g } var G, Z = f - -17, X = kl(o), W = X.horizontalAlign, K = X.verticalAlign; (function (t, e, i, r, n, a, o, s, l) { var u, h = (e - i) * n; u = a !== o ? -s * r - -17 : (-r * l + .5) * o; for (var c = 0, p = t; c < p.length; c += 1)for (var f = 0, d = p[c].positionedGlyphs; f < d.length; f += 1) { var m = d[f]; m.x += h, m.y += u } })(t.positionedLines, y, W, K, d, m, a, Z, n.length), t.top += -K * Z, t.bottom = t.top + Z, t.left += -W * d, t.right = t.left + d }(C, e, i, r, y, o, s, l, c, u, p, m), !function (t) { for (var e = 0, i = t; e < i.length; e += 1)if (0 !== i[e].positionedGlyphs.length) return !1; return !0 }(P) && C } Ml.fromFeature = function (t, e) { for (var i = new Ml, r = 0; r < t.sections.length; r++) { var n = t.sections[r]; n.image ? i.addImageSection(n) : i.addTextSection(n, e) } return i }, Ml.prototype.length = function () { return this.text.length }, Ml.prototype.getSection = function (t) { return this.sections[this.sectionIndex[t]] }, Ml.prototype.getSectionIndex = function (t) { return this.sectionIndex[t] }, Ml.prototype.getCharCode = function (t) { return this.text.charCodeAt(t) }, Ml.prototype.verticalizePunctuation = function () { this.text = function (t) { for (var e = "", i = 0; i < t.length; i++) { var r = t.charCodeAt(i + 1) || null, n = t.charCodeAt(i - 1) || null; e += r && Wr(r) && !Ws[t[i + 1]] || n && Wr(n) && !Ws[t[i - 1]] || !Ws[t[i]] ? t[i] : Ws[t[i]] } return e }(this.text) }, Ml.prototype.trim = function () { for (var t = 0, e = 0; e < this.text.length && El[this.text.charCodeAt(e)]; e++)t++; for (var i = this.text.length, r = this.text.length - 1; r >= 0 && r >= t && El[this.text.charCodeAt(r)]; r--)i--; this.text = this.text.substring(t, i), this.sectionIndex = this.sectionIndex.slice(t, i) }, Ml.prototype.substring = function (t, e) { var i = new Ml; return i.text = this.text.substring(t, e), i.sectionIndex = this.sectionIndex.slice(t, e), i.sections = this.sections, i }, Ml.prototype.toString = function () { return this.text }, Ml.prototype.getMaxScale = function () { var t = this; return this.sectionIndex.reduce((function (e, i) { return Math.max(e, t.sections[i].scale) }), 0) }, Ml.prototype.addTextSection = function (t, e) { this.text += t.text, this.sections.push(wl.forText(t.scale, t.fontStack || e)); for (var i = this.sections.length - 1, r = 0; r < t.text.length; ++r)this.sectionIndex.push(i) }, Ml.prototype.addImageSection = function (t) { var e = t.image ? t.image.name : ""; if (0 !== e.length) { var i = this.getNextImageSectionCharCode(); i ? (this.text += String.fromCharCode(i), this.sections.push(wl.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : M("Reached maximum number of images 6401") } else M("Can't add FormattedSection with an empty image.") }, Ml.prototype.getNextImageSectionCharCode = function () { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) }; var El = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Il = {}; function Tl(t, e, i, r, n, a) { if (e.imageName) { var o = r[e.imageName]; return o ? o.displaySize[0] * e.scale * 24 / a + n : 0 } var s = i[e.fontStack], l = s && s[t]; return l ? l.metrics.advance * e.scale + n : 0 } function Al(t, e, i, r) { var n = Math.pow(t - e, 2); return r ? t < e ? n / 2 : 2 * n : n + Math.abs(i) * i } function Pl(t, e, i) { var r = 0; return 10 === t && (r -= 1e4), i && (r += 150), 40 !== t && 65288 !== t || (r += 50), 41 !== e && 65289 !== e || (r += 50), r } function Cl(t, e, i, r, n, a) { for (var o = null, s = Al(e, i, n, a), l = 0, u = r; l < u.length; l += 1) { var h = u[l], c = Al(e - h.x, i, n, a) + h.badness; c <= s && (o = h, s = c) } return { index: t, x: e, priorBreak: o, badness: s } } function zl(t, e, i, r, n, a, o) { if ("point" !== a) return []; if (!t) return []; for (var s, l = [], u = function (t, e, i, r, n, a) { for (var o = 0, s = 0; s < t.length(); s++) { var l = t.getSection(s); o += Tl(t.getCharCode(s), l, r, n, e, a) } return o / Math.max(1, Math.ceil(o / i)) }(t, e, i, r, n, o), h = t.text.indexOf("​") >= 0, c = 0, p = 0; p < t.length(); p++) { var f = t.getSection(p), d = t.getCharCode(p); if (El[d] || (c += Tl(d, f, r, n, e, o)), p < t.length() - 1) { var m = !((s = d) < 11904 || !(Gr["Bopomofo Extended"](s) || Gr.Bopomofo(s) || Gr["CJK Compatibility Forms"](s) || Gr["CJK Compatibility Ideographs"](s) || Gr["CJK Compatibility"](s) || Gr["CJK Radicals Supplement"](s) || Gr["CJK Strokes"](s) || Gr["CJK Symbols and Punctuation"](s) || Gr["CJK Unified Ideographs Extension A"](s) || Gr["CJK Unified Ideographs"](s) || Gr["Enclosed CJK Letters and Months"](s) || Gr["Halfwidth and Fullwidth Forms"](s) || Gr.Hiragana(s) || Gr["Ideographic Description Characters"](s) || Gr["Kangxi Radicals"](s) || Gr["Katakana Phonetic Extensions"](s) || Gr.Katakana(s) || Gr["Vertical Forms"](s) || Gr["Yi Radicals"](s) || Gr["Yi Syllables"](s))); (Il[d] || m || f.imageName) && l.push(Cl(p + 1, c, u, l, Pl(d, t.getCharCode(p + 1), m && h), !1)) } } return function t(e) { return e ? t(e.priorBreak).concat(e.index) : [] }(Cl(t.length(), c, u, l, 0, !0)) } function kl(t) { var e = .5, i = .5; switch (t) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0 }switch (t) { case "bottom": case "bottom-right": case "bottom-left": i = 1; break; case "top": case "top-right": case "top-left": i = 0 }return { horizontalAlign: e, verticalAlign: i } } function Ll(t, e, i, r, n) { if (r || n) for (var a = t[i], o = (t[i].x + a.metrics.advance * a.scale) * r, s = e; s <= i; s++)t[s].x -= o, t[s].y += n } function Dl(t, e, i, r, n, a) { var o, s = t.image; if (s.content) { var l = s.content, u = s.pixelRatio || 1; o = [l[0] / u, l[1] / u, s.displaySize[0] - l[2] / u, s.displaySize[1] - l[3] / u] } var h, c, p, f, d = e.left * a, m = e.right * a; "width" === i || "both" === i ? (f = n[0] + d - r[3], c = n[0] + m + r[1]) : c = (f = n[0] + (d + m - s.displaySize[0]) / 2) + s.displaySize[0]; var y = e.top * a, g = e.bottom * a; return "height" === i || "both" === i ? (h = n[1] + y - r[0], p = n[1] + g + r[2]) : p = (h = n[1] + (y + g - s.displaySize[1]) / 2) + s.displaySize[1], { image: s, top: h, right: c, bottom: p, left: f, collisionPadding: o } } Il[10] = !0, Il[32] = !0, Il[38] = !0, Il[40] = !0, Il[41] = !0, Il[43] = !0, Il[45] = !0, Il[47] = !0, Il[173] = !0, Il[183] = !0, Il[8203] = !0, Il[8208] = !0, Il[8211] = !0, Il[8231] = !0; var Rl = function (t) { function e(e, i, r, n) { t.call(this, e, i), this.angle = r, void 0 !== n && (this.segment = n) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.clone = function () { return new e(this.x, this.y, this.angle, this.segment) }, e }(n); function Bl(t, e) { var i = e.expression; if ("constant" === i.kind) return { kind: "constant", layoutSize: i.evaluate(new sn(t + 1)) }; if ("source" === i.kind) return { kind: "source" }; for (var r = i.zoomStops, n = i.interpolationType, a = 0; a < r.length && r[a] <= t;)a++; for (var o = a = Math.max(0, a - 1); o < r.length && r[o] < t + 1;)o++; o = Math.min(r.length - 1, o); var s = r[a], l = r[o]; return "composite" === i.kind ? { kind: "composite", minZoom: s, maxZoom: l, interpolationType: n } : { kind: "camera", minZoom: s, maxZoom: l, minSize: i.evaluate(new sn(s)), maxSize: i.evaluate(new sn(l)), interpolationType: n } } function Ol(t, e, i) { var r = e.uSize, n = i.lowerSize; return "source" === t.kind ? n / 128 : "composite" === t.kind ? Ge(n / 128, i.upperSize / 128, e.uSizeT) : r } function Fl(t, e) { var i = 0, r = 0; if ("constant" === t.kind) r = t.layoutSize; else if ("source" !== t.kind) { var n = t.interpolationType, a = n ? h(ai.interpolationFactor(n, e, t.minZoom, t.maxZoom), 0, 1) : 0; "camera" === t.kind ? r = Ge(t.minSize, t.maxSize, a) : i = a } return { uSizeT: i, uSize: r } } Or("Anchor", Rl); var Ul = Object.freeze({ __proto__: null, getSizeData: Bl, evaluateSizeForFeature: Ol, evaluateSizeForZoom: Fl, SIZE_PACK_FACTOR: 128 }); function Nl(t, e, i, r, n) { if (void 0 === e.segment) return !0; for (var a = e, o = e.segment + 1, s = 0; s > -i / 2;) { if (--o < 0) return !1; s -= t[o].dist(a), a = t[o] } s += t[o].dist(t[o + 1]), o++; for (var l = [], u = 0; s < i / 2;) { var h = t[o], c = t[o + 1]; if (!c) return !1; var p = t[o - 1].angleTo(h) - h.angleTo(c); for (p = Math.abs((p + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({ distance: s, angleDelta: p }), u += p; s - l[0].distance > r;)u -= l.shift().angleDelta; if (u > n) return !1; o++, s += h.dist(c) } return !0 } function Vl(t) { for (var e = 0, i = 0; i < t.length - 1; i++)e += t[i].dist(t[i + 1]); return e } function jl(t, e, i) { return t ? .6 * e * i : 0 } function ql(t, e) { return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0) } function Gl(t, e, i, r, n, a) { for (var o = jl(i, n, a), s = ql(i, r) * a, l = 0, u = Vl(t) / 2, h = 0; h < t.length - 1; h++) { var c = t[h], p = t[h + 1], f = c.dist(p); if (l + f > u) { var d = (u - l) / f, m = Ge(c.x, p.x, d), y = Ge(c.y, p.y, d), g = new Rl(m, y, p.angleTo(c), h); return g._round(), !o || Nl(t, g, s, o, e) ? g : void 0 } l += f } } function Zl(t, e, i, r, n, a, o, s, l) { var u = jl(r, a, o), h = ql(r, n), c = h * o, p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l; return e - c < e / 4 && (e = c + e / 4), function t(e, i, r, n, a, o, s, l, u) { for (var h = o / 2, c = Vl(e), p = 0, f = i - r, d = [], m = 0; m < e.length - 1; m++) { for (var y = e[m], g = e[m + 1], _ = y.dist(g), v = g.angleTo(y); f + r < p + _;) { var x = ((f += r) - p) / _, b = Ge(y.x, g.x, x), w = Ge(y.y, g.y, x); if (b >= 0 && b < u && w >= 0 && w < u && f - h >= 0 && f + h <= c) { var M = new Rl(b, w, v, m); M._round(), n && !Nl(e, M, o, n, a) || d.push(M) } } p += _ } return l || d.length || s || (d = t(e, p / 2, r, n, a, o, s, !0, u)), d }(t, p ? e / 2 * s % e : (h / 2 + 2 * a) * o * s % e, e, u, i, c, p, !1, l) } function Xl(t, e, i, r, a) { for (var o = [], s = 0; s < t.length; s++)for (var l = t[s], u = void 0, h = 0; h < l.length - 1; h++) { var c = l[h], p = l[h + 1]; c.x < e && p.x < e || (c.x < e ? c = new n(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x < e && (p = new n(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y < i && p.y < i || (c.y < i ? c = new n(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round() : p.y < i && (p = new n(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round()), c.x >= r && p.x >= r || (c.x >= r ? c = new n(r, c.y + (r - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x >= r && (p = new n(r, c.y + (r - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y >= a && p.y >= a || (c.y >= a ? c = new n(c.x + (a - c.y) / (p.y - c.y) * (p.x - c.x), a)._round() : p.y >= a && (p = new n(c.x + (a - c.y) / (p.y - c.y) * (p.x - c.x), a)._round()), u && c.equals(u[u.length - 1]) || o.push(u = [c]), u.push(p))))) } return o } function Wl(t, e, i, r) { var a = [], o = t.image, s = o.pixelRatio, l = o.paddedRect.w - 2, u = o.paddedRect.h - 2, h = t.right - t.left, c = t.bottom - t.top, p = o.stretchX || [[0, l]], f = o.stretchY || [[0, u]], d = function (t, e) { return t + e[1] - e[0] }, m = p.reduce(d, 0), y = f.reduce(d, 0), g = l - m, _ = u - y, v = 0, x = m, b = 0, w = y, M = 0, S = g, E = 0, I = _; if (o.content && r) { var T = o.content; v = Kl(p, 0, T[0]), b = Kl(f, 0, T[1]), x = Kl(p, T[0], T[2]), w = Kl(f, T[1], T[3]), M = T[0] - v, E = T[1] - b, S = T[2] - T[0] - x, I = T[3] - T[1] - w } var A = function (r, a, l, u) { var p = $l(r.stretch - v, x, h, t.left), f = Jl(r.fixed - M, S, r.stretch, m), d = $l(a.stretch - b, w, c, t.top), g = Jl(a.fixed - E, I, a.stretch, y), _ = $l(l.stretch - v, x, h, t.left), T = Jl(l.fixed - M, S, l.stretch, m), A = $l(u.stretch - b, w, c, t.top), P = Jl(u.fixed - E, I, u.stretch, y), C = new n(p, d), z = new n(_, d), k = new n(_, A), L = new n(p, A), D = new n(f / s, g / s), R = new n(T / s, P / s), B = e * Math.PI / 180; if (B) { var O = Math.sin(B), F = Math.cos(B), U = [F, -O, O, F]; C._matMult(U), z._matMult(U), L._matMult(U), k._matMult(U) } var N = r.stretch + r.fixed, V = a.stretch + a.fixed; return { tl: C, tr: z, bl: L, br: k, tex: { x: o.paddedRect.x + 1 + N, y: o.paddedRect.y + 1 + V, w: l.stretch + l.fixed - N, h: u.stretch + u.fixed - V }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D, pixelOffsetBR: R, minFontScaleX: S / s / h, minFontScaleY: I / s / c, isSDF: i } }; if (r && (o.stretchX || o.stretchY)) for (var P = Hl(p, g, m), C = Hl(f, _, y), z = 0; z < P.length - 1; z++)for (var k = P[z], L = P[z + 1], D = 0; D < C.length - 1; D++)a.push(A(k, C[D], L, C[D + 1])); else a.push(A({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l + 1 }, { fixed: 0, stretch: u + 1 })); return a } function Kl(t, e, i) { for (var r = 0, n = 0, a = t; n < a.length; n += 1) { var o = a[n]; r += Math.max(e, Math.min(i, o[1])) - Math.max(e, Math.min(i, o[0])) } return r } function Hl(t, e, i) { for (var r = [{ fixed: -1, stretch: 0 }], n = 0, a = t; n < a.length; n += 1) { var o = a[n], s = o[0], l = o[1], u = r[r.length - 1]; r.push({ fixed: s - u.stretch, stretch: u.stretch }), r.push({ fixed: s - u.stretch, stretch: u.stretch + (l - s) }) } return r.push({ fixed: e + 1, stretch: i }), r } function $l(t, e, i, r) { return t / e * i + r } function Jl(t, e, i, r) { return t - e * i / r } var Yl = function (t, e, i, r, a, o, s, l, u, h) { if (this.boxStartIndex = t.length, u) { var c = o.top, p = o.bottom, f = o.collisionPadding; f && (c -= f[1], p += f[3]); var d = p - c; d > 0 && (d = Math.max(10, d), this.circleDiameter = d) } else { var m = o.top * s - l, y = o.bottom * s + l, g = o.left * s - l, _ = o.right * s + l, v = o.collisionPadding; if (v && (g -= v[0] * s, m -= v[1] * s, _ += v[2] * s, y += v[3] * s), h) { var x = new n(g, m), b = new n(_, m), w = new n(g, y), M = new n(_, y), S = h * Math.PI / 180; x._rotate(S), b._rotate(S), w._rotate(S), M._rotate(S), g = Math.min(x.x, b.x, w.x, M.x), _ = Math.max(x.x, b.x, w.x, M.x), m = Math.min(x.y, b.y, w.y, M.y), y = Math.max(x.y, b.y, w.y, M.y) } t.emplaceBack(e.x, e.y, g, m, _, y, i, r, a) } this.boxEndIndex = t.length }, Ql = function (t, e) { if (void 0 === t && (t = []), void 0 === e && (e = tu), this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--)this._down(i) }; function tu(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function eu(t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = !1); for (var r = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, l = t[0], u = 0; u < l.length; u++) { var h = l[u]; (!u || h.x < r) && (r = h.x), (!u || h.y < a) && (a = h.y), (!u || h.x > o) && (o = h.x), (!u || h.y > s) && (s = h.y) } var c = Math.min(o - r, s - a), p = c / 2, f = new Ql([], iu); if (0 === c) return new n(r, a); for (var d = r; d < o; d += c)for (var m = a; m < s; m += c)f.push(new ru(d + p, m + p, p, t)); for (var y = function (t) { for (var e = 0, i = 0, r = 0, n = t[0], a = 0, o = n.length, s = o - 1; a < o; s = a++) { var l = n[a], u = n[s], h = l.x * u.y - u.x * l.y; i += (l.x + u.x) * h, r += (l.y + u.y) * h, e += 3 * h } return new ru(i / e, r / e, 0, t) }(t), g = f.length; f.length;) { var _ = f.pop(); (_.d > y.d || !y.d) && (y = _, i && console.log("found best %d after %d probes", Math.round(1e4 * _.d) / 1e4, g)), _.max - y.d <= e || (f.push(new ru(_.p.x - (p = _.h / 2), _.p.y - p, p, t)), f.push(new ru(_.p.x + p, _.p.y - p, p, t)), f.push(new ru(_.p.x - p, _.p.y + p, p, t)), f.push(new ru(_.p.x + p, _.p.y + p, p, t)), g += 4) } return i && (console.log("num probes: " + g), console.log("best distance: " + y.d)), y.p } function iu(t, e) { return e.max - t.max } function ru(t, e, i, r) { this.p = new n(t, e), this.h = i, this.d = function (t, e) { for (var i = !1, r = 1 / 0, n = 0; n < e.length; n++)for (var a = e[n], o = 0, s = a.length, l = s - 1; o < s; l = o++) { var u = a[o], h = a[l]; u.y > t.y != h.y > t.y && t.x < (h.x - u.x) * (t.y - u.y) / (h.y - u.y) + u.x && (i = !i), r = Math.min(r, $a(t, u, h)) } return (i ? 1 : -1) * Math.sqrt(r) }(this.p, r), this.max = this.d + this.h * Math.SQRT2 } Ql.prototype.push = function (t) { this.data.push(t), this.length++, this._up(this.length - 1) }, Ql.prototype.pop = function () { if (0 !== this.length) { var t = this.data[0], e = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t } }, Ql.prototype.peek = function () { return this.data[0] }, Ql.prototype._up = function (t) { for (var e = this.data, i = this.compare, r = e[t]; t > 0;) { var n = t - 1 >> 1, a = e[n]; if (i(r, a) >= 0) break; e[t] = a, t = n } e[t] = r }, Ql.prototype._down = function (t) { for (var e = this.data, i = this.compare, r = this.length >> 1, n = e[t]; t < r;) { var a = 1 + (t << 1), o = e[a], s = a + 1; if (s < this.length && i(e[s], o) < 0 && (a = s, o = e[s]), i(o, n) >= 0) break; e[t] = o, t = a } e[t] = n }; var nu = Number.POSITIVE_INFINITY; function au(t, e) { return e[1] !== nu ? function (t, e, i) { var r = 0, n = 0; switch (e = Math.abs(e), i = Math.abs(i), t) { case "top-right": case "top-left": case "top": n = i - 7; break; case "bottom-right": case "bottom-left": case "bottom": n = 7 - i }switch (t) { case "top-right": case "bottom-right": case "right": r = -e; break; case "top-left": case "bottom-left": case "left": r = e }return [r, n] }(t, e[0], e[1]) : function (t, e) { var i = 0, r = 0; e < 0 && (e = 0); var n = e / Math.sqrt(2); switch (t) { case "top-right": case "top-left": r = n - 7; break; case "bottom-right": case "bottom-left": r = 7 - n; break; case "bottom": r = 7 - e; break; case "top": r = e - 7 }switch (t) { case "top-right": case "bottom-right": i = -n; break; case "top-left": case "bottom-left": i = n; break; case "left": i = e; break; case "right": i = -e }return [i, r] }(t, e[0]) } function ou(t) { switch (t) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function su(t, e, i, r, a, o, s, l, u, h, c, p, f, d, m) { var y = function (t, e, i, r, a, o, s, l) { for (var u = r.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180, h = [], c = 0, p = e.positionedLines; c < p.length; c += 1)for (var f = p[c], d = 0, m = f.positionedGlyphs; d < m.length; d += 1) { var y = m[d]; if (y.rect) { var g = y.rect || {}, _ = 4, v = !0, x = 1, b = 0, w = (a || l) && y.vertical, M = y.metrics.advance * y.scale / 2; if (l && e.verticalizable && (b = f.lineOffset / 2 - (y.imageName ? -(24 - y.metrics.width * y.scale) / 2 : 24 * (y.scale - 1))), y.imageName) { var S = s[y.imageName]; v = S.sdf, _ = 1 / (x = S.pixelRatio) } var E = a ? [y.x + M, y.y] : [0, 0], I = a ? [0, 0] : [y.x + M + i[0], y.y + i[1] - b], T = [0, 0]; w && (T = I, I = [0, 0]); var A = (y.metrics.left - _) * y.scale - M + I[0], P = (-y.metrics.top - _) * y.scale + I[1], C = A + g.w * y.scale / x, z = P + g.h * y.scale / x, k = new n(A, P), L = new n(C, P), D = new n(A, z), R = new n(C, z); if (w) { var B = new n(-M, M - -17), O = -Math.PI / 2, F = 12 - M, U = new n(22 - F, -(y.imageName ? F : 0)), N = new (Function.prototype.bind.apply(n, [null].concat(T))); k._rotateAround(O, B)._add(U)._add(N), L._rotateAround(O, B)._add(U)._add(N), D._rotateAround(O, B)._add(U)._add(N), R._rotateAround(O, B)._add(U)._add(N) } if (u) { var V = Math.sin(u), j = Math.cos(u), q = [j, -V, V, j]; k._matMult(q), L._matMult(q), D._matMult(q), R._matMult(q) } var G = new n(0, 0), Z = new n(0, 0); h.push({ tl: k, tr: L, bl: D, br: R, tex: g, writingMode: e.writingMode, glyphOffset: E, sectionIndex: y.sectionIndex, isSDF: v, pixelOffsetTL: G, pixelOffsetBR: Z, minFontScaleX: 0, minFontScaleY: 0 }) } } return h }(0, i, l, a, o, s, r, t.allowVerticalPlacement), g = t.textSizeData, _ = null; "source" === g.kind ? (_ = [128 * a.layout.get("text-size").evaluate(s, {})])[0] > 32640 && M(t.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === g.kind && ((_ = [128 * d.compositeTextSizes[0].evaluate(s, {}, m), 128 * d.compositeTextSizes[1].evaluate(s, {}, m)])[0] > 32640 || _[1] > 32640) && M(t.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t.addSymbols(t.text, y, _, l, o, s, h, e, u.lineStartIndex, u.lineLength, f, m); for (var v = 0, x = c; v < x.length; v += 1)p[x[v]] = t.text.placedSymbolArray.length - 1; return 4 * y.length } function lu(t) { for (var e in t) return t[e]; return null } function uu(t, e, i, r) { var n = t.compareText; if (e in n) { for (var a = n[e], o = a.length - 1; o >= 0; o--)if (r.dist(a[o]) < i) return !0 } else n[e] = []; return n[e].push(r), !1 } var hu = xs.VectorTileFeature.types, cu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function pu(t, e, i, r, n, a, o, s, l, u, h, c, p) { var f = s ? Math.min(32640, Math.round(s[0])) : 0, d = s ? Math.min(32640, Math.round(s[1])) : 0; t.emplaceBack(e, i, Math.round(32 * r), Math.round(32 * n), a, o, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * h, 256 * c, 256 * p) } function fu(t, e, i) { t.emplaceBack(e.x, e.y, i), t.emplaceBack(e.x, e.y, i), t.emplaceBack(e.x, e.y, i), t.emplaceBack(e.x, e.y, i) } function du(t) { for (var e = 0, i = t.sections; e < i.length; e += 1)if ($r(i[e].text)) return !0; return !1 } var mu = function (t) { this.layoutVertexArray = new Dn, this.indexArray = new Vn, this.programConfigurations = t, this.segments = new sa, this.dynamicLayoutVertexArray = new Rn, this.opacityVertexArray = new Bn, this.placedSymbolArray = new Qn }; mu.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length }, mu.prototype.upload = function (t, e, i, r) { this.isEmpty() || (i && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Vs.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, js.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, cu, !0), this.opacityVertexBuffer.itemSize = 1), (i || r) && this.programConfigurations.upload(t)) }, mu.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()) }, Or("SymbolBuffers", mu); var yu = function (t, e, i) { this.layoutVertexArray = new t, this.layoutAttributes = e, this.indexArray = new i, this.segments = new sa, this.collisionVertexArray = new Nn }; yu.prototype.upload = function (t) { this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, qs.members, !0) }, yu.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()) }, Or("CollisionBuffers", yu); var gu = function (t) { this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((function (t) { return t.id })), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = oo([]), this.placementViewportMatrix = oo([]); var e = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Bl(this.zoom, e["text-size"]), this.iconSizeData = Bl(this.zoom, e["icon-size"]); var i = this.layers[0].layout, r = i.get("symbol-sort-key"), n = i.get("symbol-z-order"); this.canOverlap = i.get("text-allow-overlap") || i.get("icon-allow-overlap") || i.get("text-ignore-placement") || i.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== n && void 0 !== r.constantOr(1), this.sortFeaturesByY = ("viewport-y" === n || "auto" === n && !this.sortFeaturesByKey) && this.canOverlap, "point" === i.get("symbol-placement") && (this.writingModes = i.get("text-writing-mode").map((function (t) { return bl[t] }))), this.stateDependentLayerIds = this.layers.filter((function (t) { return t.isStateDependent() })).map((function (t) { return t.id })), this.sourceID = t.sourceID }; gu.prototype.createArrays = function () { this.text = new mu(new Da(this.layers, this.zoom, (function (t) { return /^text/.test(t) }))), this.icon = new mu(new Da(this.layers, this.zoom, (function (t) { return /^icon/.test(t) }))), this.glyphOffsetArray = new ia, this.lineVertexArray = new ra, this.symbolInstances = new ea }, gu.prototype.calculateGlyphDependencies = function (t, e, i, r, n) { for (var a = 0; a < t.length; a++)if (e[t.charCodeAt(a)] = !0, (i || r) && n) { var o = Ws[t.charAt(a)]; o && (e[o.charCodeAt(0)] = !0) } }, gu.prototype.populate = function (t, e, i) { var r = this.layers[0], n = r.layout, a = n.get("text-font"), o = n.get("text-field"), s = n.get("icon-image"), l = ("constant" !== o.value.kind || o.value.value instanceof re && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), u = "constant" !== s.value.kind || !!s.value.value || Object.keys(s.parameters).length > 0, h = n.get("symbol-sort-key"); if (this.features = [], l || u) { for (var c = e.iconDependencies, p = e.glyphDependencies, f = e.availableImages, d = new sn(this.zoom), m = 0, y = t; m < y.length; m += 1) { var g = y[m], _ = g.feature, v = g.id, x = g.index, b = g.sourceLayerIndex, w = r._featureFilter.needGeometry, M = Na(_, w); if (r._featureFilter.filter(d, M, i)) { w || (M.geometry = Ua(_)); var S = void 0; if (l) { var E = r.getValueAndResolveTokens("text-field", M, i, f), I = re.factory(E); du(I) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === nn() || this.hasRTLText && on.isParsed()) && (S = Xs(I, r, M)) } var T = void 0; if (u) { var A = r.getValueAndResolveTokens("icon-image", M, i, f); T = A instanceof ne ? A : ne.fromString(A) } if (S || T) { var P = this.sortFeaturesByKey ? h.evaluate(M, {}, i) : void 0; if (this.features.push({ id: v, text: S, icon: T, index: x, sourceLayerIndex: b, geometry: M.geometry, properties: _.properties, type: hu[_.type], sortKey: P }), T && (c[T.name] = !0), S) { var C = a.evaluate(M, {}, i).join(","), z = "map" === n.get("text-rotation-alignment") && "point" !== n.get("symbol-placement"); this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(bl.vertical) >= 0; for (var k = 0, L = S.sections; k < L.length; k += 1) { var D = L[k]; if (D.image) c[D.image.name] = !0; else { var R = Zr(S.toString()), B = D.fontStack || C, O = p[B] = p[B] || {}; this.calculateGlyphDependencies(D.text, O, z, this.allowVerticalPlacement, R) } } } } } } "line" === n.get("symbol-placement") && (this.features = function (t) { var e = {}, i = {}, r = [], n = 0; function a(e) { r.push(t[e]), n++ } function o(t, e, n) { var a = i[t]; return delete i[t], i[e] = a, r[a].geometry[0].pop(), r[a].geometry[0] = r[a].geometry[0].concat(n[0]), a } function s(t, i, n) { var a = e[i]; return delete e[i], e[t] = a, r[a].geometry[0].shift(), r[a].geometry[0] = n[0].concat(r[a].geometry[0]), a } function l(t, e, i) { var r = i ? e[0][e[0].length - 1] : e[0][0]; return t + ":" + r.x + ":" + r.y } for (var u = 0; u < t.length; u++) { var h = t[u], c = h.geometry, p = h.text ? h.text.toString() : null; if (p) { var f = l(p, c), d = l(p, c, !0); if (f in i && d in e && i[f] !== e[d]) { var m = s(f, d, c), y = o(f, d, r[m].geometry); delete e[f], delete i[d], i[l(p, r[y].geometry, !0)] = y, r[m].geometry = null } else f in i ? o(f, d, c) : d in e ? s(f, d, c) : (a(u), e[f] = n - 1, i[d] = n - 1) } else a(u) } return r.filter((function (t) { return t.geometry })) }(this.features)), this.sortFeaturesByKey && this.features.sort((function (t, e) { return t.sortKey - e.sortKey })) } }, gu.prototype.update = function (t, e, i) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, i), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, i)) }, gu.prototype.isEmpty = function () { return 0 === this.symbolInstances.length && !this.hasRTLText }, gu.prototype.uploadPending = function () { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload }, gu.prototype.upload = function (t) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 }, gu.prototype.destroyDebugData = function () { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy() }, gu.prototype.destroy = function () { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData() }, gu.prototype.addToLineVertexArray = function (t, e) { var i = this.lineVertexArray.length; if (void 0 !== t.segment) { for (var r = t.dist(e[t.segment + 1]), n = t.dist(e[t.segment]), a = {}, o = t.segment + 1; o < e.length; o++)a[o] = { x: e[o].x, y: e[o].y, tileUnitDistanceFromAnchor: r }, o < e.length - 1 && (r += e[o + 1].dist(e[o])); for (var s = t.segment || 0; s >= 0; s--)a[s] = { x: e[s].x, y: e[s].y, tileUnitDistanceFromAnchor: n }, s > 0 && (n += e[s - 1].dist(e[s])); for (var l = 0; l < e.length; l++) { var u = a[l]; this.lineVertexArray.emplaceBack(u.x, u.y, u.tileUnitDistanceFromAnchor) } } return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i } }, gu.prototype.addSymbols = function (t, e, i, r, n, a, o, s, l, u, h, c) { for (var p = t.indexArray, f = t.layoutVertexArray, d = t.segments.prepareSegment(4 * e.length, f, p, this.canOverlap ? a.sortKey : void 0), m = this.glyphOffsetArray.length, y = d.vertexLength, g = this.allowVerticalPlacement && o === bl.vertical ? Math.PI / 2 : 0, _ = a.text && a.text.sections, v = 0; v < e.length; v++) { var x = e[v], b = x.tl, w = x.tr, M = x.bl, S = x.br, E = x.tex, I = x.pixelOffsetTL, T = x.pixelOffsetBR, A = x.minFontScaleX, P = x.minFontScaleY, C = x.glyphOffset, z = x.isSDF, k = x.sectionIndex, L = d.vertexLength, D = C[1]; pu(f, s.x, s.y, b.x, D + b.y, E.x, E.y, i, z, I.x, I.y, A, P), pu(f, s.x, s.y, w.x, D + w.y, E.x + E.w, E.y, i, z, T.x, I.y, A, P), pu(f, s.x, s.y, M.x, D + M.y, E.x, E.y + E.h, i, z, I.x, T.y, A, P), pu(f, s.x, s.y, S.x, D + S.y, E.x + E.w, E.y + E.h, i, z, T.x, T.y, A, P), fu(t.dynamicLayoutVertexArray, s, g), p.emplaceBack(L, L + 1, L + 2), p.emplaceBack(L + 1, L + 2, L + 3), d.vertexLength += 4, d.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(C[0]), v !== e.length - 1 && k === e[v + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, a, a.index, {}, c, _ && _[k]) } t.placedSymbolArray.emplaceBack(s.x, s.y, m, this.glyphOffsetArray.length - m, y, l, u, s.segment, i ? i[0] : 0, i ? i[1] : 0, r[0], r[1], o, 0, !1, 0, h) }, gu.prototype._addCollisionDebugVertex = function (t, e, i, r, n, a) { return e.emplaceBack(0, 0), t.emplaceBack(i.x, i.y, r, n, Math.round(a.x), Math.round(a.y)) }, gu.prototype.addCollisionDebugVertices = function (t, e, i, r, a, o, s) { var l = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray), u = l.vertexLength, h = a.layoutVertexArray, c = a.collisionVertexArray, p = s.anchorX, f = s.anchorY; this._addCollisionDebugVertex(h, c, o, p, f, new n(t, e)), this._addCollisionDebugVertex(h, c, o, p, f, new n(i, e)), this._addCollisionDebugVertex(h, c, o, p, f, new n(i, r)), this._addCollisionDebugVertex(h, c, o, p, f, new n(t, r)), l.vertexLength += 4; var d = a.indexArray; d.emplaceBack(u, u + 1), d.emplaceBack(u + 1, u + 2), d.emplaceBack(u + 2, u + 3), d.emplaceBack(u + 3, u), l.primitiveLength += 4 }, gu.prototype.addDebugCollisionBoxes = function (t, e, i, r) { for (var n = t; n < e; n++) { var a = this.collisionBoxArray.get(n); this.addCollisionDebugVertices(a.x1, a.y1, a.x2, a.y2, r ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, i) } }, gu.prototype.generateCollisionDebugBuffers = function () { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new yu(Fn, Gs.members, Wn), this.iconCollisionBox = new yu(Fn, Gs.members, Wn); for (var t = 0; t < this.symbolInstances.length; t++) { var e = this.symbolInstances.get(t); this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1) } }, gu.prototype._deserializeCollisionBoxesForSymbol = function (t, e, i, r, n, a, o, s, l) { for (var u = {}, h = e; h < i; h++) { var c = t.get(h); u.textBox = { x1: c.x1, y1: c.y1, x2: c.x2, y2: c.y2, anchorPointX: c.anchorPointX, anchorPointY: c.anchorPointY }, u.textFeatureIndex = c.featureIndex; break } for (var p = r; p < n; p++) { var f = t.get(p); u.verticalTextBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, u.verticalTextFeatureIndex = f.featureIndex; break } for (var d = a; d < o; d++) { var m = t.get(d); u.iconBox = { x1: m.x1, y1: m.y1, x2: m.x2, y2: m.y2, anchorPointX: m.anchorPointX, anchorPointY: m.anchorPointY }, u.iconFeatureIndex = m.featureIndex; break } for (var y = s; y < l; y++) { var g = t.get(y); u.verticalIconBox = { x1: g.x1, y1: g.y1, x2: g.x2, y2: g.y2, anchorPointX: g.anchorPointX, anchorPointY: g.anchorPointY }, u.verticalIconFeatureIndex = g.featureIndex; break } return u }, gu.prototype.deserializeCollisionBoxes = function (t) { this.collisionArrays = []; for (var e = 0; e < this.symbolInstances.length; e++) { var i = this.symbolInstances.get(e); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex)) } }, gu.prototype.hasTextData = function () { return this.text.segments.get().length > 0 }, gu.prototype.hasIconData = function () { return this.icon.segments.get().length > 0 }, gu.prototype.hasDebugData = function () { return this.textCollisionBox && this.iconCollisionBox }, gu.prototype.hasTextCollisionBoxData = function () { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 }, gu.prototype.hasIconCollisionBoxData = function () { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 }, gu.prototype.addIndicesForPlacedSymbol = function (t, e) { for (var i = t.placedSymbolArray.get(e), r = i.vertexStartIndex + 4 * i.numGlyphs, n = i.vertexStartIndex; n < r; n += 4)t.indexArray.emplaceBack(n, n + 1, n + 2), t.indexArray.emplaceBack(n + 1, n + 2, n + 3) }, gu.prototype.getSortedSymbolIndexes = function (t) { if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes; for (var e = Math.sin(t), i = Math.cos(t), r = [], n = [], a = [], o = 0; o < this.symbolInstances.length; ++o) { a.push(o); var s = this.symbolInstances.get(o); r.push(0 | Math.round(e * s.anchorX + i * s.anchorY)), n.push(s.featureIndex) } return a.sort((function (t, e) { return r[t] - r[e] || n[e] - n[t] })), a }, gu.prototype.addToSortKeyRanges = function (t, e) { var i = this.sortKeyRanges[this.sortKeyRanges.length - 1]; i && i.sortKey === e ? i.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: e, symbolInstanceStart: t, symbolInstanceEnd: t + 1 }) }, gu.prototype.sortFeatures = function (t) { var e = this; if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (var i = 0, r = this.symbolInstanceIndexes; i < r.length; i += 1) { var n = this.symbolInstances.get(r[i]); this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach((function (t, i, r) { t >= 0 && r.indexOf(t) === i && e.addIndicesForPlacedSymbol(e.text, t) })), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } }, Or("SymbolBucket", gu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), gu.MAX_GLYPHS = 65535, gu.addDynamicAttributes = fu; var _u = new bn({ "symbol-placement": new yn(Pt.layout_symbol["symbol-placement"]), "symbol-spacing": new yn(Pt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new yn(Pt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new gn(Pt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new yn(Pt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new yn(Pt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new yn(Pt.layout_symbol["icon-ignore-placement"]), "icon-optional": new yn(Pt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new yn(Pt.layout_symbol["icon-rotation-alignment"]), "icon-size": new gn(Pt.layout_symbol["icon-size"]), "icon-text-fit": new yn(Pt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new yn(Pt.layout_symbol["icon-text-fit-padding"]), "icon-image": new gn(Pt.layout_symbol["icon-image"]), "icon-rotate": new gn(Pt.layout_symbol["icon-rotate"]), "icon-padding": new yn(Pt.layout_symbol["icon-padding"]), "icon-keep-upright": new yn(Pt.layout_symbol["icon-keep-upright"]), "icon-offset": new gn(Pt.layout_symbol["icon-offset"]), "icon-anchor": new gn(Pt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new yn(Pt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new yn(Pt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new yn(Pt.layout_symbol["text-rotation-alignment"]), "text-field": new gn(Pt.layout_symbol["text-field"]), "text-font": new gn(Pt.layout_symbol["text-font"]), "text-size": new gn(Pt.layout_symbol["text-size"]), "text-max-width": new gn(Pt.layout_symbol["text-max-width"]), "text-line-height": new yn(Pt.layout_symbol["text-line-height"]), "text-letter-spacing": new gn(Pt.layout_symbol["text-letter-spacing"]), "text-justify": new gn(Pt.layout_symbol["text-justify"]), "text-radial-offset": new gn(Pt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new yn(Pt.layout_symbol["text-variable-anchor"]), "text-anchor": new gn(Pt.layout_symbol["text-anchor"]), "text-max-angle": new yn(Pt.layout_symbol["text-max-angle"]), "text-writing-mode": new yn(Pt.layout_symbol["text-writing-mode"]), "text-rotate": new gn(Pt.layout_symbol["text-rotate"]), "text-padding": new yn(Pt.layout_symbol["text-padding"]), "text-keep-upright": new yn(Pt.layout_symbol["text-keep-upright"]), "text-transform": new gn(Pt.layout_symbol["text-transform"]), "text-offset": new gn(Pt.layout_symbol["text-offset"]), "text-allow-overlap": new yn(Pt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new yn(Pt.layout_symbol["text-ignore-placement"]), "text-optional": new yn(Pt.layout_symbol["text-optional"]) }), vu = { paint: new bn({ "icon-opacity": new gn(Pt.paint_symbol["icon-opacity"]), "icon-color": new gn(Pt.paint_symbol["icon-color"]), "icon-halo-color": new gn(Pt.paint_symbol["icon-halo-color"]), "icon-halo-width": new gn(Pt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new gn(Pt.paint_symbol["icon-halo-blur"]), "icon-translate": new yn(Pt.paint_symbol["icon-translate"]), "icon-translate-anchor": new yn(Pt.paint_symbol["icon-translate-anchor"]), "text-opacity": new gn(Pt.paint_symbol["text-opacity"]), "text-color": new gn(Pt.paint_symbol["text-color"], { runtimeType: Vt, getOverride: function (t) { return t.textColor }, hasOverride: function (t) { return !!t.textColor } }), "text-halo-color": new gn(Pt.paint_symbol["text-halo-color"]), "text-halo-width": new gn(Pt.paint_symbol["text-halo-width"]), "text-halo-blur": new gn(Pt.paint_symbol["text-halo-blur"]), "text-translate": new yn(Pt.paint_symbol["text-translate"]), "text-translate-anchor": new yn(Pt.paint_symbol["text-translate-anchor"]) }), layout: _u }, xu = function (t) { this.type = t.property.overrides ? t.property.overrides.runtimeType : Ot, this.defaultValue = t }; xu.prototype.evaluate = function (t) { if (t.formattedSection) { var e = this.defaultValue.property.overrides; if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection) } return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default }, xu.prototype.eachChild = function (t) { this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression) }, xu.prototype.outputDefined = function () { return !1 }, xu.prototype.serialize = function () { return null }, Or("FormatSectionOverride", xu, { omit: ["defaultValue"] }); var bu = function (t) { function e(e) { t.call(this, e, vu) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, i) { if (t.prototype.recalculate.call(this, e, i), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) { var r = this.layout.get("text-writing-mode"); if (r) { for (var n = [], a = 0, o = r; a < o.length; a += 1) { var s = o[a]; n.indexOf(s) < 0 && n.push(s) } this.layout._values["text-writing-mode"] = n } else this.layout._values["text-writing-mode"] = ["horizontal"] } this._setPaintOverrides() }, e.prototype.getValueAndResolveTokens = function (t, e, i, r) { var n = this.layout.get(t).evaluate(e, {}, i, r), a = this._unevaluatedLayout._values[t]; return a.isDataDriven() || Zi(a.value) || !n ? n : function (t, e) { return e.replace(/{([^{}]+)}/g, (function (e, i) { return i in t ? String(t[i]) : "" })) }(e.properties, n) }, e.prototype.createBucket = function (t) { return new gu(t) }, e.prototype.queryRadius = function () { return 0 }, e.prototype.queryIntersectsFeature = function () { return !1 }, e.prototype._setPaintOverrides = function () { for (var t = 0, i = vu.paint.overridableProperties; t < i.length; t += 1) { var r = i[t]; if (e.hasPaintOverride(this.layout, r)) { var n, a = this.paint.get(r), o = new xu(a), s = new Gi(o, a.property.specification); n = "constant" === a.value.kind || "source" === a.value.kind ? new Wi("source", s) : new Ki("composite", s, a.value.zoomStops, a.value._interpolationType), this.paint._values[r] = new dn(a.property, n, a.parameters) } } }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, i, r) { return !(!this.layout || i.isDataDriven() || r.isDataDriven()) && e.hasPaintOverride(this.layout, t) }, e.hasPaintOverride = function (t, e) { var i = t.get("text-field"), r = vu.paint.properties[e], n = !1, a = function (t) { for (var e = 0, i = t; e < i.length; e += 1)if (r.overrides && r.overrides.hasOverride(i[e])) return void (n = !0) }; if ("constant" === i.value.kind && i.value.value instanceof re) a(i.value.value.sections); else if ("source" === i.value.kind) { var o = function (t) { n || (t instanceof ue && se(t.value) === Zt ? a(t.value.sections) : t instanceof fe ? a(t.sections) : t.eachChild(o)) }, s = i.value; s._styleExpression && o(s._styleExpression.expression) } return n }, e }(wn), wu = { paint: new bn({ "background-color": new yn(Pt.paint_background["background-color"]), "background-pattern": new vn(Pt.paint_background["background-pattern"]), "background-opacity": new yn(Pt.paint_background["background-opacity"]) }) }, Mu = function (t) { function e(e) { t.call(this, e, wu) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(wn), Su = { paint: new bn({ "raster-opacity": new yn(Pt.paint_raster["raster-opacity"]), "raster-hue-rotate": new yn(Pt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new yn(Pt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new yn(Pt.paint_raster["raster-brightness-max"]), "raster-saturation": new yn(Pt.paint_raster["raster-saturation"]), "raster-contrast": new yn(Pt.paint_raster["raster-contrast"]), "raster-resampling": new yn(Pt.paint_raster["raster-resampling"]), "raster-fade-duration": new yn(Pt.paint_raster["raster-fade-duration"]) }) }, Eu = function (t) { function e(e) { t.call(this, e, Su) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(wn), Iu = function (t) { function e(e) { t.call(this, e, {}), this.implementation = e } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.is3D = function () { return "3d" === this.implementation.renderingMode }, e.prototype.hasOffscreenPass = function () { return void 0 !== this.implementation.prerender }, e.prototype.recalculate = function () { }, e.prototype.updateTransitions = function () { }, e.prototype.hasTransition = function () { }, e.prototype.serialize = function () { }, e.prototype.onAdd = function (t) { this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl) }, e.prototype.onRemove = function (t) { this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl) }, e }(wn), Tu = { circle: co, heatmap: wo, hillshade: So, fill: hs, "fill-extrusion": Ts, line: Us, symbol: bu, background: Mu, raster: Eu }, Au = o.HTMLImageElement, Pu = o.HTMLCanvasElement, Cu = o.HTMLVideoElement, zu = o.ImageData, ku = o.ImageBitmap, Lu = function (t, e, i, r) { this.context = t, this.format = i, this.texture = t.gl.createTexture(), this.update(e, r) }; Lu.prototype.update = function (t, e, i) { var r = t.width, n = t.height, a = !(this.size && this.size[0] === r && this.size[1] === n || i), o = this.context, s = o.gl; if (this.useMipmap = Boolean(e && e.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), a) this.size = [r, n], t instanceof Au || t instanceof Pu || t instanceof Cu || t instanceof zu || ku && t instanceof ku ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, t) : s.texImage2D(s.TEXTURE_2D, 0, this.format, r, n, 0, this.format, s.UNSIGNED_BYTE, t.data); else { var l = i || { x: 0, y: 0 }, u = l.x, h = l.y; t instanceof Au || t instanceof Pu || t instanceof Cu || t instanceof zu || ku && t instanceof ku ? s.texSubImage2D(s.TEXTURE_2D, 0, u, h, s.RGBA, s.UNSIGNED_BYTE, t) : s.texSubImage2D(s.TEXTURE_2D, 0, u, h, r, n, s.RGBA, s.UNSIGNED_BYTE, t.data) } this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D) }, Lu.prototype.bind = function (t, e, i) { var r = this.context.gl; r.bindTexture(r.TEXTURE_2D, this.texture), i !== r.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i = r.LINEAR), t !== this.filter && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, i || t), this.filter = t), e !== this.wrap && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, e), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, e), this.wrap = e) }, Lu.prototype.isSizePowerOfTwo = function () { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 }, Lu.prototype.destroy = function () { this.context.gl.deleteTexture(this.texture), this.texture = null }; var Du = function (t) { var e = this; this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = function () { e._triggered = !1, e._callback() }) }; Du.prototype.trigger = function () { var t = this; this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((function () { t._triggered = !1, t._callback() }), 0)) }, Du.prototype.remove = function () { delete this._channel, this._callback = function () { } }; var Ru = function (t, e, i) { this.target = t, this.parent = e, this.mapId = i, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, g(["receive", "process"], this), this.invoker = new Du(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = I() ? t : o }; function Bu(t, e, i) { var r = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i); return [t * r - 2 * Math.PI * 6378137 / 2, e * r - 2 * Math.PI * 6378137 / 2] } Ru.prototype.send = function (t, e, i, r, n) { var a = this; void 0 === n && (n = !1); var o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10); i && (this.callbacks[o] = i); var s = P(this.globalScope) ? void 0 : []; return this.target.postMessage({ id: o, type: t, hasCallback: !!i, targetMapId: r, mustQueue: n, sourceMapId: this.mapId, data: Vr(e, s) }, s), { cancel: function () { i && delete a.callbacks[o], a.target.postMessage({ id: o, type: "<cancel>", targetMapId: r, sourceMapId: a.mapId }) } } }, Ru.prototype.receive = function (t) { var e = t.data, i = e.id; if (i && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) { delete this.tasks[i]; var r = this.cancelCallbacks[i]; delete this.cancelCallbacks[i], r && r() } else I() || e.mustQueue ? (this.tasks[i] = e, this.taskQueue.push(i), this.invoker.trigger()) : this.processTask(i, e) }, Ru.prototype.process = function () { if (this.taskQueue.length) { var t = this.taskQueue.shift(), e = this.tasks[t]; delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e) } }, Ru.prototype.processTask = function (t, e) { var i = this; if ("<response>" === e.type) { var r = this.callbacks[t]; delete this.callbacks[t], r && (e.error ? r(jr(e.error)) : r(null, jr(e.data))) } else { var n = !1, a = P(this.globalScope) ? void 0 : [], o = e.hasCallback ? function (e, r) { n = !0, delete i.cancelCallbacks[t], i.target.postMessage({ id: t, type: "<response>", sourceMapId: i.mapId, error: e ? Vr(e) : null, data: Vr(r, a) }, a) } : function (t) { n = !0 }, s = null, l = jr(e.data); if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, l, o); else if (this.parent.getWorkerSource) { var u = e.type.split("."); s = this.parent.getWorkerSource(e.sourceMapId, u[0], l.source)[u[1]](l, o) } else o(new Error("Could not find function " + e.type)); !n && s && s.cancel && (this.cancelCallbacks[t] = s.cancel) } }, Ru.prototype.remove = function () { this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1) }; var Ou = function (t, e) { t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])) }; Ou.prototype.setNorthEast = function (t) { return this._ne = t instanceof Fu ? new Fu(t.lng, t.lat) : Fu.convert(t), this }, Ou.prototype.setSouthWest = function (t) { return this._sw = t instanceof Fu ? new Fu(t.lng, t.lat) : Fu.convert(t), this }, Ou.prototype.extend = function (t) { var e, i, r = this._sw, n = this._ne; if (t instanceof Fu) e = t, i = t; else { if (!(t instanceof Ou)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Ou.convert(t)) : this.extend(Fu.convert(t)) : this; if (i = t._ne, !(e = t._sw) || !i) return this } return r || n ? (r.lng = Math.min(e.lng, r.lng), r.lat = Math.min(e.lat, r.lat), n.lng = Math.max(i.lng, n.lng), n.lat = Math.max(i.lat, n.lat)) : (this._sw = new Fu(e.lng, e.lat), this._ne = new Fu(i.lng, i.lat)), this }, Ou.prototype.getCenter = function () { return new Fu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) }, Ou.prototype.getSouthWest = function () { return this._sw }, Ou.prototype.getNorthEast = function () { return this._ne }, Ou.prototype.getNorthWest = function () { return new Fu(this.getWest(), this.getNorth()) }, Ou.prototype.getSouthEast = function () { return new Fu(this.getEast(), this.getSouth()) }, Ou.prototype.getWest = function () { return this._sw.lng }, Ou.prototype.getSouth = function () { return this._sw.lat }, Ou.prototype.getEast = function () { return this._ne.lng }, Ou.prototype.getNorth = function () { return this._ne.lat }, Ou.prototype.toArray = function () { return [this._sw.toArray(), this._ne.toArray()] }, Ou.prototype.toString = function () { return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")" }, Ou.prototype.isEmpty = function () { return !(this._sw && this._ne) }, Ou.prototype.contains = function (t) { var e = Fu.convert(t), i = e.lng, r = e.lat, n = this._sw.lng <= i && i <= this._ne.lng; return this._sw.lng > this._ne.lng && (n = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n }, Ou.convert = function (t) { return !t || t instanceof Ou ? t : new Ou(t) }; var Fu = function (t, e) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")"); if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") }; Fu.prototype.wrap = function () { return new Fu(c(this.lng, -180, 180), this.lat) }, Fu.prototype.toArray = function () { return [this.lng, this.lat] }, Fu.prototype.toString = function () { return "LngLat(" + this.lng + ", " + this.lat + ")" }, Fu.prototype.distanceTo = function (t) { var e = Math.PI / 180, i = this.lat * e, r = t.lat * e, n = Math.sin(i) * Math.sin(r) + Math.cos(i) * Math.cos(r) * Math.cos((t.lng - this.lng) * e); return 6371008.8 * Math.acos(Math.min(n, 1)) }, Fu.prototype.toBounds = function (t) { void 0 === t && (t = 0); var e = 360 * t / 40075017, i = e / Math.cos(Math.PI / 180 * this.lat); return new Ou(new Fu(this.lng - i, this.lat - e), new Fu(this.lng + i, this.lat + e)) }, Fu.convert = function (t) { if (t instanceof Fu) return t; if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Fu(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Fu(Number("lng" in t ? t.lng : t.lon), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") }; var Uu = 2 * Math.PI * 6371008.8; function Nu(t) { return Uu * Math.cos(t * Math.PI / 180) } function Vu(t) { return (180 + t) / 360 } function ju(t) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360 } function qu(t, e) { return t / Nu(e) } function Gu(t) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90 } var Zu = function (t, e, i) { void 0 === i && (i = 0), this.x = +t, this.y = +e, this.z = +i }; Zu.fromLngLat = function (t, e) { void 0 === e && (e = 0); var i = Fu.convert(t); return new Zu(Vu(i.lng), ju(i.lat), qu(e, i.lat)) }, Zu.prototype.toLngLat = function () { return new Fu(360 * this.x - 180, Gu(this.y)) }, Zu.prototype.toAltitude = function () { return this.z * Nu(Gu(this.y)) }, Zu.prototype.meterInMercatorCoordinateUnits = function () { return 1 / Uu * (t = Gu(this.y), 1 / Math.cos(t * Math.PI / 180)); var t }; var Xu = function (t, e, i) { this.z = t, this.x = e, this.y = i, this.key = Hu(0, t, t, e, i) }; Xu.prototype.equals = function (t) { return this.z === t.z && this.x === t.x && this.y === t.y }, Xu.prototype.url = function (t, e) { var i, r, n, a, o, s = (r = this.y, n = this.z, a = Bu(256 * (i = this.x), 256 * (r = Math.pow(2, n) - r - 1), n), o = Bu(256 * (i + 1), 256 * (r + 1), n), a[0] + "," + a[1] + "," + o[0] + "," + o[1]), l = function (t, e, i) { for (var r, n = "", a = t; a > 0; a--)n += (e & (r = 1 << a - 1) ? 1 : 0) + (i & r ? 2 : 0); return n }(this.z, this.x, this.y); return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", l).replace("{bbox-epsg-3857}", s) }, Xu.prototype.getTilePoint = function (t) { var e = Math.pow(2, this.z); return new n(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y)) }, Xu.prototype.toString = function () { return this.z + "/" + this.x + "/" + this.y }; var Wu = function (t, e) { this.wrap = t, this.canonical = e, this.key = Hu(t, e.z, e.z, e.x, e.y) }, Ku = function (t, e, i, r, n) { this.overscaledZ = t, this.wrap = e, this.canonical = new Xu(i, +r, +n), this.key = Hu(e, t, i, r, n) }; function Hu(t, e, i, r, n) { (t *= 2) < 0 && (t = -1 * t - 1); var a = 1 << i; return (a * a * t + a * n + r).toString(36) + i.toString(36) + e.toString(36) } Ku.prototype.equals = function (t) { return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical) }, Ku.prototype.scaledTo = function (t) { var e = this.canonical.z - t; return t > this.canonical.z ? new Ku(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ku(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e) }, Ku.prototype.calculateScaledKey = function (t, e) { var i = this.canonical.z - t; return t > this.canonical.z ? Hu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : Hu(this.wrap * +e, t, t, this.canonical.x >> i, this.canonical.y >> i) }, Ku.prototype.isChildOf = function (t) { if (t.wrap !== this.wrap) return !1; var e = this.canonical.z - t.canonical.z; return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e }, Ku.prototype.children = function (t) { if (this.overscaledZ >= t) return [new Ku(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; var e = this.canonical.z + 1, i = 2 * this.canonical.x, r = 2 * this.canonical.y; return [new Ku(e, this.wrap, e, i, r), new Ku(e, this.wrap, e, i + 1, r), new Ku(e, this.wrap, e, i, r + 1), new Ku(e, this.wrap, e, i + 1, r + 1)] }, Ku.prototype.isLessThan = function (t) { return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)) }, Ku.prototype.wrapped = function () { return new Ku(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) }, Ku.prototype.unwrapTo = function (t) { return new Ku(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y) }, Ku.prototype.overscaleFactor = function () { return Math.pow(2, this.overscaledZ - this.canonical.z) }, Ku.prototype.toUnwrapped = function () { return new Wu(this.wrap, this.canonical) }, Ku.prototype.toString = function () { return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y }, Ku.prototype.getTilePoint = function (t) { return this.canonical.getTilePoint(new Zu(t.x - this.wrap, t.y)) }, Or("CanonicalTileID", Xu), Or("OverscaledTileID", Ku, { omit: ["posMatrix"] }); var $u = function (t, e, i) { if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square"); if (i && "mapbox" !== i && "terrarium" !== i) return M('"' + i + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'); this.stride = e.height; var r = this.dim = e.height - 2; this.data = new Uint32Array(e.data.buffer), this.encoding = i || "mapbox"; for (var n = 0; n < r; n++)this.data[this._idx(-1, n)] = this.data[this._idx(0, n)], this.data[this._idx(r, n)] = this.data[this._idx(r - 1, n)], this.data[this._idx(n, -1)] = this.data[this._idx(n, 0)], this.data[this._idx(n, r)] = this.data[this._idx(n, r - 1)]; this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(r, -1)] = this.data[this._idx(r - 1, 0)], this.data[this._idx(-1, r)] = this.data[this._idx(0, r - 1)], this.data[this._idx(r, r)] = this.data[this._idx(r - 1, r - 1)] }; $u.prototype.get = function (t, e) { var i = new Uint8Array(this.data.buffer), r = 4 * this._idx(t, e); return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(i[r], i[r + 1], i[r + 2]) }, $u.prototype.getUnpackVector = function () { return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4] }, $u.prototype._idx = function (t, e) { if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data"); return (e + 1) * this.stride + (t + 1) }, $u.prototype._unpackMapbox = function (t, e, i) { return (256 * t * 256 + 256 * e + i) / 10 - 1e4 }, $u.prototype._unpackTerrarium = function (t, e, i) { return 256 * t + e + i / 256 - 32768 }, $u.prototype.getPixels = function () { return new vo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer)) }, $u.prototype.backfillBorder = function (t, e, i) { if (this.dim !== t.dim) throw new Error("dem dimension mismatch"); var r = e * this.dim, n = e * this.dim + this.dim, a = i * this.dim, o = i * this.dim + this.dim; switch (e) { case -1: r = n - 1; break; case 1: n = r + 1 }switch (i) { case -1: a = o - 1; break; case 1: o = a + 1 }for (var s = -e * this.dim, l = -i * this.dim, u = a; u < o; u++)for (var h = r; h < n; h++)this.data[this._idx(h, u)] = t.data[this._idx(h + s, u + l)] }, Or("DEMData", $u); var Ju = function (t) { this._stringToNumber = {}, this._numberToString = []; for (var e = 0; e < t.length; e++) { var i = t[e]; this._stringToNumber[i] = e, this._numberToString[e] = i } }; Ju.prototype.encode = function (t) { return this._stringToNumber[t] }, Ju.prototype.decode = function (t) { return this._numberToString[t] }; var Yu = function (t, e, i, r, n) { this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = i, t._y = r, this.properties = t.properties, this.id = n }, Qu = { geometry: { configurable: !0 } }; Qu.geometry.get = function () { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry }, Qu.geometry.set = function (t) { this._geometry = t }, Yu.prototype.toJSON = function () { var t = { geometry: this.geometry }; for (var e in this) "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]); return t }, Object.defineProperties(Yu.prototype, Qu); var th = function () { this.state = {}, this.stateChanges = {}, this.deletedStates = {} }; th.prototype.updateState = function (t, e, i) { var r = String(e); if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][r] = this.stateChanges[t][r] || {}, p(this.stateChanges[t][r], i), null === this.deletedStates[t]) for (var n in this.deletedStates[t] = {}, this.state[t]) n !== r && (this.deletedStates[t][n] = null); else if (this.deletedStates[t] && null === this.deletedStates[t][r]) for (var a in this.deletedStates[t][r] = {}, this.state[t][r]) i[a] || (this.deletedStates[t][r][a] = null); else for (var o in i) this.deletedStates[t] && this.deletedStates[t][r] && null === this.deletedStates[t][r][o] && delete this.deletedStates[t][r][o] }, th.prototype.removeFeatureState = function (t, e, i) { if (null !== this.deletedStates[t]) { var r = String(e); if (this.deletedStates[t] = this.deletedStates[t] || {}, i && void 0 !== e) null !== this.deletedStates[t][r] && (this.deletedStates[t][r] = this.deletedStates[t][r] || {}, this.deletedStates[t][r][i] = null); else if (void 0 !== e) if (this.stateChanges[t] && this.stateChanges[t][r]) for (i in this.deletedStates[t][r] = {}, this.stateChanges[t][r]) this.deletedStates[t][r][i] = null; else this.deletedStates[t][r] = null; else this.deletedStates[t] = null } }, th.prototype.getState = function (t, e) { var i = String(e), r = p({}, (this.state[t] || {})[i], (this.stateChanges[t] || {})[i]); if (null === this.deletedStates[t]) return {}; if (this.deletedStates[t]) { var n = this.deletedStates[t][e]; if (null === n) return {}; for (var a in n) delete r[a] } return r }, th.prototype.initializeTileState = function (t, e) { t.setFeatureState(this.state, e) }, th.prototype.coalesceChanges = function (t, e) { var i = {}; for (var r in this.stateChanges) { this.state[r] = this.state[r] || {}; var n = {}; for (var a in this.stateChanges[r]) this.state[r][a] || (this.state[r][a] = {}), p(this.state[r][a], this.stateChanges[r][a]), n[a] = this.state[r][a]; i[r] = n } for (var o in this.deletedStates) { this.state[o] = this.state[o] || {}; var s = {}; if (null === this.deletedStates[o]) for (var l in this.state[o]) s[l] = {}, this.state[o][l] = {}; else for (var u in this.deletedStates[o]) { if (null === this.deletedStates[o][u]) this.state[o][u] = {}; else for (var h = 0, c = Object.keys(this.deletedStates[o][u]); h < c.length; h += 1)delete this.state[o][u][c[h]]; s[u] = this.state[o][u] } i[o] = i[o] || {}, p(i[o], s) } if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i).length) for (var f in t) t[f].setFeatureState(i, e) }; var eh = function (t, e) { this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new kr(8192, 16, 0), this.grid3D = new kr(8192, 16, 0), this.featureIndexArray = new aa, this.promoteId = e }; function ih(t, e, i, r, n) { return v(t, (function (t, a) { var o = e instanceof mn ? e.get(a) : null; return o && o.evaluate ? o.evaluate(i, r, n) : o })) } function rh(t) { for (var e = 1 / 0, i = 1 / 0, r = -1 / 0, n = -1 / 0, a = 0, o = t; a < o.length; a += 1) { var s = o[a]; e = Math.min(e, s.x), i = Math.min(i, s.y), r = Math.max(r, s.x), n = Math.max(n, s.y) } return { minX: e, minY: i, maxX: r, maxY: n } } function nh(t, e) { return e - t } eh.prototype.insert = function (t, e, i, r, n, a) { var o = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(i, r, n); for (var s = a ? this.grid3D : this.grid, l = 0; l < e.length; l++) { for (var u = e[l], h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = 0; c < u.length; c++) { var p = u[c]; h[0] = Math.min(h[0], p.x), h[1] = Math.min(h[1], p.y), h[2] = Math.max(h[2], p.x), h[3] = Math.max(h[3], p.y) } h[0] < 8192 && h[1] < 8192 && h[2] >= 0 && h[3] >= 0 && s.insert(o, h[0], h[1], h[2], h[3]) } }, eh.prototype.loadVTLayers = function () { return this.vtLayers || (this.vtLayers = new xs.VectorTile(new $s(this.rawTileData)).layers, this.sourceLayerCoder = new Ju(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers }, eh.prototype.query = function (t, e, i, r) { var a = this; this.loadVTLayers(); for (var o = t.params || {}, s = 8192 / t.tileSize / t.scale, l = ar(o.filter), u = t.queryGeometry, h = t.queryPadding * s, c = rh(u), p = this.grid.query(c.minX - h, c.minY - h, c.maxX + h, c.maxY + h), f = rh(t.cameraQueryGeometry), d = 0, m = this.grid3D.query(f.minX - h, f.minY - h, f.maxX + h, f.maxY + h, (function (e, i, r, a) { return function (t, e, i, r, a) { for (var o = 0, s = t; o < s.length; o += 1) { var l = s[o]; if (e <= l.x && i <= l.y && r >= l.x && a >= l.y) return !0 } var u = [new n(e, i), new n(e, a), new n(r, a), new n(r, i)]; if (t.length > 2) for (var h = 0, c = u; h < c.length; h += 1)if (Ya(t, c[h])) return !0; for (var p = 0; p < t.length - 1; p++)if (Qa(t[p], t[p + 1], u)) return !0; return !1 }(t.cameraQueryGeometry, e - h, i - h, r + h, a + h) })); d < m.length; d += 1)p.push(m[d]); p.sort(nh); for (var y, g = {}, _ = function (n) { var h = p[n]; if (h !== y) { y = h; var c = a.featureIndexArray.get(h), f = null; a.loadMatchingFeature(g, c.bucketIndex, c.sourceLayerIndex, c.featureIndex, l, o.layers, o.availableImages, e, i, r, (function (e, i, r) { return f || (f = Ua(e)), i.queryIntersectsFeature(u, e, r, f, a.z, t.transform, s, t.pixelPosMatrix) })) } }, v = 0; v < p.length; v++)_(v); return g }, eh.prototype.loadMatchingFeature = function (t, e, i, r, n, a, o, s, l, u, h) { var c = this.bucketLayerIDs[e]; if (!a || function (t, e) { for (var i = 0; i < t.length; i++)if (e.indexOf(t[i]) >= 0) return !0; return !1 }(a, c)) { var f = this.sourceLayerCoder.decode(i), d = this.vtLayers[f].feature(r); if (n.needGeometry) { var m = Na(d, !0); if (!n.filter(new sn(this.tileID.overscaledZ), m, this.tileID.canonical)) return } else if (!n.filter(new sn(this.tileID.overscaledZ), d)) return; for (var y = this.getId(d, f), g = 0; g < c.length; g++) { var _ = c[g]; if (!(a && a.indexOf(_) < 0)) { var v = s[_]; if (v) { var x = {}; void 0 !== y && u && (x = u.getState(v.sourceLayer || "_geojsonTileLayer", y)); var b = p({}, l[_]); b.paint = ih(b.paint, v.paint, d, x, o), b.layout = ih(b.layout, v.layout, d, x, o); var w = !h || h(d, v, x); if (w) { var M = new Yu(d, this.z, this.x, this.y, y); M.layer = b; var S = t[_]; void 0 === S && (S = t[_] = []), S.push({ featureIndex: r, feature: M, intersectionZ: w }) } } } } } }, eh.prototype.lookupSymbolFeatures = function (t, e, i, r, n, a, o, s) { var l = {}; this.loadVTLayers(); for (var u = ar(n), h = 0, c = t; h < c.length; h += 1)this.loadMatchingFeature(l, i, r, c[h], u, a, o, s, e); return l }, eh.prototype.hasLayer = function (t) { for (var e = 0, i = this.bucketLayerIDs; e < i.length; e += 1)for (var r = 0, n = i[e]; r < n.length; r += 1)if (t === n[r]) return !0; return !1 }, eh.prototype.getId = function (t, e) { var i = t.id; return this.promoteId && "boolean" == typeof (i = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]]) && (i = Number(i)), i }, Or("FeatureIndex", eh, { omit: ["rawTileData", "sourceLayerCoder"] }); var ah = function (t, e) { this.tileID = t, this.uid = d(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading" }; ah.prototype.registerFadeDuration = function (t) { var e = t + this.timeAdded; e < F.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e) }, ah.prototype.wasRequested = function () { return "errored" === this.state || "loaded" === this.state || "reloading" === this.state }, ah.prototype.loadVectorData = function (t, e, i) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) { for (var r in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) { var i = {}; if (!e) return i; for (var r = function () { var t = a[n], r = t.layerIds.map((function (t) { return e.getLayer(t) })).filter(Boolean); if (0 !== r.length) { t.layers = r, t.stateDependentLayerIds && (t.stateDependentLayers = t.stateDependentLayerIds.map((function (t) { return r.filter((function (e) { return e.id === t }))[0] }))); for (var o = 0, s = r; o < s.length; o += 1)i[s[o].id] = t } }, n = 0, a = t; n < a.length; n += 1)r(); return i }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) { var n = this.buckets[r]; if (n instanceof gu) { if (this.hasSymbolBuckets = !0, !i) break; n.justReloaded = !0 } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var a in this.buckets) { var o = this.buckets[a]; if (o instanceof gu && o.hasRTLText) { this.hasRTLText = !0, on.isLoading() || on.isLoaded() || "deferred" !== nn() || an(); break } } for (var s in this.queryPadding = 0, this.buckets) { var l = this.buckets[s]; this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(s).queryRadius(l)) } t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage) } else this.collisionBoxArray = new Jn }, ah.prototype.unloadVectorData = function () { for (var t in this.buckets) this.buckets[t].destroy(); this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded" }, ah.prototype.getBucket = function (t) { return this.buckets[t.id] }, ah.prototype.upload = function (t) { for (var e in this.buckets) { var i = this.buckets[e]; i.uploadPending() && i.upload(t) } var r = t.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Lu(t, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Lu(t, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null) }, ah.prototype.prepare = function (t) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture) }, ah.prototype.queryRenderedFeatures = function (t, e, i, r, n, a, o, s, l, u) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r, cameraQueryGeometry: n, scale: a, tileSize: this.tileSize, pixelPosMatrix: u, transform: s, params: o, queryPadding: this.queryPadding * l }, t, e, i) : {} }, ah.prototype.querySourceFeatures = function (t, e) { var i = this.latestFeatureIndex; if (i && i.rawTileData) { var r = i.loadVTLayers(), n = e ? e.sourceLayer : "", a = r._geojsonTileLayer || r[n]; if (a) for (var o = ar(e && e.filter), s = this.tileID.canonical, l = s.z, u = s.x, h = s.y, c = { z: l, x: u, y: h }, p = 0; p < a.length; p++) { var f = a.feature(p); if (o.needGeometry) { var d = Na(f, !0); if (!o.filter(new sn(this.tileID.overscaledZ), d, this.tileID.canonical)) continue } else if (!o.filter(new sn(this.tileID.overscaledZ), f)) continue; var m = i.getId(f, n), y = new Yu(f, l, u, h, m); y.tile = c, t.push(y) } } }, ah.prototype.hasData = function () { return "loaded" === this.state || "reloading" === this.state || "expired" === this.state }, ah.prototype.patternsLoaded = function () { return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length }, ah.prototype.setExpiryData = function (t) { var e = this.expirationTime; if (t.cacheControl) { var i = T(t.cacheControl); i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]) } else t.expires && (this.expirationTime = new Date(t.expires).getTime()); if (this.expirationTime) { var r = Date.now(), n = !1; if (this.expirationTime > r) n = !1; else if (e) if (this.expirationTime < e) n = !0; else { var a = this.expirationTime - e; a ? this.expirationTime = r + Math.max(a, 3e4) : n = !0 } else n = !0; n ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0 } }, ah.prototype.getExpiryTimeout = function () { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1) }, ah.prototype.setFeatureState = function (t, e) { if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) { var i = this.latestFeatureIndex.loadVTLayers(); for (var r in this.buckets) if (e.style.hasLayer(r)) { var n = this.buckets[r], a = n.layers[0].sourceLayer || "_geojsonTileLayer", o = i[a], s = t[a]; if (o && s && 0 !== Object.keys(s).length) { n.update(s, o, this.imageAtlas && this.imageAtlas.patternPositions || {}); var l = e && e.style && e.style.getLayer(r); l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(n))) } } } }, ah.prototype.holdingForFade = function () { return void 0 !== this.symbolFadeHoldUntil }, ah.prototype.symbolFadeFinished = function () { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < F.now() }, ah.prototype.clearFadeHold = function () { this.symbolFadeHoldUntil = void 0 }, ah.prototype.setHoldDuration = function (t) { this.symbolFadeHoldUntil = F.now() + t }, ah.prototype.setDependencies = function (t, e) { for (var i = {}, r = 0, n = e; r < n.length; r += 1)i[n[r]] = !0; this.dependencies[t] = i }, ah.prototype.hasDependency = function (t, e) { for (var i = 0, r = t; i < r.length; i += 1) { var n = this.dependencies[r[i]]; if (n) for (var a = 0, o = e; a < o.length; a += 1)if (n[o[a]]) return !0 } return !1 }; var oh = o.performance, sh = function (t) { this._marks = { start: [t.url, "start"].join("#"), end: [t.url, "end"].join("#"), measure: t.url.toString() }, oh.mark(this._marks.start) }; sh.prototype.finish = function () { oh.mark(this._marks.end); var t = oh.getEntriesByName(this._marks.measure); return 0 === t.length && (oh.measure(this._marks.measure, this._marks.start, this._marks.end), t = oh.getEntriesByName(this._marks.measure), oh.clearMarks(this._marks.start), oh.clearMarks(this._marks.end), oh.clearMeasures(this._marks.measure)), t }, t.Actor = Ru, t.AlphaImage = _o, t.CanonicalTileID = Xu, t.CollisionBoxArray = Jn, t.Color = te, t.DEMData = $u, t.DataConstantProperty = yn, t.DictionaryCoder = Ju, t.EXTENT = 8192, t.ErrorEvent = Tt, t.EvaluationParameters = sn, t.Event = It, t.Evented = At, t.FeatureIndex = eh, t.FillBucket = ss, t.FillExtrusionBucket = Ss, t.ImageAtlas = xl, t.ImagePosition = _l, t.LineBucket = Rs, t.LngLat = Fu, t.LngLatBounds = Ou, t.MercatorCoordinate = Zu, t.ONE_EM = 24, t.OverscaledTileID = Ku, t.Point = n, t.Point$1 = n, t.Properties = bn, t.Protobuf = $s, t.RGBAImage = vo, t.RequestManager = Z, t.RequestPerformance = sh, t.ResourceType = dt, t.SegmentVector = sa, t.SourceFeatureState = th, t.StructArrayLayout1ui2 = Kn, t.StructArrayLayout2f1f2i16 = Un, t.StructArrayLayout2i4 = An, t.StructArrayLayout3ui6 = Vn, t.StructArrayLayout4i8 = Pn, t.SymbolBucket = gu, t.Texture = Lu, t.Tile = ah, t.Transitionable = hn, t.Uniform1f = xa, t.Uniform1i = va, t.Uniform2f = ba, t.Uniform3f = wa, t.Uniform4f = Ma, t.UniformColor = Sa, t.UniformMatrix4f = Ia, t.UnwrappedTileID = Wu, t.ValidationError = Ct, t.WritingMode = bl, t.ZoomHistory = qr, t.add = function (t, e, i) { return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t }, t.addDynamicAttributes = fu, t.asyncAll = function (t, e, i) { if (!t.length) return i(null, []); var r = t.length, n = new Array(t.length), a = null; t.forEach((function (t, o) { e(t, (function (t, e) { t && (a = t), n[o] = e, 0 == --r && i(a, n) })) })) }, t.bezier = l, t.bindAll = g, t.browser = F, t.cacheEntryPossiblyAdded = function (t) { ++pt > lt && (t.getActor().send("enforceCacheSizeLimit", st), pt = 0) }, t.clamp = h, t.clearTileCache = function (t) { var e = o.caches.delete("mapbox-tiles"); t && e.catch(t).then((function () { return t() })) }, t.clipLine = Xl, t.clone = function (t) { var e = new ao(16); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e }, t.clone$1 = b, t.clone$2 = function (t) { var e = new ao(3); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e }, t.collisionCircleLayout = Zs, t.config = U, t.create = function () { var t = new ao(16); return ao != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t }, t.create$1 = function () { var t = new ao(9); return ao != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t }, t.create$2 = function () { var t = new ao(4); return ao != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t }, t.createCommonjsModule = e, t.createExpression = Xi, t.createLayout = In, t.createStyleLayer = function (t) { return "custom" === t.type ? new Iu(t) : new Tu[t.type](t) }, t.cross = function (t, e, i) { var r = e[0], n = e[1], a = e[2], o = i[0], s = i[1], l = i[2]; return t[0] = n * l - a * s, t[1] = a * o - r * l, t[2] = r * s - n * o, t }, t.deepEqual = function t(e, i) { if (Array.isArray(e)) { if (!Array.isArray(i) || e.length !== i.length) return !1; for (var r = 0; r < e.length; r++)if (!t(e[r], i[r])) return !1; return !0 } if ("object" == typeof e && null !== e && null !== i) { if ("object" != typeof i) return !1; if (Object.keys(e).length !== Object.keys(i).length) return !1; for (var n in e) if (!t(e[n], i[n])) return !1; return !0 } return e === i }, t.dot = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] }, t.dot$1 = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3] }, t.ease = u, t.emitValidationErrors = zr, t.endsWith = _, t.enforceCacheSizeLimit = function (t) { ut(), tt && tt.then((function (e) { e.keys().then((function (i) { for (var r = 0; r < i.length - t; r++)e.delete(i[r]) })) })) }, t.evaluateSizeForFeature = Ol, t.evaluateSizeForZoom = Fl, t.evaluateVariableOffset = au, t.evented = rn, t.extend = p, t.featureFilter = ar, t.filterObject = x, t.fromRotation = function (t, e) { var i = Math.sin(e), r = Math.cos(e); return t[0] = r, t[1] = i, t[2] = 0, t[3] = -i, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, t.getAnchorAlignment = kl, t.getAnchorJustification = ou, t.getArrayBuffer = xt, t.getImage = Mt, t.getJSON = function (t, e) { return vt(p(t, { type: "json" }), e) }, t.getRTLTextPluginStatus = nn, t.getReferrer = _t, t.getVideo = function (t, e) { var i, r, n = o.document.createElement("video"); n.muted = !0, n.onloadstart = function () { e(null, n) }; for (var a = 0; a < t.length; a++) { var s = o.document.createElement("source"); i = t[a], r = void 0, (r = o.document.createElement("a")).href = i, (r.protocol !== o.document.location.protocol || r.host !== o.document.location.host) && (n.crossOrigin = "Anonymous"), s.src = t[a], n.appendChild(s) } return { cancel: function () { } } }, t.identity = oo, t.invert = function (t, e) { var i = e[0], r = e[1], n = e[2], a = e[3], o = e[4], s = e[5], l = e[6], u = e[7], h = e[8], c = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], _ = i * s - r * o, v = i * l - n * o, x = i * u - a * o, b = r * l - n * s, w = r * u - a * s, M = n * u - a * l, S = h * m - c * d, E = h * y - p * d, I = h * g - f * d, T = c * y - p * m, A = c * g - f * m, P = p * g - f * y, C = _ * P - v * A + x * T + b * I - w * E + M * S; return C ? (t[0] = (s * P - l * A + u * T) * (C = 1 / C), t[1] = (n * A - r * P - a * T) * C, t[2] = (m * M - y * w + g * b) * C, t[3] = (p * w - c * M - f * b) * C, t[4] = (l * I - o * P - u * E) * C, t[5] = (i * P - n * I + a * E) * C, t[6] = (y * x - d * M - g * v) * C, t[7] = (h * M - p * x + f * v) * C, t[8] = (o * A - s * I + u * S) * C, t[9] = (r * I - i * A - a * S) * C, t[10] = (d * w - m * x + g * _) * C, t[11] = (c * x - h * w - f * _) * C, t[12] = (s * E - o * T - l * S) * C, t[13] = (i * T - r * E + n * S) * C, t[14] = (m * v - d * b - y * _) * C, t[15] = (h * b - c * v + p * _) * C, t) : null }, t.isChar = Gr, t.isMapboxURL = X, t.keysDifference = function (t, e) { var i = []; for (var r in t) r in e || i.push(r); return i }, t.makeRequest = vt, t.mapObject = v, t.mercatorXfromLng = Vu, t.mercatorYfromLat = ju, t.mercatorZfromAltitude = qu, t.mul = uo, t.multiply = so, t.mvt = xs, t.nextPowerOfTwo = function (t) { return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, t.normalize = function (t, e) { var i = e[0], r = e[1], n = e[2], a = i * i + r * r + n * n; return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t }, t.number = Ge, t.offscreenCanvasSupported = ft, t.ortho = function (t, e, i, r, n, a, o) { var s = 1 / (e - i), l = 1 / (r - n), u = 1 / (a - o); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + i) * s, t[13] = (n + r) * l, t[14] = (o + a) * u, t[15] = 1, t }, t.parseGlyphPBF = function (t) { return new $s(t).readFields(dl, []) }, t.pbf = $s, t.performSymbolLayout = function (t, e, i, r, n, a, o) { t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1; var s = t.layers[0].layout, l = t.layers[0]._unevaluatedLayout._values, u = {}; if ("composite" === t.textSizeData.kind) { var h = t.textSizeData, c = h.maxZoom; u.compositeTextSizes = [l["text-size"].possiblyEvaluate(new sn(h.minZoom), o), l["text-size"].possiblyEvaluate(new sn(c), o)] } if ("composite" === t.iconSizeData.kind) { var p = t.iconSizeData, f = p.maxZoom; u.compositeIconSizes = [l["icon-size"].possiblyEvaluate(new sn(p.minZoom), o), l["icon-size"].possiblyEvaluate(new sn(f), o)] } u.layoutTextSize = l["text-size"].possiblyEvaluate(new sn(t.zoom + 1), o), u.layoutIconSize = l["icon-size"].possiblyEvaluate(new sn(t.zoom + 1), o), u.textMaxSize = l["text-size"].possiblyEvaluate(new sn(18)); for (var d = 24 * s.get("text-line-height"), m = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"), y = s.get("text-keep-upright"), g = s.get("text-size"), _ = function () { var a = x[v], l = s.get("text-font").evaluate(a, {}, o).join(","), h = g.evaluate(a, {}, o), c = u.layoutTextSize.evaluate(a, {}, o), p = u.layoutIconSize.evaluate(a, {}, o), f = { horizontal: {}, vertical: void 0 }, _ = a.text, b = [0, 0]; if (_) { var w = _.toString(), S = 24 * s.get("text-letter-spacing").evaluate(a, {}, o), E = function (t) { for (var e = 0, i = t; e < i.length; e += 1)if (r = i[e].charCodeAt(0), Gr.Arabic(r) || Gr["Arabic Supplement"](r) || Gr["Arabic Extended-A"](r) || Gr["Arabic Presentation Forms-A"](r) || Gr["Arabic Presentation Forms-B"](r)) return !1; var r; return !0 }(w) ? S : 0, I = s.get("text-anchor").evaluate(a, {}, o), T = s.get("text-variable-anchor"); if (!T) { var A = s.get("text-radial-offset").evaluate(a, {}, o); b = A ? au(I, [24 * A, nu]) : s.get("text-offset").evaluate(a, {}, o).map((function (t) { return 24 * t })) } var P = m ? "center" : s.get("text-justify").evaluate(a, {}, o), C = s.get("symbol-placement"), z = "point" === C ? 24 * s.get("text-max-width").evaluate(a, {}, o) : 0, k = function () { t.allowVerticalPlacement && Zr(w) && (f.vertical = Sl(_, e, i, n, l, z, d, I, "left", E, b, bl.vertical, !0, C, c, h)) }; if (!m && T) { for (var L = "auto" === P ? T.map((function (t) { return ou(t) })) : [P], D = !1, R = 0; R < L.length; R++) { var B = L[R]; if (!f.horizontal[B]) if (D) f.horizontal[B] = f.horizontal[0]; else { var O = Sl(_, e, i, n, l, z, d, "center", B, E, b, bl.horizontal, !1, C, c, h); O && (f.horizontal[B] = O, D = 1 === O.positionedLines.length) } } k() } else { "auto" === P && (P = ou(I)); var F = Sl(_, e, i, n, l, z, d, I, P, E, b, bl.horizontal, !1, C, c, h); F && (f.horizontal[P] = F), k(), Zr(w) && m && y && (f.vertical = Sl(_, e, i, n, l, z, d, I, P, E, b, bl.vertical, !1, C, c, h)) } } var U = void 0, N = !1; if (a.icon && a.icon.name) { var V = r[a.icon.name]; V && (U = function (t, e, i) { var r = kl(i), n = e[0] - t.displaySize[0] * r.horizontalAlign, a = e[1] - t.displaySize[1] * r.verticalAlign; return { image: t, top: a, bottom: a + t.displaySize[1], left: n, right: n + t.displaySize[0] } }(n[a.icon.name], s.get("icon-offset").evaluate(a, {}, o), s.get("icon-anchor").evaluate(a, {}, o)), N = V.sdf, void 0 === t.sdfIcons ? t.sdfIcons = V.sdf : t.sdfIcons !== V.sdf && M("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (V.pixelRatio !== t.pixelRatio || 0 !== s.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0)) } var j = lu(f.horizontal) || f.vertical; t.iconsInText = !!j && j.iconsInText, (j || U) && function (t, e, i, r, n, a, o, s, l, u, h) { var c = a.textMaxSize.evaluate(e, {}); void 0 === c && (c = o); var p, f = t.layers[0].layout, d = f.get("icon-offset").evaluate(e, {}, h), m = lu(i.horizontal), y = o / 24, g = t.tilePixelRatio * y, _ = t.tilePixelRatio * c / 24, v = t.tilePixelRatio * s, x = t.tilePixelRatio * f.get("symbol-spacing"), b = f.get("text-padding") * t.tilePixelRatio, w = f.get("icon-padding") * t.tilePixelRatio, S = f.get("text-max-angle") / 180 * Math.PI, E = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), I = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"), T = f.get("symbol-placement"), A = x / 2, P = f.get("icon-text-fit"); r && "none" !== P && (t.allowVerticalPlacement && i.vertical && (p = Dl(r, i.vertical, P, f.get("icon-text-fit-padding"), d, y)), m && (r = Dl(r, m, P, f.get("icon-text-fit-padding"), d, y))); var C = function (s, c) { c.x < 0 || c.x >= 8192 || c.y < 0 || c.y >= 8192 || function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m, y, g, _, v, x, b, w, S, E) { var I, T, A, P, C, z = t.addToLineVertexArray(e, i), k = 0, L = 0, D = 0, R = 0, B = -1, O = -1, F = {}, U = pa(""), N = 0, V = 0; if (void 0 === s._unevaluatedLayout.getValue("text-radial-offset") ? (N = (I = s.layout.get("text-offset").evaluate(x, {}, S).map((function (t) { return 24 * t })))[0], V = I[1]) : (N = 24 * s.layout.get("text-radial-offset").evaluate(x, {}, S), V = nu), t.allowVerticalPlacement && r.vertical) { var j = s.layout.get("text-rotate").evaluate(x, {}, S) + 90; P = new Yl(l, e, u, h, c, r.vertical, p, f, d, j), o && (C = new Yl(l, e, u, h, c, o, y, g, d, j)) } if (n) { var q = s.layout.get("icon-rotate").evaluate(x, {}), G = "none" !== s.layout.get("icon-text-fit"), Z = Wl(n, q, w, G), X = o ? Wl(o, q, w, G) : void 0; A = new Yl(l, e, u, h, c, n, y, g, !1, q), k = 4 * Z.length; var W = t.iconSizeData, K = null; "source" === W.kind ? (K = [128 * s.layout.get("icon-size").evaluate(x, {})])[0] > 32640 && M(t.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === W.kind && ((K = [128 * b.compositeIconSizes[0].evaluate(x, {}, S), 128 * b.compositeIconSizes[1].evaluate(x, {}, S)])[0] > 32640 || K[1] > 32640) && M(t.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t.addSymbols(t.icon, Z, K, v, _, x, !1, e, z.lineStartIndex, z.lineLength, -1, S), B = t.icon.placedSymbolArray.length - 1, X && (L = 4 * X.length, t.addSymbols(t.icon, X, K, v, _, x, bl.vertical, e, z.lineStartIndex, z.lineLength, -1, S), O = t.icon.placedSymbolArray.length - 1) } for (var H in r.horizontal) { var $ = r.horizontal[H]; if (!T) { U = pa($.text); var J = s.layout.get("text-rotate").evaluate(x, {}, S); T = new Yl(l, e, u, h, c, $, p, f, d, J) } var Y = 1 === $.positionedLines.length; if (D += su(t, e, $, a, s, d, x, m, z, r.vertical ? bl.horizontal : bl.horizontalOnly, Y ? Object.keys(r.horizontal) : [H], F, B, b, S), Y) break } r.vertical && (R += su(t, e, r.vertical, a, s, d, x, m, z, bl.vertical, ["vertical"], F, O, b, S)); var Q = T ? T.boxStartIndex : t.collisionBoxArray.length, tt = T ? T.boxEndIndex : t.collisionBoxArray.length, et = P ? P.boxStartIndex : t.collisionBoxArray.length, it = P ? P.boxEndIndex : t.collisionBoxArray.length, rt = A ? A.boxStartIndex : t.collisionBoxArray.length, nt = A ? A.boxEndIndex : t.collisionBoxArray.length, at = C ? C.boxStartIndex : t.collisionBoxArray.length, ot = C ? C.boxEndIndex : t.collisionBoxArray.length, st = -1, lt = function (t, e) { return t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e }; st = lt(T, st), st = lt(P, st), st = lt(A, st); var ut = (st = lt(C, st)) > -1 ? 1 : 0; ut && (st *= E / 24), t.glyphOffsetArray.length >= gu.MAX_GLYPHS && M("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== x.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, x.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, F.right >= 0 ? F.right : -1, F.center >= 0 ? F.center : -1, F.left >= 0 ? F.left : -1, F.vertical || -1, B, O, U, Q, tt, et, it, rt, nt, at, ot, u, D, R, k, L, ut, 0, p, N, V, st) }(t, c, s, i, r, n, p, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, g, b, E, l, v, w, I, d, e, a, u, h, o) }; if ("line" === T) for (var z = 0, k = Xl(e.geometry, 0, 0, 8192, 8192); z < k.length; z += 1)for (var L = k[z], D = 0, R = Zl(L, x, S, i.vertical || m, r, 24, _, t.overscaling, 8192); D < R.length; D += 1) { var B = R[D]; m && uu(t, m.text, A, B) || C(L, B) } else if ("line-center" === T) for (var O = 0, F = e.geometry; O < F.length; O += 1) { var U = F[O]; if (U.length > 1) { var N = Gl(U, S, i.vertical || m, r, 24, _); N && C(U, N) } } else if ("Polygon" === e.type) for (var V = 0, j = rs(e.geometry, 0); V < j.length; V += 1) { var q = j[V], G = eu(q, 16); C(q[0], new Rl(G.x, G.y, 0)) } else if ("LineString" === e.type) for (var Z = 0, X = e.geometry; Z < X.length; Z += 1) { var W = X[Z]; C(W, new Rl(W[0].x, W[0].y, 0)) } else if ("Point" === e.type) for (var K = 0, H = e.geometry; K < H.length; K += 1)for (var $ = 0, J = H[K]; $ < J.length; $ += 1) { var Y = J[$]; C([Y], new Rl(Y.x, Y.y, 0)) } }(t, a, f, U, r, u, c, p, b, N, o) }, v = 0, x = t.features; v < x.length; v += 1)_(); a && t.generateCollisionDebugBuffers() }, t.perspective = function (t, e, i, r, n) { var a, o = 1 / Math.tan(e / 2); return t[0] = o / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != n && n !== 1 / 0 ? (t[10] = (n + r) * (a = 1 / (r - n)), t[14] = 2 * n * r * a) : (t[10] = -1, t[14] = -2 * r), t }, t.pick = function (t, e) { for (var i = {}, r = 0; r < e.length; r++) { var n = e[r]; n in t && (i[n] = t[n]) } return i }, t.plugin = on, t.polygonIntersectsPolygon = qa, t.postMapLoadEvent = ot, t.postTurnstileEvent = nt, t.potpack = gl, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = Or, t.registerForPluginStateChange = function (t) { return t({ pluginStatus: Yr, pluginURL: Qr }), rn.on("pluginStateChange", t), t }, t.renderColorRamp = bo, t.rotate = function (t, e, i) { var r = e[0], n = e[1], a = e[2], o = e[3], s = Math.sin(i), l = Math.cos(i); return t[0] = r * l + a * s, t[1] = n * l + o * s, t[2] = r * -s + a * l, t[3] = n * -s + o * l, t }, t.rotateX = function (t, e, i) { var r = Math.sin(i), n = Math.cos(i), a = e[4], o = e[5], s = e[6], l = e[7], u = e[8], h = e[9], c = e[10], p = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * n + u * r, t[5] = o * n + h * r, t[6] = s * n + c * r, t[7] = l * n + p * r, t[8] = u * n - a * r, t[9] = h * n - o * r, t[10] = c * n - s * r, t[11] = p * n - l * r, t }, t.rotateZ = function (t, e, i) { var r = Math.sin(i), n = Math.cos(i), a = e[0], o = e[1], s = e[2], l = e[3], u = e[4], h = e[5], c = e[6], p = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * n + u * r, t[1] = o * n + h * r, t[2] = s * n + c * r, t[3] = l * n + p * r, t[4] = u * n - a * r, t[5] = h * n - o * r, t[6] = c * n - s * r, t[7] = p * n - l * r, t }, t.scale = function (t, e, i) { var r = i[0], n = i[1], a = i[2]; return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, t.scale$1 = function (t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t }, t.scale$2 = function (t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t }, t.setCacheLimits = function (t, e) { st = t, lt = e }, t.setRTLTextPlugin = function (t, e, i) { if (void 0 === i && (i = !1), "deferred" === Yr || "loading" === Yr || "loaded" === Yr) throw new Error("setRTLTextPlugin cannot be called multiple times."); Qr = F.resolveURL(t), Yr = "deferred", Jr = e, en(), i || an() }, t.sphericalToCartesian = function (t) { var e = t[0], i = t[1], r = t[2]; return i += 90, i *= Math.PI / 180, r *= Math.PI / 180, { x: e * Math.cos(i) * Math.sin(r), y: e * Math.sin(i) * Math.sin(r), z: e * Math.cos(r) } }, t.sqrLen = function (t) { var e = t[0], i = t[1]; return e * e + i * i }, t.styleSpec = Pt, t.sub = function (t, e, i) { return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t }, t.symbolSize = Ul, t.transformMat3 = function (t, e, i) { var r = e[0], n = e[1], a = e[2]; return t[0] = r * i[0] + n * i[3] + a * i[6], t[1] = r * i[1] + n * i[4] + a * i[7], t[2] = r * i[2] + n * i[5] + a * i[8], t }, t.transformMat4 = ho, t.translate = function (t, e, i) { var r, n, a, o, s, l, u, h, c, p, f, d, m = i[0], y = i[1], g = i[2]; return e === t ? (t[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (n = e[1], a = e[2], o = e[3], s = e[4], l = e[5], u = e[6], h = e[7], c = e[8], p = e[9], f = e[10], d = e[11], t[0] = r = e[0], t[1] = n, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t[6] = u, t[7] = h, t[8] = c, t[9] = p, t[10] = f, t[11] = d, t[12] = r * m + s * y + c * g + e[12], t[13] = n * m + l * y + p * g + e[13], t[14] = a * m + u * y + f * g + e[14], t[15] = o * m + h * y + d * g + e[15]), t }, t.triggerPluginCompletionEvent = tn, t.uniqueId = d, t.validateCustomStyleLayer = function (t) { var e = [], i = t.id; return void 0 === i && e.push({ message: "layers." + i + ': missing required property "id"' }), void 0 === t.render && e.push({ message: "layers." + i + ': missing required method "render"' }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({ message: "layers." + i + ': property "renderingMode" must be either "2d" or "3d"' }), e }, t.validateLight = Ar, t.validateStyle = Tr, t.values = function (t) { var e = []; for (var i in t) e.push(t[i]); return e }, t.vectorTile = xs, t.version = "1.13.0", t.warnOnce = M, t.webpSupported = N, t.window = o, t.wrap = c })), r(["./shared"], (function (t) { function e(t) { var i = typeof t; if ("number" === i || "boolean" === i || "string" === i || null == t) return JSON.stringify(t); if (Array.isArray(t)) { for (var r = "[", n = 0, a = t; n < a.length; n += 1)r += e(a[n]) + ","; return r + "]" } for (var o = Object.keys(t).sort(), s = "{", l = 0; l < o.length; l++)s += JSON.stringify(o[l]) + ":" + e(t[o[l]]) + ","; return s + "}" } function i(i) { for (var r = "", n = 0, a = t.refProperties; n < a.length; n += 1)r += "/" + e(i[a[n]]); return r } var r = function (t) { this.keyCache = {}, t && this.replace(t) }; r.prototype.replace = function (t) { this._layerConfigs = {}, this._layers = {}, this.update(t, []) }, r.prototype.update = function (e, r) { for (var n = this, a = 0, o = e; a < o.length; a += 1) { var s = o[a]; this._layerConfigs[s.id] = s; var l = this._layers[s.id] = t.createStyleLayer(s); l._featureFilter = t.featureFilter(l.filter), this.keyCache[s.id] && delete this.keyCache[s.id] } for (var u = 0, h = r; u < h.length; u += 1) { var c = h[u]; delete this.keyCache[c], delete this._layerConfigs[c], delete this._layers[c] } this.familiesBySource = {}; for (var p = 0, f = function (t, e) { for (var r = {}, n = 0; n < t.length; n++) { var a = e && e[t[n].id] || i(t[n]); e && (e[t[n].id] = a); var o = r[a]; o || (o = r[a] = []), o.push(t[n]) } var s = []; for (var l in r) s.push(r[l]); return s }(t.values(this._layerConfigs), this.keyCache); p < f.length; p += 1) { var d = f[p].map((function (t) { return n._layers[t.id] })), m = d[0]; if ("none" !== m.visibility) { var y = m.source || "", g = this.familiesBySource[y]; g || (g = this.familiesBySource[y] = {}); var _ = m.sourceLayer || "_geojsonTileLayer", v = g[_]; v || (v = g[_] = []), v.push(d) } } }; var n = function (e) { var i = {}, r = []; for (var n in e) { var a = e[n], o = i[n] = {}; for (var s in a) { var l = a[+s]; if (l && 0 !== l.bitmap.width && 0 !== l.bitmap.height) { var u = { x: 0, y: 0, w: l.bitmap.width + 2, h: l.bitmap.height + 2 }; r.push(u), o[s] = { rect: u, metrics: l.metrics } } } } var h = t.potpack(r), c = new t.AlphaImage({ width: h.w || 1, height: h.h || 1 }); for (var p in e) { var f = e[p]; for (var d in f) { var m = f[+d]; if (m && 0 !== m.bitmap.width && 0 !== m.bitmap.height) { var y = i[p][d].rect; t.AlphaImage.copy(m.bitmap, c, { x: 0, y: 0 }, { x: y.x + 1, y: y.y + 1 }, m.bitmap) } } } this.image = c, this.positions = i }; t.register("GlyphAtlas", n); var a = function (e) { this.tileID = new t.OverscaledTileID(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.uid = e.uid, this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId }; function o(e, i, r) { for (var n = new t.EvaluationParameters(i), a = 0, o = e; a < o.length; a += 1)o[a].recalculate(n, r) } function s(e, i) { var r = t.getArrayBuffer(e.request, (function (e, r, n, a) { e ? i(e) : r && i(null, { vectorTile: new t.vectorTile.VectorTile(new t.pbf(r)), rawData: r, cacheControl: n, expires: a }) })); return function () { r.cancel(), i() } } a.prototype.parse = function (e, i, r, a, s) { var l = this; this.status = "parsing", this.data = e, this.collisionBoxArray = new t.CollisionBoxArray; var u = new t.DictionaryCoder(Object.keys(e.layers).sort()), h = new t.FeatureIndex(this.tileID, this.promoteId); h.bucketLayerIDs = []; var c, p, f, d, m = {}, y = { featureIndex: h, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: r }, g = i.familiesBySource[this.source]; for (var _ in g) { var v = e.layers[_]; if (v) { 1 === v.version && t.warnOnce('Vector tile source "' + this.source + '" layer "' + _ + '" does not use vector tile spec v2 and therefore may have some rendering errors.'); for (var x = u.encode(_), b = [], w = 0; w < v.length; w++) { var M = v.feature(w), S = h.getId(M, _); b.push({ feature: M, id: S, index: w, sourceLayerIndex: x }) } for (var E = 0, I = g[_]; E < I.length; E += 1) { var T = I[E], A = T[0]; A.minzoom && this.zoom < Math.floor(A.minzoom) || A.maxzoom && this.zoom >= A.maxzoom || "none" !== A.visibility && (o(T, this.zoom, r), (m[A.id] = A.createBucket({ index: h.bucketLayerIDs.length, layers: T, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: x, sourceID: this.source })).populate(b, y, this.tileID.canonical), h.bucketLayerIDs.push(T.map((function (t) { return t.id })))) } } } var P = t.mapObject(y.glyphDependencies, (function (t) { return Object.keys(t).map(Number) })); Object.keys(P).length ? a.send("getGlyphs", { uid: this.uid, stacks: P }, (function (t, e) { c || (c = t, p = e, k.call(l)) })) : p = {}; var C = Object.keys(y.iconDependencies); C.length ? a.send("getImages", { icons: C, source: this.source, tileID: this.tileID, type: "icons" }, (function (t, e) { c || (c = t, f = e, k.call(l)) })) : f = {}; var z = Object.keys(y.patternDependencies); function k() { if (c) return s(c); if (p && f && d) { var e = new n(p), i = new t.ImageAtlas(f, d); for (var a in m) { var l = m[a]; l instanceof t.SymbolBucket ? (o(l.layers, this.zoom, r), t.performSymbolLayout(l, p, e.positions, f, i.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l.hasPattern && (l instanceof t.LineBucket || l instanceof t.FillBucket || l instanceof t.FillExtrusionBucket) && (o(l.layers, this.zoom, r), l.addFeatures(y, this.tileID.canonical, i.patternPositions)) } this.status = "done", s(null, { buckets: t.values(m).filter((function (t) { return !t.isEmpty() })), featureIndex: h, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: e.image, imageAtlas: i, glyphMap: this.returnDependencies ? p : null, iconMap: this.returnDependencies ? f : null, glyphPositions: this.returnDependencies ? e.positions : null }) } } z.length ? a.send("getImages", { icons: z, source: this.source, tileID: this.tileID, type: "patterns" }, (function (t, e) { c || (c = t, d = e, k.call(l)) })) : d = {}, k.call(this) }; var l = function (t, e, i, r) { this.actor = t, this.layerIndex = e, this.availableImages = i, this.loadVectorData = r || s, this.loading = {}, this.loaded = {} }; l.prototype.loadTile = function (e, i) { var r = this, n = e.uid; this.loading || (this.loading = {}); var o = !!(e && e.request && e.request.collectResourceTiming) && new t.RequestPerformance(e.request), s = this.loading[n] = new a(e); s.abort = this.loadVectorData(e, (function (e, a) { if (delete r.loading[n], e || !a) return s.status = "done", r.loaded[n] = s, i(e); var l = a.rawData, u = {}; a.expires && (u.expires = a.expires), a.cacheControl && (u.cacheControl = a.cacheControl); var h = {}; if (o) { var c = o.finish(); c && (h.resourceTiming = JSON.parse(JSON.stringify(c))) } s.vectorTile = a.vectorTile, s.parse(a.vectorTile, r.layerIndex, r.availableImages, r.actor, (function (e, r) { if (e || !r) return i(e); i(null, t.extend({ rawTileData: l.slice(0) }, r, u, h)) })), r.loaded = r.loaded || {}, r.loaded[n] = s })) }, l.prototype.reloadTile = function (t, e) { var i = this, r = this.loaded, n = t.uid, a = this; if (r && r[n]) { var o = r[n]; o.showCollisionBoxes = t.showCollisionBoxes; var s = function (t, r) { var n = o.reloadCallback; n && (delete o.reloadCallback, o.parse(o.vectorTile, a.layerIndex, i.availableImages, a.actor, n)), e(t, r) }; "parsing" === o.status ? o.reloadCallback = s : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s()) } }, l.prototype.abortTile = function (t, e) { var i = this.loading, r = t.uid; i && i[r] && i[r].abort && (i[r].abort(), delete i[r]), e() }, l.prototype.removeTile = function (t, e) { var i = this.loaded, r = t.uid; i && i[r] && delete i[r], e() }; var u = t.window.ImageBitmap, h = function () { this.loaded = {} }; function c(t, e) { if (0 !== t.length) { p(t[0], e); for (var i = 1; i < t.length; i++)p(t[i], !e) } } function p(t, e) { for (var i = 0, r = 0, n = t.length, a = n - 1; r < n; a = r++)i += (t[r][0] - t[a][0]) * (t[a][1] + t[r][1]); i >= 0 != !!e && t.reverse() } h.prototype.loadTile = function (e, i) { var r = e.uid, n = e.encoding, a = e.rawImageData, o = u && a instanceof u ? this.getImageData(a) : a, s = new t.DEMData(r, o, n); this.loaded = this.loaded || {}, this.loaded[r] = s, i(null, s) }, h.prototype.getImageData = function (e) { this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height); var i = this.offscreenCanvasContext.getImageData(-1, -1, e.width + 2, e.height + 2); return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new t.RGBAImage({ width: i.width, height: i.height }, i.data) }, h.prototype.removeTile = function (t) { var e = this.loaded, i = t.uid; e && e[i] && delete e[i] }; var f = t.vectorTile.VectorTileFeature.prototype.toGeoJSON, d = function (e) { this._feature = e, this.extent = t.EXTENT, this.type = e.type, this.properties = e.tags, "id" in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10)) }; d.prototype.loadGeometry = function () { if (1 === this._feature.type) { for (var e = [], i = 0, r = this._feature.geometry; i < r.length; i += 1) { var n = r[i]; e.push([new t.Point$1(n[0], n[1])]) } return e } for (var a = [], o = 0, s = this._feature.geometry; o < s.length; o += 1) { for (var l = [], u = 0, h = s[o]; u < h.length; u += 1) { var c = h[u]; l.push(new t.Point$1(c[0], c[1])) } a.push(l) } return a }, d.prototype.toGeoJSON = function (t, e, i) { return f.call(this, t, e, i) }; var m = function (e) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = t.EXTENT, this.length = e.length, this._features = e }; m.prototype.feature = function (t) { return new d(this._features[t]) }; var y = t.vectorTile.VectorTileFeature, g = _; function _(t, e) { this.options = e || {}, this.features = t, this.length = t.length } function v(t, e) { this.id = "number" == typeof t.id ? t.id : void 0, this.type = t.type, this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry, this.properties = t.tags, this.extent = e || 4096 } _.prototype.feature = function (t) { return new v(this.features[t], this.options.extent) }, v.prototype.loadGeometry = function () { var e = this.rawGeometry; this.geometry = []; for (var i = 0; i < e.length; i++) { for (var r = e[i], n = [], a = 0; a < r.length; a++)n.push(new t.Point$1(r[a][0], r[a][1])); this.geometry.push(n) } return this.geometry }, v.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var t = this.geometry, e = 1 / 0, i = -1 / 0, r = 1 / 0, n = -1 / 0, a = 0; a < t.length; a++)for (var o = t[a], s = 0; s < o.length; s++) { var l = o[s]; e = Math.min(e, l.x), i = Math.max(i, l.x), r = Math.min(r, l.y), n = Math.max(n, l.y) } return [e, r, i, n] }, v.prototype.toGeoJSON = y.prototype.toGeoJSON; var x = w, b = g; function w(e) { var i = new t.pbf; return function (t, e) { for (var i in t.layers) e.writeMessage(3, M, t.layers[i]) }(e, i), i.finish() } function M(t, e) { var i; e.writeVarintField(15, t.version || 1), e.writeStringField(1, t.name || ""), e.writeVarintField(5, t.extent || 4096); var r = { keys: [], values: [], keycache: {}, valuecache: {} }; for (i = 0; i < t.length; i++)r.feature = t.feature(i), e.writeMessage(2, S, r); var n = r.keys; for (i = 0; i < n.length; i++)e.writeStringField(3, n[i]); var a = r.values; for (i = 0; i < a.length; i++)e.writeMessage(4, P, a[i]) } function S(t, e) { var i = t.feature; void 0 !== i.id && e.writeVarintField(1, i.id), e.writeMessage(2, E, t), e.writeVarintField(3, i.type), e.writeMessage(4, A, i) } function E(t, e) { var i = t.feature, r = t.keys, n = t.values, a = t.keycache, o = t.valuecache; for (var s in i.properties) { var l = a[s]; void 0 === l && (r.push(s), a[s] = l = r.length - 1), e.writeVarint(l); var u = i.properties[s], h = typeof u; "string" !== h && "boolean" !== h && "number" !== h && (u = JSON.stringify(u)); var c = h + ":" + u, p = o[c]; void 0 === p && (n.push(u), o[c] = p = n.length - 1), e.writeVarint(p) } } function I(t, e) { return (e << 3) + (7 & t) } function T(t) { return t << 1 ^ t >> 31 } function A(t, e) { for (var i = t.loadGeometry(), r = t.type, n = 0, a = 0, o = i.length, s = 0; s < o; s++) { var l = i[s], u = 1; 1 === r && (u = l.length), e.writeVarint(I(1, u)); for (var h = 3 === r ? l.length - 1 : l.length, c = 0; c < h; c++) { 1 === c && 1 !== r && e.writeVarint(I(2, h - 1)); var p = l[c].x - n, f = l[c].y - a; e.writeVarint(T(p)), e.writeVarint(T(f)), n += p, a += f } 3 === r && e.writeVarint(I(7, 1)) } } function P(t, e) { var i = typeof t; "string" === i ? e.writeStringField(1, t) : "boolean" === i ? e.writeBooleanField(7, t) : "number" === i && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t)) } function C(t, e, i, r) { z(t, i, r), z(e, 2 * i, 2 * r), z(e, 2 * i + 1, 2 * r + 1) } function z(t, e, i) { var r = t[e]; t[e] = t[i], t[i] = r } function k(t, e, i, r) { var n = t - i, a = e - r; return n * n + a * a } x.fromVectorTileJs = w, x.fromGeojsonVt = function (t, e) { e = e || {}; var i = {}; for (var r in t) i[r] = new g(t[r].features, e), i[r].name = r, i[r].version = e.version, i[r].extent = e.extent; return w({ layers: i }) }, x.GeoJSONWrapper = b; var L = function (t) { return t[0] }, D = function (t) { return t[1] }, R = function (t, e, i, r, n) { void 0 === e && (e = L), void 0 === i && (i = D), void 0 === r && (r = 64), void 0 === n && (n = Float64Array), this.nodeSize = r, this.points = t; for (var a = t.length < 65536 ? Uint16Array : Uint32Array, o = this.ids = new a(t.length), s = this.coords = new n(2 * t.length), l = 0; l < t.length; l++)o[l] = l, s[2 * l] = e(t[l]), s[2 * l + 1] = i(t[l]); !function t(e, i, r, n, a, o) { if (!(a - n <= r)) { var s = n + a >> 1; !function t(e, i, r, n, a, o) { for (; a > n;) { if (a - n > 600) { var s = a - n + 1, l = r - n + 1, u = Math.log(s), h = .5 * Math.exp(2 * u / 3), c = .5 * Math.sqrt(u * h * (s - h) / s) * (l - s / 2 < 0 ? -1 : 1); t(e, i, r, Math.max(n, Math.floor(r - l * h / s + c)), Math.min(a, Math.floor(r + (s - l) * h / s + c)), o) } var p = i[2 * r + o], f = n, d = a; for (C(e, i, n, r), i[2 * a + o] > p && C(e, i, n, a); f < d;) { for (C(e, i, f, d), f++, d--; i[2 * f + o] < p;)f++; for (; i[2 * d + o] > p;)d-- } i[2 * n + o] === p ? C(e, i, n, d) : C(e, i, ++d, a), d <= r && (n = d + 1), r <= d && (a = d - 1) } }(e, i, s, n, a, o % 2), t(e, i, r, n, s - 1, o + 1), t(e, i, r, s + 1, a, o + 1) } }(o, s, r, 0, o.length - 1, 0) }; R.prototype.range = function (t, e, i, r) { return function (t, e, i, r, n, a, o) { for (var s, l, u = [0, t.length - 1, 0], h = []; u.length;) { var c = u.pop(), p = u.pop(), f = u.pop(); if (p - f <= o) for (var d = f; d <= p; d++)l = e[2 * d + 1], (s = e[2 * d]) >= i && s <= n && l >= r && l <= a && h.push(t[d]); else { var m = Math.floor((f + p) / 2); l = e[2 * m + 1], (s = e[2 * m]) >= i && s <= n && l >= r && l <= a && h.push(t[m]); var y = (c + 1) % 2; (0 === c ? i <= s : r <= l) && (u.push(f), u.push(m - 1), u.push(y)), (0 === c ? n >= s : a >= l) && (u.push(m + 1), u.push(p), u.push(y)) } } return h }(this.ids, this.coords, t, e, i, r, this.nodeSize) }, R.prototype.within = function (t, e, i) { return function (t, e, i, r, n, a) { for (var o = [0, t.length - 1, 0], s = [], l = n * n; o.length;) { var u = o.pop(), h = o.pop(), c = o.pop(); if (h - c <= a) for (var p = c; p <= h; p++)k(e[2 * p], e[2 * p + 1], i, r) <= l && s.push(t[p]); else { var f = Math.floor((c + h) / 2), d = e[2 * f], m = e[2 * f + 1]; k(d, m, i, r) <= l && s.push(t[f]); var y = (u + 1) % 2; (0 === u ? i - n <= d : r - n <= m) && (o.push(c), o.push(f - 1), o.push(y)), (0 === u ? i + n >= d : r + n >= m) && (o.push(f + 1), o.push(h), o.push(y)) } } return s }(this.ids, this.coords, t, e, i, this.nodeSize) }; var B = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function (t) { return t } }, O = function (t) { this.options = G(Object.create(B), t), this.trees = new Array(this.options.maxZoom + 1) }; function F(t, e, i, r, n) { return { x: t, y: e, zoom: 1 / 0, id: i, parentId: -1, numPoints: r, properties: n } } function U(t, e) { var i = t.geometry.coordinates, r = i[1]; return { x: j(i[0]), y: q(r), zoom: 1 / 0, index: e, parentId: -1 } } function N(t) { return { type: "Feature", id: t.id, properties: V(t), geometry: { type: "Point", coordinates: [(r = t.x, 360 * (r - .5)), (e = t.y, i = (180 - 360 * e) * Math.PI / 180, 360 * Math.atan(Math.exp(i)) / Math.PI - 90)] } }; var e, i, r } function V(t) { var e = t.numPoints, i = e >= 1e4 ? Math.round(e / 1e3) + "k" : e >= 1e3 ? Math.round(e / 100) / 10 + "k" : e; return G(G({}, t.properties), { cluster: !0, cluster_id: t.id, point_count: e, point_count_abbreviated: i }) } function j(t) { return t / 360 + .5 } function q(t) { var e = Math.sin(t * Math.PI / 180), i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI; return i < 0 ? 0 : i > 1 ? 1 : i } function G(t, e) { for (var i in e) t[i] = e[i]; return t } function Z(t) { return t.x } function X(t) { return t.y } function W(t, e, i, r, n, a) { var o = n - i, s = a - r; if (0 !== o || 0 !== s) { var l = ((t - i) * o + (e - r) * s) / (o * o + s * s); l > 1 ? (i = n, r = a) : l > 0 && (i += o * l, r += s * l) } return (o = t - i) * o + (s = e - r) * s } function K(t, e, i, r) { var n = { id: void 0 === t ? null : t, type: e, geometry: i, tags: r, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; return function (t) { var e = t.geometry, i = t.type; if ("Point" === i || "MultiPoint" === i || "LineString" === i) H(t, e); else if ("Polygon" === i || "MultiLineString" === i) for (var r = 0; r < e.length; r++)H(t, e[r]); else if ("MultiPolygon" === i) for (r = 0; r < e.length; r++)for (var n = 0; n < e[r].length; n++)H(t, e[r][n]) }(n), n } function H(t, e) { for (var i = 0; i < e.length; i += 3)t.minX = Math.min(t.minX, e[i]), t.minY = Math.min(t.minY, e[i + 1]), t.maxX = Math.max(t.maxX, e[i]), t.maxY = Math.max(t.maxY, e[i + 1]) } function $(t, e, i, r) { if (e.geometry) { var n = e.geometry.coordinates, a = e.geometry.type, o = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2), s = [], l = e.id; if (i.promoteId ? l = e.properties[i.promoteId] : i.generateId && (l = r || 0), "Point" === a) J(n, s); else if ("MultiPoint" === a) for (var u = 0; u < n.length; u++)J(n[u], s); else if ("LineString" === a) Y(n, s, o, !1); else if ("MultiLineString" === a) { if (i.lineMetrics) { for (u = 0; u < n.length; u++)Y(n[u], s = [], o, !1), t.push(K(l, "LineString", s, e.properties)); return } Q(n, s, o, !1) } else if ("Polygon" === a) Q(n, s, o, !0); else { if ("MultiPolygon" !== a) { if ("GeometryCollection" === a) { for (u = 0; u < e.geometry.geometries.length; u++)$(t, { id: l, geometry: e.geometry.geometries[u], properties: e.properties }, i, r); return } throw new Error("Input data is not a valid GeoJSON object.") } for (u = 0; u < n.length; u++) { var h = []; Q(n[u], h, o, !0), s.push(h) } } t.push(K(l, a, s, e.properties)) } } function J(t, e) { e.push(tt(t[0])), e.push(et(t[1])), e.push(0) } function Y(t, e, i, r) { for (var n, a, o = 0, s = 0; s < t.length; s++) { var l = tt(t[s][0]), u = et(t[s][1]); e.push(l), e.push(u), e.push(0), s > 0 && (o += r ? (n * u - l * a) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - a, 2))), n = l, a = u } var h = e.length - 3; e[2] = 1, function t(e, i, r, n) { for (var a, o = n, s = r - i >> 1, l = r - i, u = e[i], h = e[i + 1], c = e[r], p = e[r + 1], f = i + 3; f < r; f += 3) { var d = W(e[f], e[f + 1], u, h, c, p); if (d > o) a = f, o = d; else if (d === o) { var m = Math.abs(f - s); m < l && (a = f, l = m) } } o > n && (a - i > 3 && t(e, i, a, n), e[a + 2] = o, r - a > 3 && t(e, a, r, n)) }(e, 0, h, i), e[h + 2] = 1, e.size = Math.abs(o), e.start = 0, e.end = e.size } function Q(t, e, i, r) { for (var n = 0; n < t.length; n++) { var a = []; Y(t[n], a, i, r), e.push(a) } } function tt(t) { return t / 360 + .5 } function et(t) { var e = Math.sin(t * Math.PI / 180), i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI; return i < 0 ? 0 : i > 1 ? 1 : i } function it(t, e, i, r, n, a, o, s) { if (r /= e, a >= (i /= e) && o < r) return t; if (o < i || a >= r) return null; for (var l = [], u = 0; u < t.length; u++) { var h = t[u], c = h.geometry, p = h.type, f = 0 === n ? h.minX : h.minY, d = 0 === n ? h.maxX : h.maxY; if (f >= i && d < r) l.push(h); else if (!(d < i || f >= r)) { var m = []; if ("Point" === p || "MultiPoint" === p) rt(c, m, i, r, n); else if ("LineString" === p) nt(c, m, i, r, n, !1, s.lineMetrics); else if ("MultiLineString" === p) ot(c, m, i, r, n, !1); else if ("Polygon" === p) ot(c, m, i, r, n, !0); else if ("MultiPolygon" === p) for (var y = 0; y < c.length; y++) { var g = []; ot(c[y], g, i, r, n, !0), g.length && m.push(g) } if (m.length) { if (s.lineMetrics && "LineString" === p) { for (y = 0; y < m.length; y++)l.push(K(h.id, p, m[y], h.tags)); continue } "LineString" !== p && "MultiLineString" !== p || (1 === m.length ? (p = "LineString", m = m[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === m.length ? "Point" : "MultiPoint"), l.push(K(h.id, p, m, h.tags)) } } } return l.length ? l : null } function rt(t, e, i, r, n) { for (var a = 0; a < t.length; a += 3) { var o = t[a + n]; o >= i && o <= r && (e.push(t[a]), e.push(t[a + 1]), e.push(t[a + 2])) } } function nt(t, e, i, r, n, a, o) { for (var s, l, u = at(t), h = 0 === n ? lt : ut, c = t.start, p = 0; p < t.length - 3; p += 3) { var f = t[p], d = t[p + 1], m = t[p + 2], y = t[p + 3], g = t[p + 4], _ = 0 === n ? f : d, v = 0 === n ? y : g, x = !1; o && (s = Math.sqrt(Math.pow(f - y, 2) + Math.pow(d - g, 2))), _ < i ? v > i && (l = h(u, f, d, y, g, i), o && (u.start = c + s * l)) : _ > r ? v < r && (l = h(u, f, d, y, g, r), o && (u.start = c + s * l)) : st(u, f, d, m), v < i && _ >= i && (l = h(u, f, d, y, g, i), x = !0), v > r && _ <= r && (l = h(u, f, d, y, g, r), x = !0), !a && x && (o && (u.end = c + s * l), e.push(u), u = at(t)), o && (c += s) } var b = t.length - 3; f = t[b], d = t[b + 1], m = t[b + 2], (_ = 0 === n ? f : d) >= i && _ <= r && st(u, f, d, m), b = u.length - 3, a && b >= 3 && (u[b] !== u[0] || u[b + 1] !== u[1]) && st(u, u[0], u[1], u[2]), u.length && e.push(u) } function at(t) { var e = []; return e.size = t.size, e.start = t.start, e.end = t.end, e } function ot(t, e, i, r, n, a) { for (var o = 0; o < t.length; o++)nt(t[o], e, i, r, n, a, !1) } function st(t, e, i, r) { t.push(e), t.push(i), t.push(r) } function lt(t, e, i, r, n, a) { var o = (a - e) / (r - e); return t.push(a), t.push(i + (n - i) * o), t.push(1), o } function ut(t, e, i, r, n, a) { var o = (a - i) / (n - i); return t.push(e + (r - e) * o), t.push(a), t.push(1), o } function ht(t, e) { for (var i = [], r = 0; r < t.length; r++) { var n, a = t[r], o = a.type; if ("Point" === o || "MultiPoint" === o || "LineString" === o) n = ct(a.geometry, e); else if ("MultiLineString" === o || "Polygon" === o) { n = []; for (var s = 0; s < a.geometry.length; s++)n.push(ct(a.geometry[s], e)) } else if ("MultiPolygon" === o) for (n = [], s = 0; s < a.geometry.length; s++) { for (var l = [], u = 0; u < a.geometry[s].length; u++)l.push(ct(a.geometry[s][u], e)); n.push(l) } i.push(K(a.id, o, n, a.tags)) } return i } function ct(t, e) { var i = []; i.size = t.size, void 0 !== t.start && (i.start = t.start, i.end = t.end); for (var r = 0; r < t.length; r += 3)i.push(t[r] + e, t[r + 1], t[r + 2]); return i } function pt(t, e) { if (t.transformed) return t; var i, r, n, a = 1 << t.z, o = t.x, s = t.y; for (i = 0; i < t.features.length; i++) { var l = t.features[i], u = l.geometry, h = l.type; if (l.geometry = [], 1 === h) for (r = 0; r < u.length; r += 2)l.geometry.push(ft(u[r], u[r + 1], e, a, o, s)); else for (r = 0; r < u.length; r++) { var c = []; for (n = 0; n < u[r].length; n += 2)c.push(ft(u[r][n], u[r][n + 1], e, a, o, s)); l.geometry.push(c) } } return t.transformed = !0, t } function ft(t, e, i, r, n, a) { return [Math.round(i * (t * r - n)), Math.round(i * (e * r - a))] } function dt(t, e, i, r, n) { for (var a = e === n.maxZoom ? 0 : n.tolerance / ((1 << e) * n.extent), o = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: i, y: r, z: e, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s = 0; s < t.length; s++) { o.numFeatures++, mt(o, t[s], a, n); var l = t[s].minX, u = t[s].minY, h = t[s].maxX, c = t[s].maxY; l < o.minX && (o.minX = l), u < o.minY && (o.minY = u), h > o.maxX && (o.maxX = h), c > o.maxY && (o.maxY = c) } return o } function mt(t, e, i, r) { var n = e.geometry, a = e.type, o = []; if ("Point" === a || "MultiPoint" === a) for (var s = 0; s < n.length; s += 3)o.push(n[s]), o.push(n[s + 1]), t.numPoints++, t.numSimplified++; else if ("LineString" === a) yt(o, n, t, i, !1, !1); else if ("MultiLineString" === a || "Polygon" === a) for (s = 0; s < n.length; s++)yt(o, n[s], t, i, "Polygon" === a, 0 === s); else if ("MultiPolygon" === a) for (var l = 0; l < n.length; l++) { var u = n[l]; for (s = 0; s < u.length; s++)yt(o, u[s], t, i, !0, 0 === s) } if (o.length) { var h = e.tags || null; if ("LineString" === a && r.lineMetrics) { for (var c in h = {}, e.tags) h[c] = e.tags[c]; h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size } var p = { geometry: o, type: "Polygon" === a || "MultiPolygon" === a ? 3 : "LineString" === a || "MultiLineString" === a ? 2 : 1, tags: h }; null !== e.id && (p.id = e.id), t.features.push(p) } } function yt(t, e, i, r, n, a) { var o = r * r; if (r > 0 && e.size < (n ? o : r)) i.numPoints += e.length / 3; else { for (var s = [], l = 0; l < e.length; l += 3)(0 === r || e[l + 2] > o) && (i.numSimplified++, s.push(e[l]), s.push(e[l + 1])), i.numPoints++; n && function (t, e) { for (var i = 0, r = 0, n = t.length, a = n - 2; r < n; a = r, r += 2)i += (t[r] - t[a]) * (t[r + 1] + t[a + 1]); if (i > 0 === e) for (r = 0, n = t.length; r < n / 2; r += 2) { var o = t[r], s = t[r + 1]; t[r] = t[n - 2 - r], t[r + 1] = t[n - 1 - r], t[n - 2 - r] = o, t[n - 1 - r] = s } }(s, a), t.push(s) } } function gt(t, e) { var i = (e = this.options = function (t, e) { for (var i in e) t[i] = e[i]; return t }(Object.create(this.options), e)).debug; if (i && console.time("preprocess data"), e.maxZoom < 0 || e.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (e.promoteId && e.generateId) throw new Error("promoteId and generateId cannot be used together."); var r = function (t, e) { var i = []; if ("FeatureCollection" === t.type) for (var r = 0; r < t.features.length; r++)$(i, t.features[r], e, r); else $(i, "Feature" === t.type ? t : { geometry: t }, e); return i }(t, e); this.tiles = {}, this.tileCoords = [], i && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", e.indexMaxZoom, e.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (r = function (t, e) { var i = e.buffer / e.extent, r = t, n = it(t, 1, -1 - i, i, 0, -1, 2, e), a = it(t, 1, 1 - i, 2 + i, 0, -1, 2, e); return (n || a) && (r = it(t, 1, -i, 1 + i, 0, -1, 2, e) || [], n && (r = ht(n, 1).concat(r)), a && (r = r.concat(ht(a, -1)))), r }(r, e)).length && this.splitTile(r, 0, 0, 0), i && (r.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } function _t(t, e, i) { return 32 * ((1 << t) * i + e) + t } function vt(t, e) { var i = t.tileID.canonical; if (!this._geoJSONIndex) return e(null, null); var r = this._geoJSONIndex.getTile(i.z, i.x, i.y); if (!r) return e(null, null); var n = new m(r.features), a = x(n); 0 === a.byteOffset && a.byteLength === a.buffer.byteLength || (a = new Uint8Array(a)), e(null, { vectorTile: n, rawData: a.buffer }) } O.prototype.load = function (t) { var e = this.options, i = e.log, r = e.minZoom, n = e.maxZoom, a = e.nodeSize; i && console.time("total time"); var o = "prepare " + t.length + " points"; i && console.time(o), this.points = t; for (var s = [], l = 0; l < t.length; l++)t[l].geometry && s.push(U(t[l], l)); this.trees[n + 1] = new R(s, Z, X, a, Float32Array), i && console.timeEnd(o); for (var u = n; u >= r; u--) { var h = +Date.now(); s = this._cluster(s, u), this.trees[u] = new R(s, Z, X, a, Float32Array), i && console.log("z%d: %d clusters in %dms", u, s.length, +Date.now() - h) } return i && console.timeEnd("total time"), this }, O.prototype.getClusters = function (t, e) { var i = ((t[0] + 180) % 360 + 360) % 360 - 180, r = Math.max(-90, Math.min(90, t[1])), n = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3])); if (t[2] - t[0] >= 360) i = -180, n = 180; else if (i > n) { var o = this.getClusters([i, r, 180, a], e), s = this.getClusters([-180, r, n, a], e); return o.concat(s) } for (var l = this.trees[this._limitZoom(e)], u = [], h = 0, c = l.range(j(i), q(a), j(n), q(r)); h < c.length; h += 1) { var p = l.points[c[h]]; u.push(p.numPoints ? N(p) : this.points[p.index]) } return u }, O.prototype.getChildren = function (t) { var e = this._getOriginId(t), i = this._getOriginZoom(t), r = "No cluster with the specified id.", n = this.trees[i]; if (!n) throw new Error(r); var a = n.points[e]; if (!a) throw new Error(r); for (var o = this.options.radius / (this.options.extent * Math.pow(2, i - 1)), s = [], l = 0, u = n.within(a.x, a.y, o); l < u.length; l += 1) { var h = n.points[u[l]]; h.parentId === t && s.push(h.numPoints ? N(h) : this.points[h.index]) } if (0 === s.length) throw new Error(r); return s }, O.prototype.getLeaves = function (t, e, i) { var r = []; return this._appendLeaves(r, t, e = e || 10, i = i || 0, 0), r }, O.prototype.getTile = function (t, e, i) { var r = this.trees[this._limitZoom(t)], n = Math.pow(2, t), a = this.options, o = a.radius / a.extent, s = (i - o) / n, l = (i + 1 + o) / n, u = { features: [] }; return this._addTileFeatures(r.range((e - o) / n, s, (e + 1 + o) / n, l), r.points, e, i, n, u), 0 === e && this._addTileFeatures(r.range(1 - o / n, s, 1, l), r.points, n, i, n, u), e === n - 1 && this._addTileFeatures(r.range(0, s, o / n, l), r.points, -1, i, n, u), u.features.length ? u : null }, O.prototype.getClusterExpansionZoom = function (t) { for (var e = this._getOriginZoom(t) - 1; e <= this.options.maxZoom;) { var i = this.getChildren(t); if (e++, 1 !== i.length) break; t = i[0].properties.cluster_id } return e }, O.prototype._appendLeaves = function (t, e, i, r, n) { for (var a = 0, o = this.getChildren(e); a < o.length; a += 1) { var s = o[a], l = s.properties; if (l && l.cluster ? n + l.point_count <= r ? n += l.point_count : n = this._appendLeaves(t, l.cluster_id, i, r, n) : n < r ? n++ : t.push(s), t.length === i) break } return n }, O.prototype._addTileFeatures = function (t, e, i, r, n, a) { for (var o = 0, s = t; o < s.length; o += 1) { var l = e[s[o]], u = l.numPoints, h = { type: 1, geometry: [[Math.round(this.options.extent * (l.x * n - i)), Math.round(this.options.extent * (l.y * n - r))]], tags: u ? V(l) : this.points[l.index].properties }, c = void 0; u ? c = l.id : this.options.generateId ? c = l.index : this.points[l.index].id && (c = this.points[l.index].id), void 0 !== c && (h.id = c), a.features.push(h) } }, O.prototype._limitZoom = function (t) { return Math.max(this.options.minZoom, Math.min(+t, this.options.maxZoom + 1)) }, O.prototype._cluster = function (t, e) { for (var i = [], r = this.options, n = r.reduce, a = r.minPoints, o = r.radius / (r.extent * Math.pow(2, e)), s = 0; s < t.length; s++) { var l = t[s]; if (!(l.zoom <= e)) { l.zoom = e; for (var u = this.trees[e + 1], h = u.within(l.x, l.y, o), c = l.numPoints || 1, p = c, f = 0, d = h; f < d.length; f += 1) { var m = u.points[d[f]]; m.zoom > e && (p += m.numPoints || 1) } if (p >= a) { for (var y = l.x * c, g = l.y * c, _ = n && c > 1 ? this._map(l, !0) : null, v = (s << 5) + (e + 1) + this.points.length, x = 0, b = h; x < b.length; x += 1) { var w = u.points[b[x]]; if (!(w.zoom <= e)) { w.zoom = e; var M = w.numPoints || 1; y += w.x * M, g += w.y * M, w.parentId = v, n && (_ || (_ = this._map(l, !0)), n(_, this._map(w))) } } l.parentId = v, i.push(F(y / p, g / p, v, p, _)) } else if (i.push(l), p > 1) for (var S = 0, E = h; S < E.length; S += 1) { var I = u.points[E[S]]; I.zoom <= e || (I.zoom = e, i.push(I)) } } } return i }, O.prototype._getOriginId = function (t) { return t - this.points.length >> 5 }, O.prototype._getOriginZoom = function (t) { return (t - this.points.length) % 32 }, O.prototype._map = function (t, e) { if (t.numPoints) return e ? G({}, t.properties) : t.properties; var i = this.points[t.index].properties, r = this.options.map(i); return e && r === i ? G({}, r) : r }, gt.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, gt.prototype.splitTile = function (t, e, i, r, n, a, o) { for (var s = [t, e, i, r], l = this.options, u = l.debug; s.length;) { r = s.pop(), i = s.pop(), e = s.pop(), t = s.pop(); var h = 1 << e, c = _t(e, i, r), p = this.tiles[c]; if (!p && (u > 1 && console.time("creation"), p = this.tiles[c] = dt(t, e, i, r, l), this.tileCoords.push({ z: e, x: i, y: r }), u)) { u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", e, i, r, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation")); var f = "z" + e; this.stats[f] = (this.stats[f] || 0) + 1, this.total++ } if (p.source = t, n) { if (e === l.maxZoom || e === n) continue; var d = 1 << n - e; if (i !== Math.floor(a / d) || r !== Math.floor(o / d)) continue } else if (e === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue; if (p.source = null, 0 !== t.length) { u > 1 && console.time("clipping"); var m, y, g, _, v, x, b = .5 * l.buffer / l.extent, w = .5 - b, M = .5 + b, S = 1 + b; m = y = g = _ = null, v = it(t, h, i - b, i + M, 0, p.minX, p.maxX, l), x = it(t, h, i + w, i + S, 0, p.minX, p.maxX, l), t = null, v && (m = it(v, h, r - b, r + M, 1, p.minY, p.maxY, l), y = it(v, h, r + w, r + S, 1, p.minY, p.maxY, l), v = null), x && (g = it(x, h, r - b, r + M, 1, p.minY, p.maxY, l), _ = it(x, h, r + w, r + S, 1, p.minY, p.maxY, l), x = null), u > 1 && console.timeEnd("clipping"), s.push(m || [], e + 1, 2 * i, 2 * r), s.push(y || [], e + 1, 2 * i, 2 * r + 1), s.push(g || [], e + 1, 2 * i + 1, 2 * r), s.push(_ || [], e + 1, 2 * i + 1, 2 * r + 1) } } }, gt.prototype.getTile = function (t, e, i) { var r = this.options, n = r.extent, a = r.debug; if (t < 0 || t > 24) return null; var o = 1 << t, s = _t(t, e = (e % o + o) % o, i); if (this.tiles[s]) return pt(this.tiles[s], n); a > 1 && console.log("drilling down to z%d-%d-%d", t, e, i); for (var l, u = t, h = e, c = i; !l && u > 0;)u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[_t(u, h, c)]; return l && l.source ? (a > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), a > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, t, e, i), a > 1 && console.timeEnd("drilling down"), this.tiles[s] ? pt(this.tiles[s], n) : null) : null }; var xt = function (e) { function i(t, i, r, n) { e.call(this, t, i, r, vt), n && (this.loadGeoJSON = n) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.loadData = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = e, this._pendingLoadDataParams = t, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData()) }, i.prototype._loadData = function () { var e = this; if (this._pendingCallback && this._pendingLoadDataParams) { var i = this._pendingCallback, r = this._pendingLoadDataParams; delete this._pendingCallback, delete this._pendingLoadDataParams; var n = !!(r && r.request && r.request.collectResourceTiming) && new t.RequestPerformance(r.request); this.loadGeoJSON(r, (function (a, o) { if (a || !o) return i(a); if ("object" != typeof o) return i(new Error("Input data given to '" + r.source + "' is not a valid GeoJSON object.")); !function t(e, i) { var r, n = e && e.type; if ("FeatureCollection" === n) for (r = 0; r < e.features.length; r++)t(e.features[r], i); else if ("GeometryCollection" === n) for (r = 0; r < e.geometries.length; r++)t(e.geometries[r], i); else if ("Feature" === n) t(e.geometry, i); else if ("Polygon" === n) c(e.coordinates, i); else if ("MultiPolygon" === n) for (r = 0; r < e.coordinates.length; r++)c(e.coordinates[r], i); return e }(o, !0); try { if (r.filter) { var s = t.createExpression(r.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if ("error" === s.result) throw new Error(s.value.map((function (t) { return t.key + ": " + t.message })).join(", ")); var l = o.features.filter((function (t) { return s.value.evaluate({ zoom: 0 }, t) })); o = { type: "FeatureCollection", features: l } } e._geoJSONIndex = r.cluster ? new O(function (e) { var i = e.superclusterOptions, r = e.clusterProperties; if (!r || !i) return i; for (var n = {}, a = {}, o = { accumulated: null, zoom: 0 }, s = { properties: null }, l = Object.keys(r), u = 0, h = l; u < h.length; u += 1) { var c = h[u], p = r[c], f = p[0], d = t.createExpression(p[1]), m = t.createExpression("string" == typeof f ? [f, ["accumulated"], ["get", c]] : f); n[c] = d.value, a[c] = m.value } return i.map = function (t) { s.properties = t; for (var e = {}, i = 0, r = l; i < r.length; i += 1) { var a = r[i]; e[a] = n[a].evaluate(o, s) } return e }, i.reduce = function (t, e) { s.properties = e; for (var i = 0, r = l; i < r.length; i += 1) { var n = r[i]; o.accumulated = t[n], t[n] = a[n].evaluate(o, s) } }, i }(r)).load(o.features) : function (t, e) { return new gt(t, e) }(o, r.geojsonVtOptions) } catch (a) { return i(a) } e.loaded = {}; var u = {}; if (n) { var h = n.finish(); h && (u.resourceTiming = {}, u.resourceTiming[r.source] = JSON.parse(JSON.stringify(h))) } i(null, u) })) } }, i.prototype.coalesce = function () { "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData()) }, i.prototype.reloadTile = function (t, i) { var r = this.loaded; return r && r[t.uid] ? e.prototype.reloadTile.call(this, t, i) : this.loadTile(t, i) }, i.prototype.loadGeoJSON = function (e, i) { if (e.request) t.getJSON(e.request, i); else { if ("string" != typeof e.data) return i(new Error("Input data given to '" + e.source + "' is not a valid GeoJSON object.")); try { return i(null, JSON.parse(e.data)) } catch (t) { return i(new Error("Input data given to '" + e.source + "' is not a valid GeoJSON object.")) } } }, i.prototype.removeSource = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), e() }, i.prototype.getClusterExpansionZoom = function (t, e) { try { e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId)) } catch (t) { e(t) } }, i.prototype.getClusterChildren = function (t, e) { try { e(null, this._geoJSONIndex.getChildren(t.clusterId)) } catch (t) { e(t) } }, i.prototype.getClusterLeaves = function (t, e) { try { e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset)) } catch (t) { e(t) } }, i }(l), bt = function (e) { var i = this; this.self = e, this.actor = new t.Actor(e, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: xt }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (t, e) { if (i.workerSourceTypes[t]) throw new Error('Worker source with name "' + t + '" already registered.'); i.workerSourceTypes[t] = e }, this.self.registerRTLTextPlugin = function (e) { if (t.plugin.isParsed()) throw new Error("RTL text plugin already registered."); t.plugin.applyArabicShaping = e.applyArabicShaping, t.plugin.processBidirectionalText = e.processBidirectionalText, t.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText } }; return bt.prototype.setReferrer = function (t, e) { this.referrer = e }, bt.prototype.setImages = function (t, e, i) { for (var r in this.availableImages[t] = e, this.workerSources[t]) { var n = this.workerSources[t][r]; for (var a in n) n[a].availableImages = e } i() }, bt.prototype.setLayers = function (t, e, i) { this.getLayerIndex(t).replace(e), i() }, bt.prototype.updateLayers = function (t, e, i) { this.getLayerIndex(t).update(e.layers, e.removedIds), i() }, bt.prototype.loadTile = function (t, e, i) { this.getWorkerSource(t, e.type, e.source).loadTile(e, i) }, bt.prototype.loadDEMTile = function (t, e, i) { this.getDEMWorkerSource(t, e.source).loadTile(e, i) }, bt.prototype.reloadTile = function (t, e, i) { this.getWorkerSource(t, e.type, e.source).reloadTile(e, i) }, bt.prototype.abortTile = function (t, e, i) { this.getWorkerSource(t, e.type, e.source).abortTile(e, i) }, bt.prototype.removeTile = function (t, e, i) { this.getWorkerSource(t, e.type, e.source).removeTile(e, i) }, bt.prototype.removeDEMTile = function (t, e) { this.getDEMWorkerSource(t, e.source).removeTile(e) }, bt.prototype.removeSource = function (t, e, i) { if (this.workerSources[t] && this.workerSources[t][e.type] && this.workerSources[t][e.type][e.source]) { var r = this.workerSources[t][e.type][e.source]; delete this.workerSources[t][e.type][e.source], void 0 !== r.removeSource ? r.removeSource(e, i) : i() } }, bt.prototype.loadWorkerSource = function (t, e, i) { try { this.self.importScripts(e.url), i() } catch (t) { i(t.toString()) } }, bt.prototype.syncRTLPluginState = function (e, i, r) { try { t.plugin.setState(i); var n = t.plugin.getPluginURL(); if (t.plugin.isLoaded() && !t.plugin.isParsed() && null != n) { this.self.importScripts(n); var a = t.plugin.isParsed(); r(a ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + n), a) } } catch (t) { r(t.toString()) } }, bt.prototype.getAvailableImages = function (t) { var e = this.availableImages[t]; return e || (e = []), e }, bt.prototype.getLayerIndex = function (t) { var e = this.layerIndexes[t]; return e || (e = this.layerIndexes[t] = new r), e }, bt.prototype.getWorkerSource = function (t, e, i) { var r = this; return this.workerSources[t] || (this.workerSources[t] = {}), this.workerSources[t][e] || (this.workerSources[t][e] = {}), this.workerSources[t][e][i] || (this.workerSources[t][e][i] = new this.workerSourceTypes[e]({ send: function (e, i, n) { r.actor.send(e, i, n, t) } }, this.getLayerIndex(t), this.getAvailableImages(t))), this.workerSources[t][e][i] }, bt.prototype.getDEMWorkerSource = function (t, e) { return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}), this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new h), this.demWorkerSources[t][e] }, bt.prototype.enforceCacheSizeLimit = function (e, i) { t.enforceCacheSizeLimit(i) }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new bt(self)), bt })), r(["./shared"], (function (t) { var e = t.createCommonjsModule((function (t) { function e(t) { return !i(t) } function i(t) { return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () { if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1; var t, e, i = new Blob([""], { type: "text/javascript" }), r = URL.createObjectURL(i); try { e = new Worker(r), t = !0 } catch (e) { t = !1 } return e && e.terminate(), URL.revokeObjectURL(r), t }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () { var t = document.createElement("canvas"); t.width = t.height = 1; var e = t.getContext("2d"); if (!e) return !1; var i = e.getImageData(0, 0, 1, 1); return i && i.width === t.width }() ? (void 0 === r[i = t && t.failIfMajorPerformanceCaveat] && (r[i] = function (t) { var i = function (t) { var i = document.createElement("canvas"), r = Object.create(e.webGLContextAttributes); return r.failIfMajorPerformanceCaveat = t, i.probablySupportsContext ? i.probablySupportsContext("webgl", r) || i.probablySupportsContext("experimental-webgl", r) : i.supportsContext ? i.supportsContext("webgl", r) || i.supportsContext("experimental-webgl", r) : i.getContext("webgl", r) || i.getContext("experimental-webgl", r) }(t); if (!i) return !1; var r = i.createShader(i.VERTEX_SHADER); return !(!r || i.isContextLost()) && (i.shaderSource(r, "void main() {}"), i.compileShader(r), !0 === i.getShaderParameter(r, i.COMPILE_STATUS)) }(i)), r[i] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support"; var i } t.exports ? t.exports = e : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e, window.mapboxgl.notSupportedReason = i); var r = {}; e.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 } })), i = { create: function (e, i, r) { var n = t.window.document.createElement(e); return void 0 !== i && (n.className = i), r && r.appendChild(n), n }, createNS: function (e, i) { return t.window.document.createElementNS(e, i) } }, r = t.window.document && t.window.document.documentElement.style; function n(t) { if (!r) return t[0]; for (var e = 0; e < t.length; e++)if (t[e] in r) return t[e]; return t[0] } var a, o = n(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]); i.disableDrag = function () { r && o && (a = r[o], r[o] = "none") }, i.enableDrag = function () { r && o && (r[o] = a) }; var s = n(["transform", "WebkitTransform"]); i.setTransform = function (t, e) { t.style[s] = e }; var l = !1; try { var u = Object.defineProperty({}, "passive", { get: function () { l = !0 } }); t.window.addEventListener("test", u, u), t.window.removeEventListener("test", u, u) } catch (t) { l = !1 } i.addEventListener = function (t, e, i, r) { void 0 === r && (r = {}), t.addEventListener(e, i, "passive" in r && l ? r : r.capture) }, i.removeEventListener = function (t, e, i, r) { void 0 === r && (r = {}), t.removeEventListener(e, i, "passive" in r && l ? r : r.capture) }; var h = function (e) { e.preventDefault(), e.stopPropagation(), t.window.removeEventListener("click", h, !0) }; function c(t) { var e = t.userImage; return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0) } i.suppressClick = function () { t.window.addEventListener("click", h, !0), t.window.setTimeout((function () { t.window.removeEventListener("click", h, !0) }), 0) }, i.mousePos = function (e, i) { var r = e.getBoundingClientRect(); return new t.Point(i.clientX - r.left - e.clientLeft, i.clientY - r.top - e.clientTop) }, i.touchPos = function (e, i) { for (var r = e.getBoundingClientRect(), n = [], a = 0; a < i.length; a++)n.push(new t.Point(i[a].clientX - r.left - e.clientLeft, i[a].clientY - r.top - e.clientTop)); return n }, i.mouseButton = function (e) { return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button }, i.remove = function (t) { t.parentNode && t.parentNode.removeChild(t) }; var p = function (e) { function i() { e.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = !0 } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.isLoaded = function () { return this.loaded }, i.prototype.setLoaded = function (t) { if (this.loaded !== t && (this.loaded = t, t)) { for (var e = 0, i = this.requestors; e < i.length; e += 1) { var r = i[e]; this._notify(r.ids, r.callback) } this.requestors = [] } }, i.prototype.getImage = function (t) { return this.images[t] }, i.prototype.addImage = function (t, e) { this._validate(t, e) && (this.images[t] = e) }, i.prototype._validate = function (e, i) { var r = !0; return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "stretchX" value'))), r = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "stretchY" value'))), r = !1), this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error('Image "' + e + '" has invalid "content" value'))), r = !1), r }, i.prototype._validateStretch = function (t, e) { if (!t) return !0; for (var i = 0, r = 0, n = t; r < n.length; r += 1) { var a = n[r]; if (a[0] < i || a[1] < a[0] || e < a[1]) return !1; i = a[1] } return !0 }, i.prototype._validateContent = function (t, e) { return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1])) }, i.prototype.updateImage = function (t, e) { e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0 }, i.prototype.removeImage = function (t) { var e = this.images[t]; delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove() }, i.prototype.listImages = function () { return Object.keys(this.images) }, i.prototype.getImages = function (t, e) { var i = !0; if (!this.isLoaded()) for (var r = 0, n = t; r < n.length; r += 1)this.images[n[r]] || (i = !1); this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({ ids: t, callback: e }) }, i.prototype._notify = function (e, i) { for (var r = {}, n = 0, a = e; n < a.length; n += 1) { var o = a[n]; this.images[o] || this.fire(new t.Event("styleimagemissing", { id: o })); var s = this.images[o]; s ? r[o] = { data: s.data.clone(), pixelRatio: s.pixelRatio, sdf: s.sdf, version: s.version, stretchX: s.stretchX, stretchY: s.stretchY, content: s.content, hasRenderCallback: Boolean(s.userImage && s.userImage.render) } : t.warnOnce('Image "' + o + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.') } i(null, r) }, i.prototype.getPixelSize = function () { var t = this.atlasImage; return { width: t.width, height: t.height } }, i.prototype.getPattern = function (e) { var i = this.patterns[e], r = this.getImage(e); if (!r) return null; if (i && i.position.version === r.version) return i.position; if (i) i.position.version = r.version; else { var n = { w: r.data.width + 2, h: r.data.height + 2, x: 0, y: 0 }, a = new t.ImagePosition(n, r); this.patterns[e] = { bin: n, position: a } } return this._updatePatternAtlas(), this.patterns[e].position }, i.prototype.bind = function (e) { var i = e.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.Texture(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE) }, i.prototype._updatePatternAtlas = function () { var e = []; for (var i in this.patterns) e.push(this.patterns[i].bin); var r = t.potpack(e), n = r.w, a = r.h, o = this.atlasImage; for (var s in o.resize({ width: n || 1, height: a || 1 }), this.patterns) { var l = this.patterns[s].bin, u = l.x + 1, h = l.y + 1, c = this.images[s].data, p = c.width, f = c.height; t.RGBAImage.copy(c, o, { x: 0, y: 0 }, { x: u, y: h }, { width: p, height: f }), t.RGBAImage.copy(c, o, { x: 0, y: f - 1 }, { x: u, y: h - 1 }, { width: p, height: 1 }), t.RGBAImage.copy(c, o, { x: 0, y: 0 }, { x: u, y: h + f }, { width: p, height: 1 }), t.RGBAImage.copy(c, o, { x: p - 1, y: 0 }, { x: u - 1, y: h }, { width: 1, height: f }), t.RGBAImage.copy(c, o, { x: 0, y: 0 }, { x: u + p, y: h }, { width: 1, height: f }) } this.dirty = !0 }, i.prototype.beginFrame = function () { this.callbackDispatchedThisFrame = {} }, i.prototype.dispatchRenderCallbacks = function (t) { for (var e = 0, i = t; e < i.length; e += 1) { var r = i[e]; if (!this.callbackDispatchedThisFrame[r]) { this.callbackDispatchedThisFrame[r] = !0; var n = this.images[r]; c(n) && this.updateImage(r, n) } } }, i }(t.Evented), f = y, d = y, m = 1e20; function y(t, e, i, r, n, a) { this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = r || .25, this.fontFamily = n || "sans-serif", this.fontWeight = a || "normal", this.radius = i || 8; var o = this.size = this.fontSize + 2 * this.buffer; this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = o, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.d = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Int16Array(o), this.middle = Math.round(o / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)) } function g(t, e, i, r, n, a, o) { for (var s = 0; s < e; s++) { for (var l = 0; l < i; l++)r[l] = t[l * e + s]; for (_(r, n, a, o, i), l = 0; l < i; l++)t[l * e + s] = n[l] } for (l = 0; l < i; l++) { for (s = 0; s < e; s++)r[s] = t[l * e + s]; for (_(r, n, a, o, e), s = 0; s < e; s++)t[l * e + s] = Math.sqrt(n[s]) } } function _(t, e, i, r, n) { i[0] = 0, r[0] = -m, r[1] = +m; for (var a = 1, o = 0; a < n; a++) { for (var s = (t[a] + a * a - (t[i[o]] + i[o] * i[o])) / (2 * a - 2 * i[o]); s <= r[o];)o--, s = (t[a] + a * a - (t[i[o]] + i[o] * i[o])) / (2 * a - 2 * i[o]); i[++o] = a, r[o] = s, r[o + 1] = +m } for (a = 0, o = 0; a < n; a++) { for (; r[o + 1] < a;)o++; e[a] = (a - i[o]) * (a - i[o]) + t[i[o]] } } y.prototype.draw = function (t) { this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle); for (var e = this.ctx.getImageData(0, 0, this.size, this.size), i = new Uint8ClampedArray(this.size * this.size), r = 0; r < this.size * this.size; r++) { var n = e.data[4 * r + 3] / 255; this.gridOuter[r] = 1 === n ? 0 : 0 === n ? m : Math.pow(Math.max(0, .5 - n), 2), this.gridInner[r] = 1 === n ? m : 0 === n ? 0 : Math.pow(Math.max(0, n - .5), 2) } for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), r = 0; r < this.size * this.size; r++)i[r] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[r] - this.gridInner[r]) / this.radius + this.cutoff)))); return i }, f.default = d; var v = function (t, e) { this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {} }; v.prototype.setURL = function (t) { this.url = t }, v.prototype.getGlyphs = function (e, i) { var r = this, n = []; for (var a in e) for (var o = 0, s = e[a]; o < s.length; o += 1)n.push({ stack: a, id: s[o] }); t.asyncAll(n, (function (t, e) { var i = t.stack, n = t.id, a = r.entries[i]; a || (a = r.entries[i] = { glyphs: {}, requests: {}, ranges: {} }); var o = a.glyphs[n]; if (void 0 === o) { if (o = r._tinySDF(a, i, n)) return a.glyphs[n] = o, void e(null, { stack: i, id: n, glyph: o }); var s = Math.floor(n / 256); if (256 * s > 65535) e(new Error("glyphs > 65535 not supported")); else if (a.ranges[s]) e(null, { stack: i, id: n, glyph: o }); else { var l = a.requests[s]; l || (l = a.requests[s] = [], v.loadGlyphRange(i, s, r.url, r.requestManager, (function (t, e) { if (e) { for (var i in e) r._doesCharSupportLocalGlyph(+i) || (a.glyphs[+i] = e[+i]); a.ranges[s] = !0 } for (var n = 0, o = l; n < o.length; n += 1)(0, o[n])(t, e); delete a.requests[s] }))), l.push((function (t, r) { t ? e(t) : r && e(null, { stack: i, id: n, glyph: r[n] || null }) })) } } else e(null, { stack: i, id: n, glyph: o }) }), (function (t, e) { if (t) i(t); else if (e) { for (var r = {}, n = 0, a = e; n < a.length; n += 1) { var o = a[n], s = o.stack, l = o.id, u = o.glyph; (r[s] || (r[s] = {}))[l] = u && { id: u.id, bitmap: u.bitmap.clone(), metrics: u.metrics } } i(null, r) } })) }, v.prototype._doesCharSupportLocalGlyph = function (e) { return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e) || t.isChar["Hangul Syllables"](e) || t.isChar.Hiragana(e) || t.isChar.Katakana(e)) }, v.prototype._tinySDF = function (e, i, r) { var n = this.localIdeographFontFamily; if (n && this._doesCharSupportLocalGlyph(r)) { var a = e.tinySDF; if (!a) { var o = "400"; /bold/i.test(i) ? o = "900" : /medium/i.test(i) ? o = "500" : /light/i.test(i) && (o = "200"), a = e.tinySDF = new v.TinySDF(24, 3, 8, .25, n, o) } return { id: r, bitmap: new t.AlphaImage({ width: 30, height: 30 }, a.draw(String.fromCharCode(r))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } } } }, v.loadGlyphRange = function (e, i, r, n, a) { var o = 256 * i, s = o + 255, l = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", e).replace("{range}", o + "-" + s), t.ResourceType.Glyphs); t.getArrayBuffer(l, (function (e, i) { if (e) a(e); else if (i) { for (var r = {}, n = 0, o = t.parseGlyphPBF(i); n < o.length; n += 1) { var s = o[n]; r[s.id] = s } a(null, r) } })) }, v.TinySDF = f; var x = function () { this.specification = t.styleSpec.light.position }; x.prototype.possiblyEvaluate = function (e, i) { return t.sphericalToCartesian(e.expression.evaluate(i)) }, x.prototype.interpolate = function (e, i, r) { return { x: t.number(e.x, i.x, r), y: t.number(e.y, i.y, r), z: t.number(e.z, i.z, r) } }; var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x, color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function (e) { function i(i) { e.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i), this._transitioning = this._transitionable.untransitioned() } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getLight = function () { return this._transitionable.serialize() }, i.prototype.setLight = function (e, i) { if (void 0 === i && (i = {}), !this._validate(t.validateLight, e, i)) for (var r in e) { var n = e[r]; t.endsWith(r, "-transition") ? this._transitionable.setTransition(r.slice(0, -"-transition".length), n) : this._transitionable.setValue(r, n) } }, i.prototype.updateTransitions = function (t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) }, i.prototype.hasTransition = function () { return this._transitioning.hasTransition() }, i.prototype.recalculate = function (t) { this.properties = this._transitioning.possiblyEvaluate(t) }, i.prototype._validate = function (e, i, r) { return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: t.styleSpec }))) }, i }(t.Evented), M = function (t, e) { this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {} }; M.prototype.getDash = function (t, e) { var i = t.join(",") + String(e); return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)), this.dashEntry[i] }, M.prototype.getDashRanges = function (t, e, i) { var r = [], n = t.length % 2 == 1 ? -t[t.length - 1] * i : 0, a = t[0] * i, o = !0; r.push({ left: n, right: a, isDash: o, zeroLength: 0 === t[0] }); for (var s = t[0], l = 1; l < t.length; l++) { var u = t[l]; r.push({ left: n = s * i, right: a = (s += u) * i, isDash: o = !o, zeroLength: 0 === u }) } return r }, M.prototype.addRoundDash = function (t, e, i) { for (var r = e / 2, n = -i; n <= i; n++)for (var a = this.width * (this.nextRow + i + n), o = 0, s = t[o], l = 0; l < this.width; l++) { l / s.right > 1 && (s = t[++o]); var u = Math.abs(l - s.left), h = Math.abs(l - s.right), c = Math.min(u, h), p = void 0, f = n / i * (r + 1); if (s.isDash) { var d = r - Math.abs(f); p = Math.sqrt(c * c + d * d) } else p = r - Math.sqrt(c * c + f * f); this.data[a + l] = Math.max(0, Math.min(255, p + 128)) } }, M.prototype.addRegularDash = function (t) { for (var e = t.length - 1; e >= 0; --e) { var i = t[e], r = t[e + 1]; i.zeroLength ? t.splice(e, 1) : r && r.isDash === i.isDash && (r.left = i.left, t.splice(e, 1)) } var n = t[0], a = t[t.length - 1]; n.isDash === a.isDash && (n.left = a.left - this.width, a.right = n.right + this.width); for (var o = this.width * this.nextRow, s = 0, l = t[s], u = 0; u < this.width; u++) { u / l.right > 1 && (l = t[++s]); var h = Math.abs(u - l.left), c = Math.abs(u - l.right), p = Math.min(h, c); this.data[o + u] = Math.max(0, Math.min(255, (l.isDash ? p : -p) + 128)) } }, M.prototype.addDash = function (e, i) { var r = i ? 7 : 0, n = 2 * r + 1; if (this.nextRow + n > this.height) return t.warnOnce("LineAtlas out of space"), null; for (var a = 0, o = 0; o < e.length; o++)a += e[o]; if (0 !== a) { var s = this.width / a, l = this.getDashRanges(e, this.width, s); i ? this.addRoundDash(l, s, r) : this.addRegularDash(l) } var u = { y: (this.nextRow + r + .5) / this.height, height: 2 * r / this.height, width: a }; return this.nextRow += n, this.dirty = !0, u }, M.prototype.bind = function (t) { var e = t.gl; this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data)) }; var S = function e(i, r) { this.workerPool = i, this.actors = [], this.currentActor = 0, this.id = t.uniqueId(); for (var n = this.workerPool.acquire(this.id), a = 0; a < n.length; a++) { var o = new e.Actor(n[a], r, this.id); o.name = "Worker " + a, this.actors.push(o) } }; function E(e, i, r) { var n = function (n, a) { if (n) return r(n); if (a) { var o = t.pick(t.extend(a, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]); a.vector_layers && (o.vectorLayers = a.vector_layers, o.vectorLayerIds = o.vectorLayers.map((function (t) { return t.id }))), o.tiles = i.canonicalizeTileset(o, e.url), r(null, o) } }; return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url), t.ResourceType.Source), n) : t.browser.frame((function () { return n(null, e) })) } S.prototype.broadcast = function (e, i, r) { t.asyncAll(this.actors, (function (t, r) { t.send(e, i, r) }), r = r || function () { }) }, S.prototype.getActor = function () { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] }, S.prototype.remove = function () { this.actors.forEach((function (t) { t.remove() })), this.actors = [], this.workerPool.release(this.id) }, S.Actor = t.Actor; var I = function (e, i, r) { this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = r || 24 }; I.prototype.validateBounds = function (t) { return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90] }, I.prototype.contains = function (e) { var i = Math.pow(2, e.z), r = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i), n = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i), a = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i), o = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i); return e.x >= r && e.x < a && e.y >= n && e.y < o }; var T = function (e) { function i(i, r, n, a) { if (e.call(this), this.id = i, this.dispatcher = n, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(a) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () { var e = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (function (i, r) { e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : r && (t.extend(e, r), r.bounds && (e.tileBounds = new I(r.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(r.tiles, e.map._requestManager._customAccessToken), t.postMapLoadEvent(r.tiles, e.map._getMapId(), e.map._requestManager._skuToken, e.map._requestManager._customAccessToken), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" }))) })) }, i.prototype.loaded = function () { return this._loaded }, i.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, i.prototype.onAdd = function (t) { this.map = t, this.load() }, i.prototype.setSourceProperty = function (t) { this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.map.style.sourceCaches[this.id].clearTiles(), this.load() }, i.prototype.setTiles = function (t) { var e = this; return this.setSourceProperty((function () { e._options.tiles = t })), this }, i.prototype.setUrl = function (t) { var e = this; return this.setSourceProperty((function () { e.url = t, e._options.url = t })), this }, i.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, i.prototype.serialize = function () { return t.extend({}, this._options) }, i.prototype.loadTile = function (e, i) { var r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)), n = { request: this.map._requestManager.transformRequest(r, t.ResourceType.Tile), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }; function a(r, n) { return delete e.request, e.aborted ? i(null) : r && 404 !== r.status ? i(r) : (n && n.resourceTiming && (e.resourceTiming = n.resourceTiming), this.map._refreshExpiredTiles && n && e.setExpiryData(n), e.loadVectorData(n, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null))) } n.request.collectResourceTiming = this._collectResourceTiming, e.actor && "expired" !== e.state ? "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", n, a.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send("loadTile", n, a.bind(this))) }, i.prototype.abortTile = function (t) { t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id }, void 0) }, i.prototype.unloadTile = function (t) { t.unloadVectorData(), t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id }, void 0) }, i.prototype.hasTransition = function () { return !1 }, i }(t.Evented), A = function (e) { function i(i, r, n, a) { e.call(this), this.id = i, this.dispatcher = n, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({ type: "raster" }, r), t.extend(this, t.pick(r, ["url", "scheme", "tileSize"])) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () { var e = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = E(this._options, this.map._requestManager, (function (i, r) { e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : r && (t.extend(e, r), r.bounds && (e.tileBounds = new I(r.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(r.tiles), t.postMapLoadEvent(r.tiles, e.map._getMapId(), e.map._requestManager._skuToken), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" }))) })) }, i.prototype.loaded = function () { return this._loaded }, i.prototype.onAdd = function (t) { this.map = t, this.load() }, i.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, i.prototype.serialize = function () { return t.extend({}, this._options) }, i.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, i.prototype.loadTile = function (e, i) { var r = this, n = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize); e.request = t.getImage(this.map._requestManager.transformRequest(n, t.ResourceType.Tile), (function (n, a) { if (delete e.request, e.aborted) e.state = "unloaded", i(null); else if (n) e.state = "errored", i(n); else if (a) { r.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires; var o = r.map.painter.context, s = o.gl; e.texture = r.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, { useMipmap: !0 }) : (e.texture = new t.Texture(o, a, s.RGBA, { useMipmap: !0 }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), o.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o.extTextureFilterAnisotropicMax)), e.state = "loaded", t.cacheEntryPossiblyAdded(r.dispatcher), i(null) } })) }, i.prototype.abortTile = function (t, e) { t.request && (t.request.cancel(), delete t.request), e() }, i.prototype.unloadTile = function (t, e) { t.texture && this.map.painter.saveTileTexture(t.texture), e() }, i.prototype.hasTransition = function () { return !1 }, i }(t.Evented), P = function (e) { function i(i, r, n, a) { e.call(this, i, r, n, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox" } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.serialize = function () { return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding } }, i.prototype.loadTile = function (e, i) { var r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize); function n(t, r) { t && (e.state = "errored", i(t)), r && (e.dem = r, e.needsHillshadePrepare = !0, e.state = "loaded", i(null)) } e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function (r, a) { if (delete e.request, e.aborted) e.state = "unloaded", i(null); else if (r) e.state = "errored", i(r); else if (a) { this.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires; var o = t.window.ImageBitmap && a instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a : t.browser.getImageData(a, 1), s = { uid: e.uid, coord: e.tileID, source: this.id, rawImageData: o, encoding: this.encoding }; e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send("loadDEMTile", s, n.bind(this))) } }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID) }, i.prototype._getNeighboringTiles = function (e) { var i = e.canonical, r = Math.pow(2, i.z), n = (i.x - 1 + r) % r, a = 0 === i.x ? e.wrap - 1 : e.wrap, o = (i.x + 1 + r) % r, s = i.x + 1 === r ? e.wrap + 1 : e.wrap, l = {}; return l[new t.OverscaledTileID(e.overscaledZ, a, i.z, n, i.y).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, o, i.y).key] = { backfilled: !1 }, i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, n, i.y - 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, o, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < r && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, n, i.y + 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, o, i.y + 1).key] = { backfilled: !1 }), l }, i.prototype.unloadTile = function (t) { t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && t.actor.send("removeDEMTile", { uid: t.uid, source: this.id }) }, i }(A), C = function (e) { function i(i, r, n, a) { e.call(this), this.id = i, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = n.getActor(), this.setEventedParent(a), this._data = r.data, this._options = t.extend({}, r), this._collectResourceTiming = r.collectResourceTiming, this._resourceTiming = [], void 0 !== r.maxzoom && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId; var o = t.EXTENT / this.tileSize; this.workerOptions = t.extend({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (void 0 !== r.buffer ? r.buffer : 128) * o, tolerance: (void 0 !== r.tolerance ? r.tolerance : .375) * o, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== r.clusterMaxZoom ? Math.min(r.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: t.EXTENT, radius: (r.clusterRadius || 50) * o, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () { var e = this; this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function (i) { if (i) e.fire(new t.ErrorEvent(i)); else { var r = { dataType: "source", sourceDataType: "metadata" }; e._collectResourceTiming && e._resourceTiming && e._resourceTiming.length > 0 && (r.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new t.Event("data", r)) } })) }, i.prototype.onAdd = function (t) { this.map = t, this.load() }, i.prototype.setData = function (e) { var i = this; return this._data = e, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function (e) { if (e) i.fire(new t.ErrorEvent(e)); else { var r = { dataType: "source", sourceDataType: "content" }; i._collectResourceTiming && i._resourceTiming && i._resourceTiming.length > 0 && (r.resourceTiming = i._resourceTiming, i._resourceTiming = []), i.fire(new t.Event("data", r)) } })), this }, i.prototype.getClusterExpansionZoom = function (t, e) { return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t, source: this.id }, e), this }, i.prototype.getClusterChildren = function (t, e) { return this.actor.send("geojson.getClusterChildren", { clusterId: t, source: this.id }, e), this }, i.prototype.getClusterLeaves = function (t, e, i, r) { return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t, limit: e, offset: i }, r), this }, i.prototype._updateWorkerData = function (e) { var i = this; this._loaded = !1; var r = t.extend({}, this.workerOptions), n = this._data; "string" == typeof n ? (r.request = this.map._requestManager.transformRequest(t.browser.resolveURL(n), t.ResourceType.Source), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(n), this.actor.send(this.type + ".loadData", r, (function (t, n) { i._removed || n && n.abandoned || (i._loaded = !0, n && n.resourceTiming && n.resourceTiming[i.id] && (i._resourceTiming = n.resourceTiming[i.id].slice(0)), i.actor.send(i.type + ".coalesce", { source: r.source }, null), e(t)) })) }, i.prototype.loaded = function () { return this._loaded }, i.prototype.loadTile = function (e, i) { var r = this, n = e.actor ? "reloadTile" : "loadTile"; e.actor = this.actor, e.request = this.actor.send(n, { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (function (t, a) { return delete e.request, e.unloadVectorData(), e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(a, r.map.painter, "reloadTile" === n), i(null)) })) }, i.prototype.abortTile = function (t) { t.request && (t.request.cancel(), delete t.request), t.aborted = !0 }, i.prototype.unloadTile = function (t) { t.unloadVectorData(), this.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id }) }, i.prototype.onRemove = function () { this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id }) }, i.prototype.serialize = function () { return t.extend({}, this._options, { type: this.type, data: this._data }) }, i.prototype.hasTransition = function () { return !1 }, i }(t.Evented), z = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), k = function (e) { function i(t, i, r, n) { e.call(this), this.id = t, this.dispatcher = r, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(n), this.options = i } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function (e, i) { var r = this; this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (function (n, a) { r._loaded = !0, n ? r.fire(new t.ErrorEvent(n)) : a && (r.image = a, e && (r.coordinates = e), i && i(), r._finishLoading()) })) }, i.prototype.loaded = function () { return this._loaded }, i.prototype.updateImage = function (t) { var e = this; return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, (function () { e.texture = null })), this) : this }, i.prototype._finishLoading = function () { this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" }))) }, i.prototype.onAdd = function (t) { this.map = t, this.load() }, i.prototype.setCoordinates = function (e) { var i = this; this.coordinates = e; var r = e.map(t.MercatorCoordinate.fromLngLat); this.tileID = function (e) { for (var i = 1 / 0, r = 1 / 0, n = -1 / 0, a = -1 / 0, o = 0, s = e; o < s.length; o += 1) { var l = s[o]; i = Math.min(i, l.x), r = Math.min(r, l.y), n = Math.max(n, l.x), a = Math.max(a, l.y) } var u = Math.max(n - i, a - r), h = Math.max(0, Math.floor(-Math.log(u) / Math.LN2)), c = Math.pow(2, h); return new t.CanonicalTileID(h, Math.floor((i + n) / 2 * c), Math.floor((r + a) / 2 * c)) }(r), this.minzoom = this.maxzoom = this.tileID.z; var n = r.map((function (t) { return i.tileID.getTilePoint(t)._round() })); return this._boundsArray = new t.StructArrayLayout4i8, this._boundsArray.emplaceBack(n[0].x, n[0].y, 0, 0), this._boundsArray.emplaceBack(n[1].x, n[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(n[3].x, n[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(n[2].x, n[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this }, i.prototype.prepare = function () { if (0 !== Object.keys(this.tiles).length && this.image) { var e = this.map.painter.context, i = e.gl; for (var r in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, z.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) { var n = this.tiles[r]; "loaded" !== n.state && (n.state = "loaded", n.texture = this.texture) } } }, i.prototype.loadTile = function (t, e) { this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = "errored", e(null)) }, i.prototype.serialize = function () { return { type: "image", url: this.options.url, coordinates: this.coordinates } }, i.prototype.hasTransition = function () { return !1 }, i }(t.Evented), L = function (e) { function i(t, i, r, n) { e.call(this, t, i, r, n), this.roundZoom = !0, this.type = "video", this.options = i } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () { var e = this; this._loaded = !1; var i = this.options; this.urls = []; for (var r = 0, n = i.urls; r < n.length; r += 1)this.urls.push(this.map._requestManager.transformRequest(n[r], t.ResourceType.Source).url); t.getVideo(this.urls, (function (i, r) { e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : r && (e.video = r, e.video.loop = !0, e.video.addEventListener("playing", (function () { e.map.triggerRepaint() })), e.map && e.video.play(), e._finishLoading()) })) }, i.prototype.pause = function () { this.video && this.video.pause() }, i.prototype.play = function () { this.video && this.video.play() }, i.prototype.seek = function (e) { if (this.video) { var i = this.video.seekable; e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i.start(0) + " and " + i.end(0) + "-second mark."))) : this.video.currentTime = e } }, i.prototype.getVideo = function () { return this.video }, i.prototype.onAdd = function (t) { this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) }, i.prototype.prepare = function () { if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) { var e = this.map.painter.context, i = e.gl; for (var r in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, z.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) { var n = this.tiles[r]; "loaded" !== n.state && (n.state = "loaded", n.texture = this.texture) } } }, i.prototype.serialize = function () { return { type: "video", urls: this.urls, coordinates: this.coordinates } }, i.prototype.hasTransition = function () { return this.video && !this.video.paused }, i }(k), D = function (e) { function i(i, r, n, a) { e.call(this, i, r, n, a), r.coordinates ? Array.isArray(r.coordinates) && 4 === r.coordinates.length && !r.coordinates.some((function (t) { return !Array.isArray(t) || 2 !== t.length || t.some((function (t) { return "number" != typeof t })) })) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, 'missing required property "coordinates"'))), r.animate && "boolean" != typeof r.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, 'optional "animate" property must be a boolean value'))), r.canvas ? "string" == typeof r.canvas || r.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, 'missing required property "canvas"'))), this.options = r, this.animate = void 0 === r.animate || r.animate } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint() }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1) }, this._finishLoading()) }, i.prototype.getCanvas = function () { return this.canvas }, i.prototype.onAdd = function (t) { this.map = t, this.load(), this.canvas && this.animate && this.play() }, i.prototype.onRemove = function () { this.pause() }, i.prototype.prepare = function () { var e = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) { var i = this.map.painter.context, r = i.gl; for (var n in this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, z.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new t.Texture(i, this.canvas, r.RGBA, { premultiply: !0 }), this.tiles) { var a = this.tiles[n]; "loaded" !== a.state && (a.state = "loaded", a.texture = this.texture) } } }, i.prototype.serialize = function () { return { type: "canvas", coordinates: this.coordinates } }, i.prototype.hasTransition = function () { return this._playing }, i.prototype._hasInvalidDimensions = function () { for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) { var i = e[t]; if (isNaN(i) || i <= 0) return !0 } return !1 }, i }(k), R = { vector: T, raster: A, "raster-dem": P, geojson: C, video: L, image: k, canvas: D }; function B(e, i) { var r = t.identity([]); return t.translate(r, r, [1, 1, 0]), t.scale(r, r, [.5 * e.width, .5 * e.height, 1]), t.multiply(r, r, e.calculatePosMatrix(i.toUnwrapped())) } function O(t, e, i, r, n, a) { var o = function (t, e, i) { if (t) for (var r = 0, n = t; r < n.length; r += 1) { var a = e[n[r]]; if (a && a.source === i && "fill-extrusion" === a.type) return !0 } else for (var o in e) { var s = e[o]; if (s.source === i && "fill-extrusion" === s.type) return !0 } return !1 }(n && n.layers, e, t.id), s = a.maxPitchScaleFactor(), l = t.tilesIn(r, s, o); l.sort(F); for (var u = [], h = 0, c = l; h < c.length; h += 1) { var p = c[h]; u.push({ wrappedTileID: p.tileID.wrapped().key, queryResults: p.tile.queryRenderedFeatures(e, i, t._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, n, a, s, B(t.transform, p.tileID)) }) } var f = function (t) { for (var e = {}, i = {}, r = 0, n = t; r < n.length; r += 1) { var a = n[r], o = a.queryResults, s = a.wrappedTileID, l = i[s] = i[s] || {}; for (var u in o) for (var h = o[u], c = l[u] = l[u] || {}, p = e[u] = e[u] || [], f = 0, d = h; f < d.length; f += 1) { var m = d[f]; c[m.featureIndex] || (c[m.featureIndex] = !0, p.push(m)) } } return e }(u); for (var d in f) f[d].forEach((function (e) { var i = e.feature, r = t.getFeatureState(i.layer["source-layer"], i.id); i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = r })); return f } function F(t, e) { var i = t.tileID, r = e.tileID; return i.overscaledZ - r.overscaledZ || i.canonical.y - r.canonical.y || i.wrap - r.wrap || i.canonical.x - r.canonical.x } var U = function (t, e) { this.max = t, this.onRemove = e, this.reset() }; U.prototype.reset = function () { for (var t in this.data) for (var e = 0, i = this.data[t]; e < i.length; e += 1) { var r = i[e]; r.timeout && clearTimeout(r.timeout), this.onRemove(r.value) } return this.data = {}, this.order = [], this }, U.prototype.add = function (t, e, i) { var r = this, n = t.wrapped().key; void 0 === this.data[n] && (this.data[n] = []); var a = { value: e, timeout: void 0 }; if (void 0 !== i && (a.timeout = setTimeout((function () { r.remove(t, a) }), i)), this.data[n].push(a), this.order.push(n), this.order.length > this.max) { var o = this._getAndRemoveByKey(this.order[0]); o && this.onRemove(o) } return this }, U.prototype.has = function (t) { return t.wrapped().key in this.data }, U.prototype.getAndRemove = function (t) { return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null }, U.prototype._getAndRemoveByKey = function (t) { var e = this.data[t].shift(); return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value }, U.prototype.getByKey = function (t) { var e = this.data[t]; return e ? e[0].value : null }, U.prototype.get = function (t) { return this.has(t) ? this.data[t.wrapped().key][0].value : null }, U.prototype.remove = function (t, e) { if (!this.has(t)) return this; var i = t.wrapped().key, r = void 0 === e ? 0 : this.data[i].indexOf(e), n = this.data[i][r]; return this.data[i].splice(r, 1), n.timeout && clearTimeout(n.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(n.value), this.order.splice(this.order.indexOf(i), 1), this }, U.prototype.setMaxSize = function (t) { for (this.max = t; this.order.length > this.max;) { var e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this }, U.prototype.filter = function (t) { var e = []; for (var i in this.data) for (var r = 0, n = this.data[i]; r < n.length; r += 1) { var a = n[r]; t(a.value) || e.push(a) } for (var o = 0, s = e; o < s.length; o += 1) { var l = s[o]; this.remove(l.value.tileID, l) } }; var N = function (t, e, i) { this.context = t; var r = t.gl; this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer }; N.prototype.bind = function () { this.context.bindElementBuffer.set(this.buffer) }, N.prototype.updateData = function (t) { var e = this.context.gl; this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer) }, N.prototype.destroy = function () { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) }; var V = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, j = function (t, e, i, r) { this.length = e.length, this.attributes = i, this.itemSize = e.bytesPerElement, this.dynamicDraw = r, this.context = t; var n = t.gl; this.buffer = n.createBuffer(), t.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer }; j.prototype.bind = function () { this.context.bindVertexBuffer.set(this.buffer) }, j.prototype.updateData = function (t) { var e = this.context.gl; this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer) }, j.prototype.enableAttributes = function (t, e) { for (var i = 0; i < this.attributes.length; i++) { var r = e.attributes[this.attributes[i].name]; void 0 !== r && t.enableVertexAttribArray(r) } }, j.prototype.setVertexAttribPointers = function (t, e, i) { for (var r = 0; r < this.attributes.length; r++) { var n = this.attributes[r], a = e.attributes[n.name]; void 0 !== a && t.vertexAttribPointer(a, n.components, t[V[n.type]], !1, this.itemSize, n.offset + this.itemSize * (i || 0)) } }, j.prototype.destroy = function () { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) }; var q = function (t) { this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1 }; q.prototype.get = function () { return this.current }, q.prototype.set = function (t) { }, q.prototype.getDefault = function () { return this.default }, q.prototype.setDefault = function () { this.set(this.default) }; var G = function (e) { function i() { e.apply(this, arguments) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () { return t.Color.transparent }, i.prototype.set = function (t) { var e = this.current; (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) }, i }(q), Z = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 1 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1) }, e }(q), X = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1) }, e }(q), W = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return [!0, !0, !0, !0] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) }, e }(q), K = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1) }, e }(q), H = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 255 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1) }, e }(q), $ = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } }, e.prototype.set = function (t) { var e = this.current; (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1) }, e }(q), J = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [t.KEEP, t.KEEP, t.KEEP] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1) }, e }(q), Y = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1 } }, e }(q), Q = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return [0, 1] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1) }, e }(q), tt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1 } }, e }(q), et = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.LESS }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1) }, e }(q), it = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1 } }, e }(q), rt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [t.ONE, t.ZERO] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1) }, e }(q), nt = function (e) { function i() { e.apply(this, arguments) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () { return t.Color.transparent }, i.prototype.set = function (t) { var e = this.current; (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) }, i }(q), at = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.FUNC_ADD }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1) }, e }(q), ot = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1 } }, e }(q), st = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.BACK }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1) }, e }(q), lt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.CCW }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1) }, e }(q), ut = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1) }, e }(q), ht = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return this.gl.TEXTURE0 }, e.prototype.set = function (t) { (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1) }, e }(q), ct = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { var t = this.gl; return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight] }, e.prototype.set = function (t) { var e = this.current; (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) }, e }(q), pt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1 } }, e }(q), ft = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1 } }, e }(q), dt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1 } }, e }(q), mt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1 } }, e }(q), yt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { var e = this.gl; e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1 }, e }(q), gt = function (t) { function e(e) { t.call(this, e), this.vao = e.extVertexArrayObject } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e.prototype.set = function (t) { this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1) }, e }(q), _t = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return 4 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1 } }, e }(q), vt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1 } }, e }(q), xt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return !1 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { var e = this.gl; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1 } }, e }(q), bt = function (t) { function e(e, i) { t.call(this, e), this.context = e, this.parent = i } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () { return null }, e }(q), wt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.setDirty = function () { this.dirty = !0 }, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { this.context.bindFramebuffer.set(this.parent); var e = this.gl; e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1 } }, e }(bt), Mt = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) { if (t !== this.current || this.dirty) { this.context.bindFramebuffer.set(this.parent); var e = this.gl; e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1 } }, e }(bt), St = function (t, e, i, r) { this.context = t, this.width = e, this.height = i; var n = this.framebuffer = t.gl.createFramebuffer(); this.colorAttachment = new wt(t, n), r && (this.depthAttachment = new Mt(t, n)) }; St.prototype.destroy = function () { var t = this.context.gl, e = this.colorAttachment.get(); if (e && t.deleteTexture(e), this.depthAttachment) { var i = this.depthAttachment.get(); i && t.deleteRenderbuffer(i) } t.deleteFramebuffer(this.framebuffer) }; var Et = function (t, e, i) { this.func = t, this.mask = e, this.range = i }; Et.ReadOnly = !1, Et.ReadWrite = !0, Et.disabled = new Et(519, Et.ReadOnly, [0, 1]); var It = function (t, e, i, r, n, a) { this.test = t, this.ref = e, this.mask = i, this.fail = r, this.depthFail = n, this.pass = a }; It.disabled = new It({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680); var Tt = function (t, e, i) { this.blendFunction = t, this.blendColor = e, this.mask = i }; Tt.disabled = new Tt(Tt.Replace = [1, 0], t.Color.transparent, [!1, !1, !1, !1]), Tt.unblended = new Tt(Tt.Replace, t.Color.transparent, [!0, !0, !0, !0]), Tt.alphaBlended = new Tt([1, 771], t.Color.transparent, [!0, !0, !0, !0]); var At = function (t, e, i) { this.enable = t, this.mode = e, this.frontFace = i }; At.disabled = new At(!1, 1029, 2305), At.backCCW = new At(!0, 1029, 2305); var Pt = function (t) { this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new G(this), this.clearDepth = new Z(this), this.clearStencil = new X(this), this.colorMask = new W(this), this.depthMask = new K(this), this.stencilMask = new H(this), this.stencilFunc = new $(this), this.stencilOp = new J(this), this.stencilTest = new Y(this), this.depthRange = new Q(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new rt(this), this.blendColor = new nt(this), this.blendEquation = new at(this), this.cullFace = new ot(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ut(this), this.activeTexture = new ht(this), this.viewport = new ct(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new ft(this), this.bindTexture = new dt(this), this.bindVertexBuffer = new mt(this), this.bindElementBuffer = new yt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new _t(this), this.pixelStoreUnpackPremultiplyAlpha = new vt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE) }; Pt.prototype.setDefault = function () { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault() }, Pt.prototype.setDirty = function () { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0 }, Pt.prototype.createIndexBuffer = function (t, e) { return new N(this, t, e) }, Pt.prototype.createVertexBuffer = function (t, e, i) { return new j(this, t, e, i) }, Pt.prototype.createRenderbuffer = function (t, e, i) { var r = this.gl, n = r.createRenderbuffer(); return this.bindRenderbuffer.set(n), r.renderbufferStorage(r.RENDERBUFFER, t, e, i), this.bindRenderbuffer.set(null), n }, Pt.prototype.createFramebuffer = function (t, e, i) { return new St(this, t, e, i) }, Pt.prototype.clear = function (t) { var e = t.color, i = t.depth, r = this.gl, n = 0; e && (n |= r.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== i && (n |= r.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), r.clear(n) }, Pt.prototype.setCullFace = function (t) { !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace)) }, Pt.prototype.setDepthMode = function (t) { t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1) }, Pt.prototype.setStencilMode = function (t) { t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1) }, Pt.prototype.setColorMode = function (e) { t.deepEqual(e.blendFunction, Tt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask) }, Pt.prototype.unbindVAO = function () { this.extVertexArrayObject && this.bindVertexArrayOES.set(null) }; var Ct = function (e) { function i(i, r, n) { var a = this; e.call(this), this.id = i, this.dispatcher = n, this.on("data", (function (t) { "source" === t.dataType && "metadata" === t.sourceDataType && (a._sourceLoaded = !0), a._sourceLoaded && !a._paused && "source" === t.dataType && "content" === t.sourceDataType && (a.reload(), a.transform && a.update(a.transform)) })), this.on("error", (function () { a._sourceErrored = !0 })), this._source = function (e, i, r, n) { var a = new R[i.type](e, i, r, n); if (a.id !== e) throw new Error("Expected Source id to be " + e + " instead of " + a.id); return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a), a }(i, r, n, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.onAdd = function (t) { this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t) }, i.prototype.onRemove = function (t) { this._source && this._source.onRemove && this._source.onRemove(t) }, i.prototype.loaded = function () { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; if (!this._source.loaded()) return !1; for (var t in this._tiles) { var e = this._tiles[t]; if ("loaded" !== e.state && "errored" !== e.state) return !1 } return !0 }, i.prototype.getSource = function () { return this._source }, i.prototype.pause = function () { this._paused = !0 }, i.prototype.resume = function () { if (this._paused) { var t = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform) } }, i.prototype._loadTile = function (t, e) { return this._source.loadTile(t, e) }, i.prototype._unloadTile = function (t) { if (this._source.unloadTile) return this._source.unloadTile(t, (function () { })) }, i.prototype._abortTile = function (t) { if (this._source.abortTile) return this._source.abortTile(t, (function () { })) }, i.prototype.serialize = function () { return this._source.serialize() }, i.prototype.prepare = function (t) { for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) { var i = this._tiles[e]; i.upload(t), i.prepare(this.map.style.imageManager) } }, i.prototype.getIds = function () { return t.values(this._tiles).map((function (t) { return t.tileID })).sort(zt).map((function (t) { return t.key })) }, i.prototype.getRenderableIds = function (e) { var i = this, r = []; for (var n in this._tiles) this._isIdRenderable(n, e) && r.push(this._tiles[n]); return e ? r.sort((function (e, r) { var n = e.tileID, a = r.tileID, o = new t.Point(n.canonical.x, n.canonical.y)._rotate(i.transform.angle), s = new t.Point(a.canonical.x, a.canonical.y)._rotate(i.transform.angle); return n.overscaledZ - a.overscaledZ || s.y - o.y || s.x - o.x })).map((function (t) { return t.tileID.key })) : r.map((function (t) { return t.tileID })).sort(zt).map((function (t) { return t.key })) }, i.prototype.hasRenderableParent = function (t) { var e = this.findLoadedParent(t, 0); return !!e && this._isIdRenderable(e.tileID.key) }, i.prototype._isIdRenderable = function (t, e) { return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade()) }, i.prototype.reload = function () { if (this._paused) this._shouldReloadOnResume = !0; else for (var t in this._cache.reset(), this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading") }, i.prototype._reloadTile = function (t, e) { var i = this._tiles[t]; i && ("loading" !== i.state && (i.state = e), this._loadTile(i, this._tileLoaded.bind(this, i, t, e))) }, i.prototype._tileLoaded = function (e, i, r, n) { if (n) return e.state = "errored", void (404 !== n.status ? this._source.fire(new t.ErrorEvent(n, { tile: e })) : this.update(this.transform)); e.timeAdded = t.browser.now(), "expired" === r && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e, coord: e.tileID })) }, i.prototype._backfillDEM = function (t) { for (var e = this.getRenderableIds(), i = 0; i < e.length; i++) { var r = e[i]; if (t.neighboringTiles && t.neighboringTiles[r]) { var n = this.getTileByID(r); a(t, n), a(n, t) } } function a(t, e) { t.needsHillshadePrepare = !0; var i = e.tileID.canonical.x - t.tileID.canonical.x, r = e.tileID.canonical.y - t.tileID.canonical.y, n = Math.pow(2, t.tileID.canonical.z), a = e.tileID.key; 0 === i && 0 === r || Math.abs(r) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + n) ? i += n : 1 === Math.abs(i - n) && (i -= n)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, r), t.neighboringTiles && t.neighboringTiles[a] && (t.neighboringTiles[a].backfilled = !0))) } }, i.prototype.getTile = function (t) { return this.getTileByID(t.key) }, i.prototype.getTileByID = function (t) { return this._tiles[t] }, i.prototype._retainLoadedChildren = function (t, e, i, r) { for (var n in this._tiles) { var a = this._tiles[n]; if (!(r[n] || !a.hasData() || a.tileID.overscaledZ <= e || a.tileID.overscaledZ > i)) { for (var o = a.tileID; a && a.tileID.overscaledZ > e + 1;) { var s = a.tileID.scaledTo(a.tileID.overscaledZ - 1); (a = this._tiles[s.key]) && a.hasData() && (o = s) } for (var l = o; l.overscaledZ > e;)if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) { r[o.key] = o; break } } } }, i.prototype.findLoadedParent = function (t, e) { if (t.key in this._loadedParentTiles) { var i = this._loadedParentTiles[t.key]; return i && i.tileID.overscaledZ >= e ? i : null } for (var r = t.overscaledZ - 1; r >= e; r--) { var n = t.scaledTo(r), a = this._getLoadedTile(n); if (a) return a } }, i.prototype._getLoadedTile = function (t) { var e = this._tiles[t.key]; return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key) }, i.prototype.updateCacheSize = function (t) { var e = Math.ceil(t.width / this._source.tileSize) + 1, i = Math.ceil(t.height / this._source.tileSize) + 1, r = Math.floor(e * i * 5), n = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r; this._cache.setMaxSize(n) }, i.prototype.handleWrapJump = function (t) { var e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360); if (this._prevLng = t, e) { var i = {}; for (var r in this._tiles) { var n = this._tiles[r]; n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), i[n.tileID.key] = n } for (var a in this._tiles = i, this._timers) clearTimeout(this._timers[a]), delete this._timers[a]; for (var o in this._tiles) this._setTileReloadTimer(o, this._tiles[o]) } }, i.prototype.update = function (e) { var r = this; if (this.transform = e, this._sourceLoaded && !this._paused) { var n; this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? n = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((function (e) { return new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y) })) : (n = e.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (n = n.filter((function (t) { return r._source.hasTile(t) })))) : n = []; var a = e.coveringZoomLevel(this._source), o = Math.max(a - i.maxOverzooming, this._source.minzoom), s = Math.max(a + i.maxUnderzooming, this._source.minzoom), l = this._updateRetainedTiles(n, a); if (kt(this._source.type)) { for (var u = {}, h = {}, c = 0, p = Object.keys(l); c < p.length; c += 1) { var f = p[c], d = l[f], m = this._tiles[f]; if (m && !(m.fadeEndTime && m.fadeEndTime <= t.browser.now())) { var y = this.findLoadedParent(d, o); y && (this._addTile(y.tileID), u[y.tileID.key] = y.tileID), h[f] = d } } for (var g in this._retainLoadedChildren(h, a, s, l), u) l[g] || (this._coveredTiles[g] = !0, l[g] = u[g]) } for (var _ in l) this._tiles[_].clearFadeHold(); for (var v = 0, x = t.keysDifference(this._tiles, l); v < x.length; v += 1) { var b = x[v], w = this._tiles[b]; w.hasSymbolBuckets && !w.holdingForFade() ? w.setHoldDuration(this.map._fadeDuration) : w.hasSymbolBuckets && !w.symbolFadeFinished() || this._removeTile(b) } this._updateLoadedParentTileCache() } }, i.prototype.releaseSymbolFadeTiles = function () { for (var t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t) }, i.prototype._updateRetainedTiles = function (t, e) { for (var r = {}, n = {}, a = Math.max(e - i.maxOverzooming, this._source.minzoom), o = Math.max(e + i.maxUnderzooming, this._source.minzoom), s = {}, l = 0, u = t; l < u.length; l += 1) { var h = u[l], c = this._addTile(h); r[h.key] = h, c.hasData() || e < this._source.maxzoom && (s[h.key] = h) } this._retainLoadedChildren(s, e, o, r); for (var p = 0, f = t; p < f.length; p += 1) { var d = f[p], m = this._tiles[d.key]; if (!m.hasData()) { if (e + 1 > this._source.maxzoom) { var y = d.children(this._source.maxzoom)[0], g = this.getTile(y); if (g && g.hasData()) { r[y.key] = y; continue } } else { var _ = d.children(this._source.maxzoom); if (r[_[0].key] && r[_[1].key] && r[_[2].key] && r[_[3].key]) continue } for (var v = m.wasRequested(), x = d.overscaledZ - 1; x >= a; --x) { var b = d.scaledTo(x); if (n[b.key]) break; if (n[b.key] = !0, !(m = this.getTile(b)) && v && (m = this._addTile(b)), m && (r[b.key] = b, v = m.wasRequested(), m.hasData())) break } } } return r }, i.prototype._updateLoadedParentTileCache = function () { for (var t in this._loadedParentTiles = {}, this._tiles) { for (var e = [], i = void 0, r = this._tiles[t].tileID; r.overscaledZ > 0;) { if (r.key in this._loadedParentTiles) { i = this._loadedParentTiles[r.key]; break } e.push(r.key); var n = r.scaledTo(r.overscaledZ - 1); if (i = this._getLoadedTile(n)) break; r = n } for (var a = 0, o = e; a < o.length; a += 1)this._loadedParentTiles[o[a]] = i } }, i.prototype._addTile = function (e) { var i = this._tiles[e.key]; if (i) return i; (i = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i))); var r = Boolean(i); return r || (i = new t.Tile(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state))), i ? (i.uses++, this._tiles[e.key] = i, r || this._source.fire(new t.Event("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i) : null }, i.prototype._setTileReloadTimer = function (t, e) { var i = this; t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]); var r = e.getExpiryTimeout(); r && (this._timers[t] = setTimeout((function () { i._reloadTile(t, "expired"), delete i._timers[t] }), r)) }, i.prototype._removeTile = function (t) { var e = this._tiles[t]; e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e)))) }, i.prototype.clearTiles = function () { for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(t); this._cache.reset() }, i.prototype.tilesIn = function (e, i, r) { var n = this, a = [], o = this.transform; if (!o) return a; for (var s = r ? o.getCameraQueryGeometry(e) : e, l = e.map((function (t) { return o.pointCoordinate(t) })), u = s.map((function (t) { return o.pointCoordinate(t) })), h = this.getIds(), c = 1 / 0, p = 1 / 0, f = -1 / 0, d = -1 / 0, m = 0, y = u; m < y.length; m += 1) { var g = y[m]; c = Math.min(c, g.x), p = Math.min(p, g.y), f = Math.max(f, g.x), d = Math.max(d, g.y) } for (var _ = function (e) { var r = n._tiles[h[e]]; if (!r.holdingForFade()) { var s = r.tileID, m = Math.pow(2, o.zoom - r.tileID.overscaledZ), y = i * r.queryPadding * t.EXTENT / r.tileSize / m, g = [s.getTilePoint(new t.MercatorCoordinate(c, p)), s.getTilePoint(new t.MercatorCoordinate(f, d))]; if (g[0].x - y < t.EXTENT && g[0].y - y < t.EXTENT && g[1].x + y >= 0 && g[1].y + y >= 0) { var _ = l.map((function (t) { return s.getTilePoint(t) })), v = u.map((function (t) { return s.getTilePoint(t) })); a.push({ tile: r, tileID: s, queryGeometry: _, cameraQueryGeometry: v, scale: m }) } } }, v = 0; v < h.length; v++)_(v); return a }, i.prototype.getVisibleCoordinates = function (t) { for (var e = this, i = this.getRenderableIds(t).map((function (t) { return e._tiles[t].tileID })), r = 0, n = i; r < n.length; r += 1) { var a = n[r]; a.posMatrix = this.transform.calculatePosMatrix(a.toUnwrapped()) } return i }, i.prototype.hasTransition = function () { if (this._source.hasTransition()) return !0; if (kt(this._source.type)) for (var e in this._tiles) { var i = this._tiles[e]; if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t.browser.now()) return !0 } return !1 }, i.prototype.setFeatureState = function (t, e, i) { this._state.updateState(t = t || "_geojsonTileLayer", e, i) }, i.prototype.removeFeatureState = function (t, e, i) { this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i) }, i.prototype.getFeatureState = function (t, e) { return this._state.getState(t = t || "_geojsonTileLayer", e) }, i.prototype.setDependencies = function (t, e, i) { var r = this._tiles[t]; r && r.setDependencies(e, i) }, i.prototype.reloadTilesForDependencies = function (t, e) { for (var i in this._tiles) this._tiles[i].hasDependency(t, e) && this._reloadTile(i, "reloading"); this._cache.filter((function (i) { return !i.hasDependency(t, e) })) }, i }(t.Evented); function zt(t, e) { var i = Math.abs(2 * t.wrap) - +(t.wrap < 0), r = Math.abs(2 * e.wrap) - +(e.wrap < 0); return t.overscaledZ - e.overscaledZ || r - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x } function kt(t) { return "raster" === t || "image" === t || "video" === t } function Lt() { return new t.window.Worker(Hn.workerUrl) } Ct.maxOverzooming = 10, Ct.maxUnderzooming = 3; var Dt = "mapboxgl_preloaded_worker_pool", Rt = function () { this.active = {} }; Rt.prototype.acquire = function (t) { if (!this.workers) for (this.workers = []; this.workers.length < Rt.workerCount;)this.workers.push(new Lt); return this.active[t] = !0, this.workers.slice() }, Rt.prototype.release = function (t) { delete this.active[t], 0 === this.numActive() && (this.workers.forEach((function (t) { t.terminate() })), this.workers = null) }, Rt.prototype.isPreloaded = function () { return !!this.active[Dt] }, Rt.prototype.numActive = function () { return Object.keys(this.active).length }; var Bt, Ot = Math.floor(t.browser.hardwareConcurrency / 2); function Ft() { return Bt || (Bt = new Rt), Bt } function Ut(e, i) { var r = {}; for (var n in e) "ref" !== n && (r[n] = e[n]); return t.refProperties.forEach((function (t) { t in i && (r[t] = i[t]) })), r } function Nt(t) { t = t.slice(); for (var e = Object.create(null), i = 0; i < t.length; i++)e[t[i].id] = t[i]; for (var r = 0; r < t.length; r++)"ref" in t[r] && (t[r] = Ut(t[r], e[t[r].ref])); return t } Rt.workerCount = Math.max(Math.min(Ot, 6), 1); var Vt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" }; function jt(t, e, i) { i.push({ command: Vt.addSource, args: [t, e[t]] }) } function qt(t, e, i) { e.push({ command: Vt.removeSource, args: [t] }), i[t] = !0 } function Gt(t, e, i, r) { qt(t, i, r), jt(t, e, i) } function Zt(e, i, r) { var n; for (n in e[r]) if (e[r].hasOwnProperty(n) && "data" !== n && !t.deepEqual(e[r][n], i[r][n])) return !1; for (n in i[r]) if (i[r].hasOwnProperty(n) && "data" !== n && !t.deepEqual(e[r][n], i[r][n])) return !1; return !0 } function Xt(e, i, r, n, a, o) { var s; for (s in i = i || {}, e = e || {}) e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || r.push({ command: o, args: [n, s, i[s], a] })); for (s in i) i.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || r.push({ command: o, args: [n, s, i[s], a] })) } function Wt(t) { return t.id } function Kt(t, e) { return t[e.id] = e, t } var Ht = function (t, e) { this.reset(t, e) }; Ht.prototype.reset = function (t, e) { this.points = t || [], this._distances = [0]; for (var i = 1; i < this.points.length; i++)this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding }, Ht.prototype.lerp = function (e) { if (1 === this.points.length) return this.points[0]; e = t.clamp(e, 0, 1); for (var i = 1, r = this._distances[i], n = e * this.paddedLength + this.padding; r < n && i < this._distances.length;)r = this._distances[++i]; var a = i - 1, o = this._distances[a], s = r - o, l = s > 0 ? (n - o) / s : 0; return this.points[a].mult(1 - l).add(this.points[i].mult(l)) }; var $t = function (t, e, i) { var r = this.boxCells = [], n = this.circleCells = []; this.xCellCount = Math.ceil(t / i), this.yCellCount = Math.ceil(e / i); for (var a = 0; a < this.xCellCount * this.yCellCount; a++)r.push([]), n.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0 }; function Jt(e, i, r, n, a) { var o = t.create(); return i ? (t.scale(o, o, [1 / a, 1 / a, 1]), r || t.rotateZ(o, o, n.angle)) : t.multiply(o, n.labelPlaneMatrix, e), o } function Yt(e, i, r, n, a) { if (i) { var o = t.clone(e); return t.scale(o, o, [a, a, 1]), r || t.rotateZ(o, o, -n.angle), o } return n.glCoordMatrix } function Qt(e, i) { var r = [e.x, e.y, 0, 1]; he(r, r, i); var n = r[3]; return { point: new t.Point(r[0] / n, r[1] / n), signedDistanceFromCamera: n } } function te(t, e) { return .5 + t / e * .5 } function ee(t, e) { var i = t[0] / t[3], r = t[1] / t[3]; return i >= -e[0] && i <= e[0] && r >= -e[1] && r <= e[1] } function ie(e, i, r, n, a, o, s, l) { var u = n ? e.textSizeData : e.iconSizeData, h = t.evaluateSizeForZoom(u, r.transform.zoom), c = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], p = n ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray; p.clear(); for (var f = e.lineVertexArray, d = n ? e.text.placedSymbolArray : e.icon.placedSymbolArray, m = r.transform.width / r.transform.height, y = !1, g = 0; g < d.length; g++) { var _ = d.get(g); if (_.hidden || _.writingMode === t.WritingMode.vertical && !y) ue(_.numGlyphs, p); else { y = !1; var v = [_.anchorX, _.anchorY, 0, 1]; if (t.transformMat4(v, v, i), ee(v, c)) { var x = te(r.transform.cameraToCenterDistance, v[3]), b = t.evaluateSizeForFeature(u, h, _), w = s ? b / x : b * x, M = new t.Point(_.anchorX, _.anchorY), S = Qt(M, a).point, E = {}, I = ae(_, w, !1, l, i, a, o, e.glyphOffsetArray, f, p, S, M, E, m); y = I.useVertical, (I.notEnoughRoom || y || I.needsFlipping && ae(_, w, !0, l, i, a, o, e.glyphOffsetArray, f, p, S, M, E, m).notEnoughRoom) && ue(_.numGlyphs, p) } else ue(_.numGlyphs, p) } } n ? e.text.dynamicLayoutVertexBuffer.updateData(p) : e.icon.dynamicLayoutVertexBuffer.updateData(p) } function re(t, e, i, r, n, a, o, s, l, u, h) { var c = s.glyphStartIndex + s.numGlyphs, p = s.lineStartIndex, f = s.lineStartIndex + s.lineLength, d = e.getoffsetX(s.glyphStartIndex), m = e.getoffsetX(c - 1), y = se(t * d, i, r, n, a, o, s.segment, p, f, l, u, h); if (!y) return null; var g = se(t * m, i, r, n, a, o, s.segment, p, f, l, u, h); return g ? { first: y, last: g } : null } function ne(e, i, r, n) { return e === t.WritingMode.horizontal && Math.abs(r.y - i.y) > Math.abs(r.x - i.x) * n ? { useVertical: !0 } : (e === t.WritingMode.vertical ? i.y < r.y : i.x > r.x) ? { needsFlipping: !0 } : null } function ae(e, i, r, n, a, o, s, l, u, h, c, p, f, d) { var m, y = i / 24, g = e.lineOffsetX * y, _ = e.lineOffsetY * y; if (e.numGlyphs > 1) { var v = e.glyphStartIndex + e.numGlyphs, x = e.lineStartIndex, b = e.lineStartIndex + e.lineLength, w = re(y, l, g, _, r, c, p, e, u, o, f); if (!w) return { notEnoughRoom: !0 }; var M = Qt(w.first.point, s).point, S = Qt(w.last.point, s).point; if (n && !r) { var E = ne(e.writingMode, M, S, d); if (E) return E } m = [w.first]; for (var I = e.glyphStartIndex + 1; I < v - 1; I++)m.push(se(y * l.getoffsetX(I), g, _, r, c, p, e.segment, x, b, u, o, f)); m.push(w.last) } else { if (n && !r) { var T = Qt(p, a).point, A = e.lineStartIndex + e.segment + 1, P = new t.Point(u.getx(A), u.gety(A)), C = Qt(P, a), z = C.signedDistanceFromCamera > 0 ? C.point : oe(p, P, T, 1, a), k = ne(e.writingMode, T, z, d); if (k) return k } var L = se(y * l.getoffsetX(e.glyphStartIndex), g, _, r, c, p, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, u, o, f); if (!L) return { notEnoughRoom: !0 }; m = [L] } for (var D = 0, R = m; D < R.length; D += 1) { var B = R[D]; t.addDynamicAttributes(h, B.point, B.angle) } return {} } function oe(t, e, i, r, n) { var a = Qt(t.add(t.sub(e)._unit()), n).point, o = i.sub(a); return i.add(o._mult(r / o.mag())) } function se(e, i, r, n, a, o, s, l, u, h, c, p) { var f = n ? e - i : e + i, d = f > 0 ? 1 : -1, m = 0; n && (d *= -1, m = Math.PI), d < 0 && (m += Math.PI); for (var y = d > 0 ? l + s : l + s + 1, g = a, _ = a, v = 0, x = 0, b = Math.abs(f), w = []; v + x <= b;) { if ((y += d) < l || y >= u) return null; if (_ = g, w.push(g), void 0 === (g = p[y])) { var M = new t.Point(h.getx(y), h.gety(y)), S = Qt(M, c); if (S.signedDistanceFromCamera > 0) g = p[y] = S.point; else { var E = y - d; g = oe(0 === v ? o : new t.Point(h.getx(E), h.gety(E)), M, _, b - v + 1, c) } } v += x, x = _.dist(g) } var I = (b - v) / x, T = g.sub(_), A = T.mult(I)._add(_); A._add(T._unit()._perp()._mult(r * d)); var P = m + Math.atan2(g.y - _.y, g.x - _.x); return w.push(A), { point: A, angle: P, path: w } } $t.prototype.keysLength = function () { return this.boxKeys.length + this.circleKeys.length }, $t.prototype.insert = function (t, e, i, r, n) { this._forEachCell(e, i, r, n, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(r), this.bboxes.push(n) }, $t.prototype.insertCircle = function (t, e, i, r) { this._forEachCell(e - r, i - r, e + r, i + r, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(i), this.circles.push(r) }, $t.prototype._insertBoxCell = function (t, e, i, r, n, a) { this.boxCells[n].push(a) }, $t.prototype._insertCircleCell = function (t, e, i, r, n, a) { this.circleCells[n].push(a) }, $t.prototype._query = function (t, e, i, r, n, a) { if (i < 0 || t > this.width || r < 0 || e > this.height) return !n && []; var o = []; if (t <= 0 && e <= 0 && this.width <= i && this.height <= r) { if (n) return !0; for (var s = 0; s < this.boxKeys.length; s++)o.push({ key: this.boxKeys[s], x1: this.bboxes[4 * s], y1: this.bboxes[4 * s + 1], x2: this.bboxes[4 * s + 2], y2: this.bboxes[4 * s + 3] }); for (var l = 0; l < this.circleKeys.length; l++) { var u = this.circles[3 * l], h = this.circles[3 * l + 1], c = this.circles[3 * l + 2]; o.push({ key: this.circleKeys[l], x1: u - c, y1: h - c, x2: u + c, y2: h + c }) } return a ? o.filter(a) : o } return this._forEachCell(t, e, i, r, this._queryCell, o, { hitTest: n, seenUids: { box: {}, circle: {} } }, a), n ? o.length > 0 : o }, $t.prototype._queryCircle = function (t, e, i, r, n) { var a = t - i, o = t + i, s = e - i, l = e + i; if (o < 0 || a > this.width || l < 0 || s > this.height) return !r && []; var u = []; return this._forEachCell(a, s, o, l, this._queryCellCircle, u, { hitTest: r, circle: { x: t, y: e, radius: i }, seenUids: { box: {}, circle: {} } }, n), r ? u.length > 0 : u }, $t.prototype.query = function (t, e, i, r, n) { return this._query(t, e, i, r, !1, n) }, $t.prototype.hitTest = function (t, e, i, r, n) { return this._query(t, e, i, r, !0, n) }, $t.prototype.hitTestCircle = function (t, e, i, r) { return this._queryCircle(t, e, i, !0, r) }, $t.prototype._queryCell = function (t, e, i, r, n, a, o, s) { var l = o.seenUids, u = this.boxCells[n]; if (null !== u) for (var h = this.bboxes, c = 0, p = u; c < p.length; c += 1) { var f = p[c]; if (!l.box[f]) { l.box[f] = !0; var d = 4 * f; if (t <= h[d + 2] && e <= h[d + 3] && i >= h[d + 0] && r >= h[d + 1] && (!s || s(this.boxKeys[f]))) { if (o.hitTest) return a.push(!0), !0; a.push({ key: this.boxKeys[f], x1: h[d], y1: h[d + 1], x2: h[d + 2], y2: h[d + 3] }) } } } var m = this.circleCells[n]; if (null !== m) for (var y = this.circles, g = 0, _ = m; g < _.length; g += 1) { var v = _[g]; if (!l.circle[v]) { l.circle[v] = !0; var x = 3 * v; if (this._circleAndRectCollide(y[x], y[x + 1], y[x + 2], t, e, i, r) && (!s || s(this.circleKeys[v]))) { if (o.hitTest) return a.push(!0), !0; var b = y[x], w = y[x + 1], M = y[x + 2]; a.push({ key: this.circleKeys[v], x1: b - M, y1: w - M, x2: b + M, y2: w + M }) } } } }, $t.prototype._queryCellCircle = function (t, e, i, r, n, a, o, s) { var l = o.circle, u = o.seenUids, h = this.boxCells[n]; if (null !== h) for (var c = this.bboxes, p = 0, f = h; p < f.length; p += 1) { var d = f[p]; if (!u.box[d]) { u.box[d] = !0; var m = 4 * d; if (this._circleAndRectCollide(l.x, l.y, l.radius, c[m + 0], c[m + 1], c[m + 2], c[m + 3]) && (!s || s(this.boxKeys[d]))) return a.push(!0), !0 } } var y = this.circleCells[n]; if (null !== y) for (var g = this.circles, _ = 0, v = y; _ < v.length; _ += 1) { var x = v[_]; if (!u.circle[x]) { u.circle[x] = !0; var b = 3 * x; if (this._circlesCollide(g[b], g[b + 1], g[b + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[x]))) return a.push(!0), !0 } } }, $t.prototype._forEachCell = function (t, e, i, r, n, a, o, s) { for (var l = this._convertToXCellCoord(t), u = this._convertToYCellCoord(e), h = this._convertToXCellCoord(i), c = this._convertToYCellCoord(r), p = l; p <= h; p++)for (var f = u; f <= c; f++)if (n.call(this, t, e, i, r, this.xCellCount * f + p, a, o, s)) return }, $t.prototype._convertToXCellCoord = function (t) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))) }, $t.prototype._convertToYCellCoord = function (t) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))) }, $t.prototype._circlesCollide = function (t, e, i, r, n, a) { var o = r - t, s = n - e, l = i + a; return l * l > o * o + s * s }, $t.prototype._circleAndRectCollide = function (t, e, i, r, n, a, o) { var s = (a - r) / 2, l = Math.abs(t - (r + s)); if (l > s + i) return !1; var u = (o - n) / 2, h = Math.abs(e - (n + u)); if (h > u + i) return !1; if (l <= s || h <= u) return !0; var c = l - s, p = h - u; return c * c + p * p <= i * i }; var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function ue(t, e) { for (var i = 0; i < t; i++) { var r = e.length; e.resize(r + 4), e.float32.set(le, 3 * r) } } function he(t, e, i) { var r = e[0], n = e[1]; return t[0] = i[0] * r + i[4] * n + i[12], t[1] = i[1] * r + i[5] * n + i[13], t[3] = i[3] * r + i[7] * n + i[15], t } var ce = function (t, e, i) { void 0 === e && (e = new $t(t.width + 200, t.height + 200, 25)), void 0 === i && (i = new $t(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = i, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200 }; function pe(e, i, r) { return i * (t.EXTENT / (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ))) } ce.prototype.placeCollisionBox = function (t, e, i, r, n) { var a = this.projectAndGetPerspectiveRatio(r, t.anchorPointX, t.anchorPointY), o = i * a.perspectiveRatio, s = t.x1 * o + a.point.x, l = t.y1 * o + a.point.y, u = t.x2 * o + a.point.x, h = t.y2 * o + a.point.y; return !this.isInsideGrid(s, l, u, h) || !e && this.grid.hitTest(s, l, u, h, n) ? { box: [], offscreen: !1 } : { box: [s, l, u, h], offscreen: this.isOffscreen(s, l, u, h) } }, ce.prototype.placeCollisionCircles = function (e, i, r, n, a, o, s, l, u, h, c, p, f) { var d = [], m = new t.Point(i.anchorX, i.anchorY), y = Qt(m, o), g = te(this.transform.cameraToCenterDistance, y.signedDistanceFromCamera), _ = (h ? a / g : a * g) / t.ONE_EM, v = Qt(m, s).point, x = re(_, n, i.lineOffsetX * _, i.lineOffsetY * _, !1, v, m, i, r, s, {}), b = !1, w = !1, M = !0; if (x) { for (var S = .5 * p * g + f, E = new t.Point(-100, -100), I = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), T = new Ht, A = x.first, P = x.last, C = [], z = A.path.length - 1; z >= 1; z--)C.push(A.path[z]); for (var k = 1; k < P.path.length; k++)C.push(P.path[k]); var L = 2.5 * S; if (l) { var D = C.map((function (t) { return Qt(t, l) })); C = D.some((function (t) { return t.signedDistanceFromCamera <= 0 })) ? [] : D.map((function (t) { return t.point })) } var R = []; if (C.length > 0) { for (var B = C[0].clone(), O = C[0].clone(), F = 1; F < C.length; F++)B.x = Math.min(B.x, C[F].x), B.y = Math.min(B.y, C[F].y), O.x = Math.max(O.x, C[F].x), O.y = Math.max(O.y, C[F].y); R = B.x >= E.x && O.x <= I.x && B.y >= E.y && O.y <= I.y ? [C] : O.x < E.x || B.x > I.x || O.y < E.y || B.y > I.y ? [] : t.clipLine([C], E.x, E.y, I.x, I.y) } for (var U = 0, N = R; U < N.length; U += 1) { var V; T.reset(N[U], .25 * S), V = T.length <= .5 * S ? 1 : Math.ceil(T.paddedLength / L) + 1; for (var j = 0; j < V; j++) { var q = j / Math.max(V - 1, 1), G = T.lerp(q), Z = G.x + 100, X = G.y + 100; d.push(Z, X, S, 0); var W = Z - S, K = X - S, H = Z + S, $ = X + S; if (M = M && this.isOffscreen(W, K, H, $), w = w || this.isInsideGrid(W, K, H, $), !e && this.grid.hitTestCircle(Z, X, S, c) && (b = !0, !u)) return { circles: [], offscreen: !1, collisionDetected: b } } } } return { circles: !u && b || !w ? [] : d, offscreen: M, collisionDetected: b } }, ce.prototype.queryRenderedSymbols = function (e) { if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {}; for (var i = [], r = 1 / 0, n = 1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e; s < l.length; s += 1) { var u = l[s], h = new t.Point(u.x + 100, u.y + 100); r = Math.min(r, h.x), n = Math.min(n, h.y), a = Math.max(a, h.x), o = Math.max(o, h.y), i.push(h) } for (var c = {}, p = {}, f = 0, d = this.grid.query(r, n, a, o).concat(this.ignoredGrid.query(r, n, a, o)); f < d.length; f += 1) { var m = d[f], y = m.key; if (void 0 === c[y.bucketInstanceId] && (c[y.bucketInstanceId] = {}), !c[y.bucketInstanceId][y.featureIndex]) { var g = [new t.Point(m.x1, m.y1), new t.Point(m.x2, m.y1), new t.Point(m.x2, m.y2), new t.Point(m.x1, m.y2)]; t.polygonIntersectsPolygon(i, g) && (c[y.bucketInstanceId][y.featureIndex] = !0, void 0 === p[y.bucketInstanceId] && (p[y.bucketInstanceId] = []), p[y.bucketInstanceId].push(y.featureIndex)) } } return p }, ce.prototype.insertCollisionBox = function (t, e, i, r, n) { (e ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i, featureIndex: r, collisionGroupID: n }, t[0], t[1], t[2], t[3]) }, ce.prototype.insertCollisionCircles = function (t, e, i, r, n) { for (var a = e ? this.ignoredGrid : this.grid, o = { bucketInstanceId: i, featureIndex: r, collisionGroupID: n }, s = 0; s < t.length; s += 4)a.insertCircle(o, t[s], t[s + 1], t[s + 2]) }, ce.prototype.projectAndGetPerspectiveRatio = function (e, i, r) { var n = [i, r, 0, 1]; return he(n, n, e), { point: new t.Point((n[0] / n[3] + 1) / 2 * this.transform.width + 100, (-n[1] / n[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: .5 + this.transform.cameraToCenterDistance / n[3] * .5 } }, ce.prototype.isOffscreen = function (t, e, i, r) { return i < 100 || t >= this.screenRightBoundary || r < 100 || e > this.screenBottomBoundary }, ce.prototype.isInsideGrid = function (t, e, i, r) { return i >= 0 && t < this.gridRightBoundary && r >= 0 && e < this.gridBottomBoundary }, ce.prototype.getViewportMatrix = function () { var e = t.identity([]); return t.translate(e, e, [-100, -100, 0]), e }; var fe = function (t, e, i, r) { this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : r && i ? 1 : 0, this.placed = i }; fe.prototype.isHidden = function () { return 0 === this.opacity && !this.placed }; var de = function (t, e, i, r, n) { this.text = new fe(t ? t.text : null, e, i, n), this.icon = new fe(t ? t.icon : null, e, r, n) }; de.prototype.isHidden = function () { return this.text.isHidden() && this.icon.isHidden() }; var me = function (t, e, i) { this.text = t, this.icon = e, this.skipFade = i }, ye = function () { this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [] }, ge = function (t, e, i, r, n) { this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = i, this.bucketIndex = r, this.tileID = n }, _e = function (t) { this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {} }; function ve(e, i, r, n, a) { var o = t.getAnchorAlignment(e), s = -(o.horizontalAlign - .5) * i, l = -(o.verticalAlign - .5) * r, u = t.evaluateVariableOffset(e, n); return new t.Point(s + u[0] * a, l + u[1] * a) } function xe(e, i, r, n, a, o) { var s = e.x1, l = e.x2, u = e.y1, h = e.y2, c = e.anchorPointX, p = e.anchorPointY, f = new t.Point(i, r); return n && f._rotate(a ? o : -o), { x1: s + f.x, y1: u + f.y, x2: l + f.x, y2: h + f.y, anchorPointX: c, anchorPointY: p } } _e.prototype.get = function (t) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[t]) { var e = ++this.maxGroupID; this.collisionGroups[t] = { ID: e, predicate: function (t) { return t.collisionGroupID === e } } } return this.collisionGroups[t] }; var be = function (t, e, i, r) { this.transform = t.clone(), this.collisionIndex = new ce(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new _e(i), this.collisionCircleArrays = {}, this.prevPlacement = r, r && (r.prevPlacement = void 0), this.placedOrientations = {} }; function we(t, e, i, r, n) { t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, n || 0) } be.prototype.getBucketParts = function (e, i, r, n) { var a = r.getBucket(i), o = r.latestFeatureIndex; if (a && o && i.id === a.layerIds[0]) { var s = r.collisionBoxArray, l = a.layers[0].layout, u = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ), h = r.tileSize / t.EXTENT, c = this.transform.calculatePosMatrix(r.tileID.toUnwrapped()), p = "map" === l.get("text-pitch-alignment"), f = "map" === l.get("text-rotation-alignment"), d = pe(r, 1, this.transform.zoom), m = Jt(c, p, f, this.transform, d), y = null; if (p) { var g = Yt(c, p, f, this.transform, d); y = t.multiply([], this.transform.labelPlaneMatrix, g) } this.retainedQueryData[a.bucketInstanceId] = new ge(a.bucketInstanceId, o, a.sourceLayerIndex, a.index, r.tileID); var _ = { bucket: a, layout: l, posMatrix: c, textLabelPlaneMatrix: m, labelToScreenMatrix: y, scale: u, textPixelRatio: h, holdingForFade: r.holdingForFade(), collisionBoxArray: s, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a.sourceID) }; if (n) for (var v = 0, x = a.sortKeyRanges; v < x.length; v += 1) { var b = x[v]; e.push({ sortKey: b.sortKey, symbolInstanceStart: b.symbolInstanceStart, symbolInstanceEnd: b.symbolInstanceEnd, parameters: _ }) } else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: a.symbolInstances.length, parameters: _ }) } }, be.prototype.attemptAnchorPlacement = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d) { var m, y = [c.textOffset0, c.textOffset1], g = ve(t, i, r, y, n), _ = this.collisionIndex.placeCollisionBox(xe(e, g.x, g.y, a, o, this.transform.angle), h, s, l, u.predicate); if (!d || 0 !== this.collisionIndex.placeCollisionBox(xe(d, g.x, g.y, a, o, this.transform.angle), h, s, l, u.predicate).box.length) return _.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[c.crossTileID] && this.prevPlacement.placements[c.crossTileID] && this.prevPlacement.placements[c.crossTileID].text && (m = this.prevPlacement.variableOffsets[c.crossTileID].anchor), this.variableOffsets[c.crossTileID] = { textOffset: y, width: i, height: r, anchor: t, textBoxScale: n, prevAnchor: m }, this.markUsedJustification(p, t, c, f), p.allowVerticalPlacement && (this.markUsedOrientation(p, f, c), this.placedOrientations[c.crossTileID] = f), { shift: g, placedGlyphBoxes: _ }) : void 0 }, be.prototype.placeLayerBucketPart = function (e, i, r) { var n = this, a = e.parameters, o = a.bucket, s = a.layout, l = a.posMatrix, u = a.textLabelPlaneMatrix, h = a.labelToScreenMatrix, c = a.textPixelRatio, p = a.holdingForFade, f = a.collisionBoxArray, d = a.partiallyEvaluatedTextSize, m = a.collisionGroup, y = s.get("text-optional"), g = s.get("icon-optional"), _ = s.get("text-allow-overlap"), v = s.get("icon-allow-overlap"), x = "map" === s.get("text-rotation-alignment"), b = "map" === s.get("text-pitch-alignment"), w = "none" !== s.get("icon-text-fit"), M = "viewport-y" === s.get("symbol-z-order"), S = _ && (v || !o.hasIconData() || g), E = v && (_ || !o.hasTextData() || y); !o.collisionArrays && f && o.deserializeCollisionBoxes(f); var I = function (e, a) { if (!i[e.crossTileID]) if (p) n.placements[e.crossTileID] = new me(!1, !1, !1); else { var f, M = !1, I = !1, T = !0, A = null, P = { box: null, offscreen: null }, C = { box: null, offscreen: null }, z = null, k = null, L = 0, D = 0, R = 0; a.textFeatureIndex ? L = a.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), a.verticalTextFeatureIndex && (D = a.verticalTextFeatureIndex); var B = a.textBox; if (B) { var O = function (i) { var r = t.WritingMode.horizontal; if (o.allowVerticalPlacement && !i && n.prevPlacement) { var a = n.prevPlacement.placedOrientations[e.crossTileID]; a && (n.placedOrientations[e.crossTileID] = a, n.markUsedOrientation(o, r = a, e)) } return r }, F = function (i, r) { if (o.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && a.verticalTextBox) for (var n = 0, s = o.writingModes; n < s.length && (s[n] === t.WritingMode.vertical ? (P = r(), C = P) : P = i(), !(P && P.box && P.box.length)); n += 1); else P = i() }; if (s.get("text-variable-anchor")) { var U = s.get("text-variable-anchor"); if (n.prevPlacement && n.prevPlacement.variableOffsets[e.crossTileID]) { var N = n.prevPlacement.variableOffsets[e.crossTileID]; U.indexOf(N.anchor) > 0 && (U = U.filter((function (t) { return t !== N.anchor }))).unshift(N.anchor) } var V = function (t, i, r) { for (var a = t.x2 - t.x1, s = t.y2 - t.y1, u = e.textBoxScale, h = w && !v ? i : null, p = { box: [], offscreen: !1 }, f = _ ? 2 * U.length : U.length, d = 0; d < f; ++d) { var y = n.attemptAnchorPlacement(U[d % U.length], t, a, s, u, x, b, c, l, m, d >= U.length, e, o, r, h); if (y && (p = y.placedGlyphBoxes) && p.box && p.box.length) { M = !0, A = y.shift; break } } return p }; F((function () { return V(B, a.iconBox, t.WritingMode.horizontal) }), (function () { var i = a.verticalTextBox; return o.allowVerticalPlacement && !(P && P.box && P.box.length) && e.numVerticalGlyphVertices > 0 && i ? V(i, a.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null } })), P && (M = P.box, T = P.offscreen); var j = O(P && P.box); if (!M && n.prevPlacement) { var q = n.prevPlacement.variableOffsets[e.crossTileID]; q && (n.variableOffsets[e.crossTileID] = q, n.markUsedJustification(o, q.anchor, e, j)) } } else { var G = function (t, i) { var r = n.collisionIndex.placeCollisionBox(t, _, c, l, m.predicate); return r && r.box && r.box.length && (n.markUsedOrientation(o, i, e), n.placedOrientations[e.crossTileID] = i), r }; F((function () { return G(B, t.WritingMode.horizontal) }), (function () { var i = a.verticalTextBox; return o.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? G(i, t.WritingMode.vertical) : { box: null, offscreen: null } })), O(P && P.box && P.box.length) } } if (M = (f = P) && f.box && f.box.length > 0, T = f && f.offscreen, e.useRuntimeCollisionCircles) { var Z = o.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex), X = t.evaluateSizeForFeature(o.textSizeData, d, Z), W = s.get("text-padding"); z = n.collisionIndex.placeCollisionCircles(_, Z, o.lineVertexArray, o.glyphOffsetArray, X, l, u, h, r, b, m.predicate, e.collisionCircleDiameter, W), M = _ || z.circles.length > 0 && !z.collisionDetected, T = T && z.offscreen } if (a.iconFeatureIndex && (R = a.iconFeatureIndex), a.iconBox) { var K = function (t) { var e = w && A ? xe(t, A.x, A.y, x, b, n.transform.angle) : t; return n.collisionIndex.placeCollisionBox(e, v, c, l, m.predicate) }; I = C && C.box && C.box.length && a.verticalIconBox ? (k = K(a.verticalIconBox)).box.length > 0 : (k = K(a.iconBox)).box.length > 0, T = T && k.offscreen } var H = y || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices, $ = g || 0 === e.numIconVertices; if (H || $ ? $ ? H || (I = I && M) : M = I && M : I = M = I && M, M && f && f.box && n.collisionIndex.insertCollisionBox(f.box, s.get("text-ignore-placement"), o.bucketInstanceId, C && C.box && D ? D : L, m.ID), I && k && n.collisionIndex.insertCollisionBox(k.box, s.get("icon-ignore-placement"), o.bucketInstanceId, R, m.ID), z && (M && n.collisionIndex.insertCollisionCircles(z.circles, s.get("text-ignore-placement"), o.bucketInstanceId, L, m.ID), r)) { var J = o.bucketInstanceId, Y = n.collisionCircleArrays[J]; void 0 === Y && (Y = n.collisionCircleArrays[J] = new ye); for (var Q = 0; Q < z.circles.length; Q += 4)Y.circles.push(z.circles[Q + 0]), Y.circles.push(z.circles[Q + 1]), Y.circles.push(z.circles[Q + 2]), Y.circles.push(z.collisionDetected ? 1 : 0) } n.placements[e.crossTileID] = new me(M || S, I || E, T || o.justReloaded), i[e.crossTileID] = !0 } }; if (M) for (var T = o.getSortedSymbolIndexes(this.transform.angle), A = T.length - 1; A >= 0; --A) { var P = T[A]; I(o.symbolInstances.get(P), o.collisionArrays[P]) } else for (var C = e.symbolInstanceStart; C < e.symbolInstanceEnd; C++)I(o.symbolInstances.get(C), o.collisionArrays[C]); if (r && o.bucketInstanceId in this.collisionCircleArrays) { var z = this.collisionCircleArrays[o.bucketInstanceId]; t.invert(z.invProjMatrix, l), z.viewportMatrix = this.collisionIndex.getViewportMatrix() } o.justReloaded = !1 }, be.prototype.markUsedJustification = function (e, i, r, n) { var a; a = n === t.WritingMode.vertical ? r.verticalPlacedTextSymbolIndex : { left: r.leftJustifiedTextSymbolIndex, center: r.centerJustifiedTextSymbolIndex, right: r.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i)]; for (var o = 0, s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex]; o < s.length; o += 1) { var l = s[o]; l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = a >= 0 && l !== a ? 0 : r.crossTileID) } }, be.prototype.markUsedOrientation = function (e, i, r) { for (var n = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0, a = i === t.WritingMode.vertical ? i : 0, o = 0, s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex]; o < s.length; o += 1)e.text.placedSymbolArray.get(s[o]).placedOrientation = n; r.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = a) }, be.prototype.commit = function (t) { this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom; var e = this.prevPlacement, i = !1; this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0; var r = e ? e.symbolFadeChange(t) : 1, n = e ? e.opacities : {}, a = e ? e.variableOffsets : {}, o = e ? e.placedOrientations : {}; for (var s in this.placements) { var l = this.placements[s], u = n[s]; u ? (this.opacities[s] = new de(u, r, l.text, l.icon), i = i || l.text !== u.text.placed || l.icon !== u.icon.placed) : (this.opacities[s] = new de(null, r, l.text, l.icon, l.skipFade), i = i || l.text || l.icon) } for (var h in n) { var c = n[h]; if (!this.opacities[h]) { var p = new de(c, r, !1, !1); p.isHidden() || (this.opacities[h] = p, i = i || c.text.placed || c.icon.placed) } } for (var f in a) this.variableOffsets[f] || !this.opacities[f] || this.opacities[f].isHidden() || (this.variableOffsets[f] = a[f]); for (var d in o) this.placedOrientations[d] || !this.opacities[d] || this.opacities[d].isHidden() || (this.placedOrientations[d] = o[d]); i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t) }, be.prototype.updateLayerOpacities = function (t, e) { for (var i = {}, r = 0, n = e; r < n.length; r += 1) { var a = n[r], o = a.getBucket(t); o && a.latestFeatureIndex && t.id === o.layerIds[0] && this.updateBucketOpacities(o, i, a.collisionBoxArray) } }, be.prototype.updateBucketOpacities = function (e, i, r) { var n = this; e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear(); var a = e.layers[0].layout, o = new de(null, 0, !1, !1, !0), s = a.get("text-allow-overlap"), l = a.get("icon-allow-overlap"), u = a.get("text-variable-anchor"), h = "map" === a.get("text-rotation-alignment"), c = "map" === a.get("text-pitch-alignment"), p = "none" !== a.get("icon-text-fit"), f = new de(null, 0, s && (l || !e.hasIconData() || a.get("icon-optional")), l && (s || !e.hasTextData() || a.get("text-optional")), !0); !e.collisionArrays && r && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(r); for (var d = function (t, e, i) { for (var r = 0; r < e / 4; r++)t.opacityVertexArray.emplaceBack(i) }, m = function (r) { var a = e.symbolInstances.get(r), s = a.numHorizontalGlyphVertices, l = a.numVerticalGlyphVertices, m = a.crossTileID, y = n.opacities[m]; i[m] ? y = o : y || (n.opacities[m] = y = f), i[m] = !0; var g = a.numIconVertices > 0, _ = n.placedOrientations[a.crossTileID], v = _ === t.WritingMode.vertical, x = _ === t.WritingMode.horizontal || _ === t.WritingMode.horizontalOnly; if (s > 0 || l > 0) { var b = Ce(y.text); d(e.text, s, v ? ze : b), d(e.text, l, x ? ze : b); var w = y.text.isHidden();[a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach((function (t) { t >= 0 && (e.text.placedSymbolArray.get(t).hidden = w || v ? 1 : 0) })), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = w || x ? 1 : 0); var M = n.variableOffsets[a.crossTileID]; M && n.markUsedJustification(e, M.anchor, a, _); var S = n.placedOrientations[a.crossTileID]; S && (n.markUsedJustification(e, "left", a, S), n.markUsedOrientation(e, S, a)) } if (g) { var E = Ce(y.icon), I = !(p && a.verticalPlacedIconSymbolIndex && v); a.placedIconSymbolIndex >= 0 && (d(e.icon, a.numIconVertices, I ? E : ze), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = y.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (d(e.icon, a.numVerticalIconVertices, I ? ze : E), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = y.icon.isHidden()) } if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) { var T = e.collisionArrays[r]; if (T) { var A = new t.Point(0, 0); if (T.textBox || T.verticalTextBox) { var P = !0; if (u) { var C = n.variableOffsets[m]; C ? (A = ve(C.anchor, C.width, C.height, C.textOffset, C.textBoxScale), h && A._rotate(c ? n.transform.angle : -n.transform.angle)) : P = !1 } T.textBox && we(e.textCollisionBox.collisionVertexArray, y.text.placed, !P || v, A.x, A.y), T.verticalTextBox && we(e.textCollisionBox.collisionVertexArray, y.text.placed, !P || x, A.x, A.y) } var z = Boolean(!x && T.verticalIconBox); T.iconBox && we(e.iconCollisionBox.collisionVertexArray, y.icon.placed, z, p ? A.x : 0, p ? A.y : 0), T.verticalIconBox && we(e.iconCollisionBox.collisionVertexArray, y.icon.placed, !z, p ? A.x : 0, p ? A.y : 0) } } }, y = 0; y < e.symbolInstances.length; y++)m(y); if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) { var g = this.collisionCircleArrays[e.bucketInstanceId]; e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId] } }, be.prototype.symbolFadeChange = function (t) { return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment }, be.prototype.zoomAdjustment = function (t) { return Math.max(0, (this.transform.zoom - t) / 1.5) }, be.prototype.hasTransitions = function (t) { return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration }, be.prototype.stillRecent = function (t, e) { var i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1; return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * i > t }, be.prototype.setStale = function () { this.stale = !0 }; var Me = Math.pow(2, 25), Se = Math.pow(2, 24), Ee = Math.pow(2, 17), Ie = Math.pow(2, 16), Te = Math.pow(2, 9), Ae = Math.pow(2, 8), Pe = Math.pow(2, 1); function Ce(t) { if (0 === t.opacity && !t.placed) return 0; if (1 === t.opacity && t.placed) return 4294967295; var e = t.placed ? 1 : 0, i = Math.floor(127 * t.opacity); return i * Me + e * Se + i * Ee + e * Ie + i * Te + e * Ae + i * Pe + e } var ze = 0, ke = function (t) { this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [] }; ke.prototype.continuePlacement = function (t, e, i, r, n) { for (var a = this._bucketParts; this._currentTileIndex < t.length;)if (e.getBucketParts(a, r, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, n()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort((function (t, e) { return t.sortKey - e.sortKey }))); this._currentPartIndex < a.length;)if (e.placeLayerBucketPart(a[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, n()) return !0; return !1 }; var Le = function (t, e, i, r, n, a, o) { this.placement = new be(t, n, a, o), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = r, this._done = !1 }; Le.prototype.isDone = function () { return this._done }, Le.prototype.continuePlacement = function (e, i, r) { for (var n = this, a = t.browser.now(), o = function () { var e = t.browser.now() - a; return !n._forceFullPlacement && e > 2 }; this._currentPlacementIndex >= 0;) { var s = i[e[this._currentPlacementIndex]], l = this.placement.collisionIndex.transform.zoom; if ("symbol" === s.type && (!s.minzoom || s.minzoom <= l) && (!s.maxzoom || s.maxzoom > l)) { if (this._inProgressLayer || (this._inProgressLayer = new ke(s)), this._inProgressLayer.continuePlacement(r[s.source], this.placement, this._showCollisionBoxes, s, o)) return; delete this._inProgressLayer } this._currentPlacementIndex-- } this._done = !0 }, Le.prototype.commit = function (t) { return this.placement.commit(t), this.placement }; var De = 512 / t.EXTENT / 2, Re = function (t, e, i) { this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = i; for (var r = 0; r < e.length; r++) { var n = e.get(r), a = n.key; this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({ crossTileID: n.crossTileID, coord: this.getScaledCoordinates(n, t) }) } }; Re.prototype.getScaledCoordinates = function (e, i) { var r = De / Math.pow(2, i.canonical.z - this.tileID.canonical.z); return { x: Math.floor((i.canonical.x * t.EXTENT + e.anchorX) * r), y: Math.floor((i.canonical.y * t.EXTENT + e.anchorY) * r) } }, Re.prototype.findMatches = function (t, e, i) { for (var r = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), n = 0; n < t.length; n++) { var a = t.get(n); if (!a.crossTileID) { var o = this.indexedSymbolInstances[a.key]; if (o) for (var s = this.getScaledCoordinates(a, e), l = 0, u = o; l < u.length; l += 1) { var h = u[l]; if (Math.abs(h.coord.x - s.x) <= r && Math.abs(h.coord.y - s.y) <= r && !i[h.crossTileID]) { i[h.crossTileID] = !0, a.crossTileID = h.crossTileID; break } } } } }; var Be = function () { this.maxCrossTileID = 0 }; Be.prototype.generate = function () { return ++this.maxCrossTileID }; var Oe = function () { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 }; Oe.prototype.handleWrapJump = function (t) { var e = Math.round((t - this.lng) / 360); if (0 !== e) for (var i in this.indexes) { var r = this.indexes[i], n = {}; for (var a in r) { var o = r[a]; o.tileID = o.tileID.unwrapTo(o.tileID.wrap + e), n[o.tileID.key] = o } this.indexes[i] = n } this.lng = t }, Oe.prototype.addBucket = function (t, e, i) { if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) { if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]) } for (var r = 0; r < e.symbolInstances.length; r++)e.symbolInstances.get(r).crossTileID = 0; this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {}); var n = this.usedCrossTileIDs[t.overscaledZ]; for (var a in this.indexes) { var o = this.indexes[a]; if (Number(a) > t.overscaledZ) for (var s in o) { var l = o[s]; l.tileID.isChildOf(t) && l.findMatches(e.symbolInstances, t, n) } else { var u = o[t.scaledTo(Number(a)).key]; u && u.findMatches(e.symbolInstances, t, n) } } for (var h = 0; h < e.symbolInstances.length; h++) { var c = e.symbolInstances.get(h); c.crossTileID || (c.crossTileID = i.generate(), n[c.crossTileID] = !0) } return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Re(t, e.symbolInstances, e.bucketInstanceId), !0 }, Oe.prototype.removeBucketCrossTileIDs = function (t, e) { for (var i in e.indexedSymbolInstances) for (var r = 0, n = e.indexedSymbolInstances[i]; r < n.length; r += 1)delete this.usedCrossTileIDs[t][n[r].crossTileID] }, Oe.prototype.removeStaleBuckets = function (t) { var e = !1; for (var i in this.indexes) { var r = this.indexes[i]; for (var n in r) t[r[n].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, r[n]), delete r[n], e = !0) } return e }; var Fe = function () { this.layerIndexes = {}, this.crossTileIDs = new Be, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} }; Fe.prototype.addLayer = function (t, e, i) { var r = this.layerIndexes[t.id]; void 0 === r && (r = this.layerIndexes[t.id] = new Oe); var n = !1, a = {}; r.handleWrapJump(i); for (var o = 0, s = e; o < s.length; o += 1) { var l = s[o], u = l.getBucket(t); u && t.id === u.layerIds[0] && (u.bucketInstanceId || (u.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(l.tileID, u, this.crossTileIDs) && (n = !0), a[u.bucketInstanceId] = !0) } return r.removeStaleBuckets(a) && (n = !0), n }, Fe.prototype.pruneUnusedLayers = function (t) { var e = {}; for (var i in t.forEach((function (t) { e[t] = !0 })), this.layerIndexes) e[i] || delete this.layerIndexes[i] }; var Ue = function (e, i) { return t.emitValidationErrors(e, i && i.filter((function (t) { return "source.canvas" !== t.identifier }))) }, Ne = t.pick(Vt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ve = t.pick(Vt, ["setCenter", "setZoom", "setBearing", "setPitch"]), je = function () { var e = {}, i = t.styleSpec.$version; for (var r in t.styleSpec.$root) { var n, a = t.styleSpec.$root[r]; a.required && null != (n = "version" === r ? i : "array" === a.type ? [] : {}) && (e[r] = n) } return e }(), qe = function (e) { function i(r, n) { var a = this; void 0 === n && (n = {}), e.call(this), this.map = r, this.dispatcher = new S(Ft(), this), this.imageManager = new p, this.imageManager.setEventedParent(this), this.glyphManager = new v(r._requestManager, n.localIdeographFontFamily), this.lineAtlas = new M(256, 512), this.crossTileSymbolIndex = new Fe, this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer()); var o = this; this._rtlTextPluginCallback = i.registerForPluginStateChange((function (e) { o.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e.pluginStatus, pluginURL: e.pluginURL }, (function (e, i) { if (t.triggerPluginCompletionEvent(e), i && i.every((function (t) { return t }))) for (var r in o.sourceCaches) o.sourceCaches[r].reload() })) })), this.on("data", (function (t) { if ("source" === t.dataType && "metadata" === t.sourceDataType) { var e = a.sourceCaches[t.sourceId]; if (e) { var i = e.getSource(); if (i && i.vectorLayerIds) for (var r in a._layers) { var n = a._layers[r]; n.source === i.id && a._validateLayer(n) } } } })) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.loadURL = function (e, i) { var r = this; void 0 === i && (i = {}), this.fire(new t.Event("dataloading", { dataType: "style" })); var n = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e); e = this.map._requestManager.normalizeStyleURL(e, i.accessToken); var a = this.map._requestManager.transformRequest(e, t.ResourceType.Style); this._request = t.getJSON(a, (function (e, i) { r._request = null, e ? r.fire(new t.ErrorEvent(e)) : i && r._load(i, n) })) }, i.prototype.loadJSON = function (e, i) { var r = this; void 0 === i && (i = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame((function () { r._request = null, r._load(e, !1 !== i.validate) })) }, i.prototype.loadEmpty = function () { this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(je, !1) }, i.prototype._load = function (e, i) { if (!i || !Ue(this, t.validateStyle(e))) { for (var r in this._loaded = !0, this.stylesheet = e, e.sources) this.addSource(r, e.sources[r], { validate: !1 }); e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs); var n = Nt(this.stylesheet.layers); this._order = n.map((function (t) { return t.id })), this._layers = {}, this._serializedLayers = {}; for (var a = 0, o = n; a < o.length; a += 1) { var s = o[a]; (s = t.createStyleLayer(s)).setEventedParent(this, { layer: { id: s.id } }), this._layers[s.id] = s, this._serializedLayers[s.id] = s.serialize() } this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load")) } }, i.prototype._loadSprite = function (e) { var i = this; this._spriteRequest = function (e, i, r) { var n, a, o, s = t.browser.devicePixelRatio > 1 ? "@2x" : "", l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, s, ".json"), t.ResourceType.SpriteJSON), (function (t, e) { l = null, o || (o = t, n = e, h()) })), u = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, s, ".png"), t.ResourceType.SpriteImage), (function (t, e) { u = null, o || (o = t, a = e, h()) })); function h() { if (o) r(o); else if (n && a) { var e = t.browser.getImageData(a), i = {}; for (var s in n) { var l = n[s], u = l.width, h = l.height, c = l.x, p = l.y, f = l.sdf, d = l.pixelRatio, m = l.stretchX, y = l.stretchY, g = l.content, _ = new t.RGBAImage({ width: u, height: h }); t.RGBAImage.copy(e, _, { x: c, y: p }, { x: 0, y: 0 }, { width: u, height: h }), i[s] = { data: _, pixelRatio: d, sdf: f, stretchX: m, stretchY: y, content: g } } r(null, i) } } return { cancel: function () { l && (l.cancel(), l = null), u && (u.cancel(), u = null) } } }(e, this.map._requestManager, (function (e, r) { if (i._spriteRequest = null, e) i.fire(new t.ErrorEvent(e)); else if (r) for (var n in r) i.imageManager.addImage(n, r[n]); i.imageManager.setLoaded(!0), i._availableImages = i.imageManager.listImages(), i.dispatcher.broadcast("setImages", i._availableImages), i.fire(new t.Event("data", { dataType: "style" })) })) }, i.prototype._validateLayer = function (e) { var i = this.sourceCaches[e.source]; if (i) { var r = e.sourceLayer; if (r) { var n = i.getSource(); ("geojson" === n.type || n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(r)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + r + '" does not exist on source "' + n.id + '" as specified by style layer "' + e.id + '"'))) } } }, i.prototype.loaded = function () { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (var t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1; return !!this.imageManager.isLoaded() }, i.prototype._serializeLayers = function (t) { for (var e = [], i = 0, r = t; i < r.length; i += 1) { var n = this._layers[r[i]]; "custom" !== n.type && e.push(n.serialize()) } return e }, i.prototype.hasTransitions = function () { if (this.light && this.light.hasTransition()) return !0; for (var t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0; for (var e in this._layers) if (this._layers[e].hasTransition()) return !0; return !1 }, i.prototype._checkLoaded = function () { if (!this._loaded) throw new Error("Style is not done loading") }, i.prototype.update = function (e) { if (this._loaded) { var i = this._changed; if (this._changed) { var r = Object.keys(this._updatedLayers), n = Object.keys(this._removedLayers); for (var a in (r.length || n.length) && this._updateWorkerLayers(r, n), this._updatedSources) { var o = this._updatedSources[a]; "reload" === o ? this._reloadSource(a) : "clear" === o && this._clearSource(a) } for (var s in this._updateTilesForChangedImages(), this._updatedPaintProps) this._layers[s].updateTransitions(e); this.light.updateTransitions(e), this._resetUpdates() } var l = {}; for (var u in this.sourceCaches) { var h = this.sourceCaches[u]; l[u] = h.used, h.used = !1 } for (var c = 0, p = this._order; c < p.length; c += 1) { var f = this._layers[p[c]]; f.recalculate(e, this._availableImages), !f.isHidden(e.zoom) && f.source && (this.sourceCaches[f.source].used = !0) } for (var d in l) { var m = this.sourceCaches[d]; l[d] !== m.used && m.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: d })) } this.light.recalculate(e), this.z = e.zoom, i && this.fire(new t.Event("data", { dataType: "style" })) } }, i.prototype._updateTilesForChangedImages = function () { var t = Object.keys(this._changedImages); if (t.length) { for (var e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t); this._changedImages = {} } }, i.prototype._updateWorkerLayers = function (t, e) { this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t), removedIds: e }) }, i.prototype._resetUpdates = function () { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {} }, i.prototype.setState = function (e) { var i = this; if (this._checkLoaded(), Ue(this, t.validateStyle(e))) return !1; (e = t.clone$1(e)).layers = Nt(e.layers); var r = function (e, i) { if (!e) return [{ command: Vt.setStyle, args: [i] }]; var r = []; try { if (!t.deepEqual(e.version, i.version)) return [{ command: Vt.setStyle, args: [i] }]; t.deepEqual(e.center, i.center) || r.push({ command: Vt.setCenter, args: [i.center] }), t.deepEqual(e.zoom, i.zoom) || r.push({ command: Vt.setZoom, args: [i.zoom] }), t.deepEqual(e.bearing, i.bearing) || r.push({ command: Vt.setBearing, args: [i.bearing] }), t.deepEqual(e.pitch, i.pitch) || r.push({ command: Vt.setPitch, args: [i.pitch] }), t.deepEqual(e.sprite, i.sprite) || r.push({ command: Vt.setSprite, args: [i.sprite] }), t.deepEqual(e.glyphs, i.glyphs) || r.push({ command: Vt.setGlyphs, args: [i.glyphs] }), t.deepEqual(e.transition, i.transition) || r.push({ command: Vt.setTransition, args: [i.transition] }), t.deepEqual(e.light, i.light) || r.push({ command: Vt.setLight, args: [i.light] }); var n = {}, a = []; !function (e, i, r, n) { var a; for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (i.hasOwnProperty(a) || qt(a, r, n)); for (a in i) i.hasOwnProperty(a) && (e.hasOwnProperty(a) ? t.deepEqual(e[a], i[a]) || ("geojson" === e[a].type && "geojson" === i[a].type && Zt(e, i, a) ? r.push({ command: Vt.setGeoJSONSourceData, args: [a, i[a].data] }) : Gt(a, i, r, n)) : jt(a, i, r)) }(e.sources, i.sources, a, n); var o = []; e.layers && e.layers.forEach((function (t) { n[t.source] ? r.push({ command: Vt.removeLayer, args: [t.id] }) : o.push(t) })), r = r.concat(a), function (e, i, r) { i = i || []; var n, a, o, s, l, u, h, c = (e = e || []).map(Wt), p = i.map(Wt), f = e.reduce(Kt, {}), d = i.reduce(Kt, {}), m = c.slice(), y = Object.create(null); for (n = 0, a = 0; n < c.length; n++)d.hasOwnProperty(o = c[n]) ? a++ : (r.push({ command: Vt.removeLayer, args: [o] }), m.splice(m.indexOf(o, a), 1)); for (n = 0, a = 0; n < p.length; n++)m[m.length - 1 - n] !== (o = p[p.length - 1 - n]) && (f.hasOwnProperty(o) ? (r.push({ command: Vt.removeLayer, args: [o] }), m.splice(m.lastIndexOf(o, m.length - a), 1)) : a++, r.push({ command: Vt.addLayer, args: [d[o], u = m[m.length - n]] }), m.splice(m.length - n, 0, o), y[o] = !0); for (n = 0; n < p.length; n++)if (s = f[o = p[n]], l = d[o], !y[o] && !t.deepEqual(s, l)) if (t.deepEqual(s.source, l.source) && t.deepEqual(s["source-layer"], l["source-layer"]) && t.deepEqual(s.type, l.type)) { for (h in Xt(s.layout, l.layout, r, o, null, Vt.setLayoutProperty), Xt(s.paint, l.paint, r, o, null, Vt.setPaintProperty), t.deepEqual(s.filter, l.filter) || r.push({ command: Vt.setFilter, args: [o, l.filter] }), t.deepEqual(s.minzoom, l.minzoom) && t.deepEqual(s.maxzoom, l.maxzoom) || r.push({ command: Vt.setLayerZoomRange, args: [o, l.minzoom, l.maxzoom] }), s) s.hasOwnProperty(h) && "layout" !== h && "paint" !== h && "filter" !== h && "metadata" !== h && "minzoom" !== h && "maxzoom" !== h && (0 === h.indexOf("paint.") ? Xt(s[h], l[h], r, o, h.slice(6), Vt.setPaintProperty) : t.deepEqual(s[h], l[h]) || r.push({ command: Vt.setLayerProperty, args: [o, h, l[h]] })); for (h in l) l.hasOwnProperty(h) && !s.hasOwnProperty(h) && "layout" !== h && "paint" !== h && "filter" !== h && "metadata" !== h && "minzoom" !== h && "maxzoom" !== h && (0 === h.indexOf("paint.") ? Xt(s[h], l[h], r, o, h.slice(6), Vt.setPaintProperty) : t.deepEqual(s[h], l[h]) || r.push({ command: Vt.setLayerProperty, args: [o, h, l[h]] })) } else r.push({ command: Vt.removeLayer, args: [o] }), u = m[m.lastIndexOf(o) + 1], r.push({ command: Vt.addLayer, args: [l, u] }) }(o, i.layers, r) } catch (t) { console.warn("Unable to compute style diff:", t), r = [{ command: Vt.setStyle, args: [i] }] } return r }(this.serialize(), e).filter((function (t) { return !(t.command in Ve) })); if (0 === r.length) return !1; var n = r.filter((function (t) { return !(t.command in Ne) })); if (n.length > 0) throw new Error("Unimplemented: " + n.map((function (t) { return t.command })).join(", ") + "."); return r.forEach((function (t) { "setTransition" !== t.command && i[t.command].apply(i, t.args) })), this.stylesheet = e, !0 }, i.prototype.addImage = function (e, i) { if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("An image with this name already exists."))); this.imageManager.addImage(e, i), this._afterImageUpdated(e) }, i.prototype.updateImage = function (t, e) { this.imageManager.updateImage(t, e) }, i.prototype.getImage = function (t) { return this.imageManager.getImage(t) }, i.prototype.removeImage = function (e) { if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("No image with this name exists."))); this.imageManager.removeImage(e), this._afterImageUpdated(e) }, i.prototype._afterImageUpdated = function (e) { this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" })) }, i.prototype.listImages = function () { return this._checkLoaded(), this.imageManager.listImages() }, i.prototype.addSource = function (e, i, r) { var n = this; if (void 0 === r && (r = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error("There is already a source with this ID"); if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i).join(", ") + "."); if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e, i, null, r))) { this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0); var a = this.sourceCaches[e] = new Ct(e, i, this.dispatcher); a.style = this, a.setEventedParent(this, (function () { return { isSourceLoaded: n.loaded(), source: a.serialize(), sourceId: e } })), a.onAdd(this.map), this._changed = !0 } }, i.prototype.removeSource = function (e) { if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID"); for (var i in this._layers) if (this._layers[i].source === e) return this.fire(new t.ErrorEvent(new Error('Source "' + e + '" cannot be removed while layer "' + i + '" is using it.'))); var r = this.sourceCaches[e]; delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.clearTiles(), r.onRemove && r.onRemove(this.map), this._changed = !0 }, i.prototype.setGeoJSONSourceData = function (t, e) { this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0 }, i.prototype.getSource = function (t) { return this.sourceCaches[t] && this.sourceCaches[t].getSource() }, i.prototype.addLayer = function (e, i, r) { void 0 === r && (r = {}), this._checkLoaded(); var n = e.id; if (this.getLayer(n)) this.fire(new t.ErrorEvent(new Error('Layer with id "' + n + '" already exists on this map'))); else { var a; if ("custom" === e.type) { if (Ue(this, t.validateCustomStyleLayer(e))) return; a = t.createStyleLayer(e) } else { if ("object" == typeof e.source && (this.addSource(n, e.source), e = t.clone$1(e), e = t.extend(e, { source: n })), this._validate(t.validateStyle.layer, "layers." + n, e, { arrayIndex: -1 }, r)) return; a = t.createStyleLayer(e), this._validateLayer(a), a.setEventedParent(this, { layer: { id: n } }), this._serializedLayers[a.id] = a.serialize() } var o = i ? this._order.indexOf(i) : this._order.length; if (i && -1 === o) this.fire(new t.ErrorEvent(new Error('Layer with id "' + i + '" does not exist on this map.'))); else { if (this._order.splice(o, 0, n), this._layerOrderChanged = !0, this._layers[n] = a, this._removedLayers[n] && a.source && "custom" !== a.type) { var s = this._removedLayers[n]; delete this._removedLayers[n], s.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()) } this._updateLayer(a), a.onAdd && a.onAdd(this.map) } } }, i.prototype.moveLayer = function (e, i) { if (this._checkLoaded(), this._changed = !0, this._layers[e]) { if (e !== i) { var r = this._order.indexOf(e); this._order.splice(r, 1); var n = i ? this._order.indexOf(i) : this._order.length; i && -1 === n ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + i + '" does not exist on this map.'))) : (this._order.splice(n, 0, e), this._layerOrderChanged = !0) } } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be moved."))) }, i.prototype.removeLayer = function (e) { this._checkLoaded(); var i = this._layers[e]; if (i) { i.setEventedParent(null); var r = this._order.indexOf(e); this._order.splice(r, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map) } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be removed."))) }, i.prototype.getLayer = function (t) { return this._layers[t] }, i.prototype.hasLayer = function (t) { return t in this._layers }, i.prototype.setLayerZoomRange = function (e, i, r) { this._checkLoaded(); var n = this.getLayer(e); n ? n.minzoom === i && n.maxzoom === r || (null != i && (n.minzoom = i), null != r && (n.maxzoom = r), this._updateLayer(n)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot have zoom extent."))) }, i.prototype.setFilter = function (e, i, r) { void 0 === r && (r = {}), this._checkLoaded(); var n = this.getLayer(e); if (n) { if (!t.deepEqual(n.filter, i)) return null == i ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(t.validateStyle.filter, "layers." + n.id + ".filter", i, null, r) || (n.filter = t.clone$1(i), this._updateLayer(n))) } else this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be filtered."))) }, i.prototype.getFilter = function (e) { return t.clone$1(this.getLayer(e).filter) }, i.prototype.setLayoutProperty = function (e, i, r, n) { void 0 === n && (n = {}), this._checkLoaded(); var a = this.getLayer(e); a ? t.deepEqual(a.getLayoutProperty(i), r) || (a.setLayoutProperty(i, r, n), this._updateLayer(a)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be styled."))) }, i.prototype.getLayoutProperty = function (e, i) { var r = this.getLayer(e); if (r) return r.getLayoutProperty(i); this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style."))) }, i.prototype.setPaintProperty = function (e, i, r, n) { void 0 === n && (n = {}), this._checkLoaded(); var a = this.getLayer(e); a ? t.deepEqual(a.getPaintProperty(i), r) || (a.setPaintProperty(i, r, n) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error("The layer '" + e + "' does not exist in the map's style and cannot be styled."))) }, i.prototype.getPaintProperty = function (t, e) { return this.getLayer(t).getPaintProperty(e) }, i.prototype.setFeatureState = function (e, i) { this._checkLoaded(); var r = e.source, n = e.sourceLayer, a = this.sourceCaches[r]; if (void 0 !== a) { var o = a.getSource().type; "geojson" === o && n ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== o || n ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a.setFeatureState(n, e.id, i)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + r + "' does not exist in the map's style."))) }, i.prototype.removeFeatureState = function (e, i) { this._checkLoaded(); var r = e.source, n = this.sourceCaches[r]; if (void 0 !== n) { var a = n.getSource().type, o = "vector" === a ? e.sourceLayer : void 0; "vector" !== a || o ? i && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : n.removeFeatureState(o, e.id, i) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + r + "' does not exist in the map's style."))) }, i.prototype.getFeatureState = function (e) { this._checkLoaded(); var i = e.source, r = e.sourceLayer, n = this.sourceCaches[i]; if (void 0 !== n) { if ("vector" !== n.getSource().type || r) return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), n.getFeatureState(r, e.id); this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new t.ErrorEvent(new Error("The source '" + i + "' does not exist in the map's style."))) }, i.prototype.getTransition = function () { return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) }, i.prototype.serialize = function () { return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (function (t) { return t.serialize() })), layers: this._serializeLayers(this._order) }, (function (t) { return void 0 !== t })) }, i.prototype._updateLayer = function (t) { this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && "raster" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0 }, i.prototype._flattenAndSortRenderedFeatures = function (t) { for (var e = this, i = function (t) { return "fill-extrusion" === e._layers[t].type }, r = {}, n = [], a = this._order.length - 1; a >= 0; a--) { var o = this._order[a]; if (i(o)) { r[o] = a; for (var s = 0, l = t; s < l.length; s += 1) { var u = l[s][o]; if (u) for (var h = 0, c = u; h < c.length; h += 1)n.push(c[h]) } } } n.sort((function (t, e) { return e.intersectionZ - t.intersectionZ })); for (var p = [], f = this._order.length - 1; f >= 0; f--) { var d = this._order[f]; if (i(d)) for (var m = n.length - 1; m >= 0; m--) { var y = n[m].feature; if (r[y.layer.id] < f) break; p.push(y), n.pop() } else for (var g = 0, _ = t; g < _.length; g += 1) { var v = _[g][d]; if (v) for (var x = 0, b = v; x < b.length; x += 1)p.push(b[x].feature) } } return p }, i.prototype.queryRenderedFeatures = function (e, i, r) { i && i.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i.filter, null, i); var n = {}; if (i && i.layers) { if (!Array.isArray(i.layers)) return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), []; for (var a = 0, o = i.layers; a < o.length; a += 1) { var s = o[a], l = this._layers[s]; if (!l) return this.fire(new t.ErrorEvent(new Error("The layer '" + s + "' does not exist in the map's style and cannot be queried for features."))), []; n[l.source] = !0 } } var u = []; for (var h in i.availableImages = this._availableImages, this.sourceCaches) i.layers && !n[h] || u.push(O(this.sourceCaches[h], this._layers, this._serializedLayers, e, i, r)); return this.placement && u.push(function (t, e, i, r, n, a, o) { for (var s = {}, l = a.queryRenderedSymbols(r), u = [], h = 0, c = Object.keys(l).map(Number); h < c.length; h += 1)u.push(o[c[h]]); u.sort(F); for (var p = function () { var i = d[f], r = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, n.filter, n.layers, n.availableImages, t); for (var a in r) { var o = s[a] = s[a] || [], u = r[a]; u.sort((function (t, e) { var r = i.featureSortOrder; if (r) { var n = r.indexOf(t.featureIndex); return r.indexOf(e.featureIndex) - n } return e.featureIndex - t.featureIndex })); for (var h = 0, c = u; h < c.length; h += 1)o.push(c[h]) } }, f = 0, d = u; f < d.length; f += 1)p(); var m = function (e) { s[e].forEach((function (r) { var n = r.feature, a = i[t[e].source].getFeatureState(n.layer["source-layer"], n.id); n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = a })) }; for (var y in s) m(y); return s }(this._layers, this._serializedLayers, this.sourceCaches, e, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(u) }, i.prototype.querySourceFeatures = function (e, i) { i && i.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i.filter, null, i); var r = this.sourceCaches[e]; return r ? function (t, e) { for (var i = t.getRenderableIds().map((function (e) { return t.getTileByID(e) })), r = [], n = {}, a = 0; a < i.length; a++) { var o = i[a], s = o.tileID.canonical.key; n[s] || (n[s] = !0, o.querySourceFeatures(r, e)) } return r }(r, i) : [] }, i.prototype.addSourceType = function (t, e, r) { return i.getSourceType(t) ? r(new Error('A source type called "' + t + '" already exists.')) : (i.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: e.workerSourceURL }, r) : r(null, null)) }, i.prototype.getLight = function () { return this.light.getLight() }, i.prototype.setLight = function (e, i) { void 0 === i && (i = {}), this._checkLoaded(); var r = this.light.getLight(), n = !1; for (var a in e) if (!t.deepEqual(e[a], r[a])) { n = !0; break } if (n) { var o = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(e, i), this.light.updateTransitions(o) } }, i.prototype._validate = function (e, i, r, n, a) { return void 0 === a && (a = {}), (!a || !1 !== a.validate) && Ue(this, e.call(t.validateStyle, t.extend({ key: i, style: this.serialize(), value: r, styleSpec: t.styleSpec }, n))) }, i.prototype._remove = function () { for (var e in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) this._layers[e].setEventedParent(null); for (var i in this.sourceCaches) this.sourceCaches[i].clearTiles(), this.sourceCaches[i].setEventedParent(null); this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove() }, i.prototype._clearSource = function (t) { this.sourceCaches[t].clearTiles() }, i.prototype._reloadSource = function (t) { this.sourceCaches[t].resume(), this.sourceCaches[t].reload() }, i.prototype._updateSources = function (t) { for (var e in this.sourceCaches) this.sourceCaches[e].update(t) }, i.prototype._generateCollisionBoxes = function () { for (var t in this.sourceCaches) this._reloadSource(t) }, i.prototype._updatePlacement = function (e, i, r, n, a) { void 0 === a && (a = !1); for (var o = !1, s = !1, l = {}, u = 0, h = this._order; u < h.length; u += 1) { var c = this._layers[h[u]]; if ("symbol" === c.type) { if (!l[c.source]) { var p = this.sourceCaches[c.source]; l[c.source] = p.getRenderableIds(!0).map((function (t) { return p.getTileByID(t) })).sort((function (t, e) { return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1) })) } var f = this.crossTileSymbolIndex.addLayer(c, l[c.source], e.center.lng); o = o || f } } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || 0 === r) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e.zoom)) && (this.pauseablePlacement = new Le(e, this._order, a, i, r, n, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s = !0), o && this.pauseablePlacement.placement.setStale()), s || o) for (var d = 0, m = this._order; d < m.length; d += 1) { var y = this._layers[m[d]]; "symbol" === y.type && this.placement.updateLayerOpacities(y, l[y.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now()) }, i.prototype._releaseSymbolFadeTiles = function () { for (var t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles() }, i.prototype.getImages = function (t, e, i) { this.imageManager.getImages(e.icons, i), this._updateTilesForChangedImages(); var r = this.sourceCaches[e.source]; r && r.setDependencies(e.tileID.key, e.type, e.icons) }, i.prototype.getGlyphs = function (t, e, i) { this.glyphManager.getGlyphs(e.stacks, i) }, i.prototype.getResource = function (e, i, r) { return t.makeRequest(i, r) }, i }(t.Evented); qe.getSourceType = function (t) { return R[t] }, qe.setSourceType = function (t, e) { R[t] = e }, qe.registerForPluginStateChange = t.registerForPluginStateChange; var Ge = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Ze = gi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), Xe = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), We = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Ke = gi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), He = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), $e = gi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Ye = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), Qe = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), ei = gi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), ii = gi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ri = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), oi = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), si = gi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ui = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), hi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), ci = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), fi = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), di = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), mi = gi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), yi = gi("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"); function gi(t, e) { var i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r = e.match(/attribute ([\w]+) ([\w]+)/g), n = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = a ? a.concat(n) : n, s = {}; return { fragmentSource: t = t.replace(i, (function (t, e, i, r, n) { return s[n] = !0, "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + n + "\nvarying " + i + " " + r + " " + n + ";\n#else\nuniform " + i + " " + r + " u_" + n + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + n + "\n    " + i + " " + r + " " + n + " = u_" + n + ";\n#endif\n" })), vertexSource: e = e.replace(i, (function (t, e, i, r, n) { var a = "float" === r ? "vec2" : "vec4", o = n.match(/color/) ? "color" : a; return s[n] ? "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + n + "\nuniform lowp float u_" + n + "_t;\nattribute " + i + " " + a + " a_" + n + ";\nvarying " + i + " " + r + " " + n + ";\n#else\nuniform " + i + " " + r + " u_" + n + ";\n#endif\n" : "vec4" === o ? "\n#ifndef HAS_UNIFORM_u_" + n + "\n    " + n + " = a_" + n + ";\n#else\n    " + i + " " + r + " " + n + " = u_" + n + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + n + "\n    " + n + " = unpack_mix_" + o + "(a_" + n + ", u_" + n + "_t);\n#else\n    " + i + " " + r + " " + n + " = u_" + n + ";\n#endif\n" : "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + n + "\nuniform lowp float u_" + n + "_t;\nattribute " + i + " " + a + " a_" + n + ";\n#else\nuniform " + i + " " + r + " u_" + n + ";\n#endif\n" : "vec4" === o ? "\n#ifndef HAS_UNIFORM_u_" + n + "\n    " + i + " " + r + " " + n + " = a_" + n + ";\n#else\n    " + i + " " + r + " " + n + " = u_" + n + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + n + "\n    " + i + " " + r + " " + n + " = unpack_mix_" + o + "(a_" + n + ", u_" + n + "_t);\n#else\n    " + i + " " + r + " " + n + " = u_" + n + ";\n#endif\n" })), staticAttributes: r, staticUniforms: o } } var _i = Object.freeze({ __proto__: null, prelude: Ze, background: Xe, backgroundPattern: We, circle: Ke, clippingMask: He, heatmap: $e, heatmapTexture: Je, collisionBox: Ye, collisionCircle: Qe, debug: ti, fill: ei, fillOutline: ii, fillOutlinePattern: ri, fillPattern: ni, fillExtrusion: ai, fillExtrusionPattern: oi, hillshadePrepare: si, hillshade: li, line: ui, lineGradient: hi, linePattern: ci, lineSDF: pi, raster: fi, symbolIcon: di, symbolSDF: mi, symbolTextAndIcon: yi }), vi = function () { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null }; function xi(t) { for (var e = [], i = 0; i < t.length; i++)if (null !== t[i]) { var r = t[i].split(" "); e.push(r.pop()) } return e } vi.prototype.bind = function (t, e, i, r, n, a, o, s) { this.context = t; for (var l = this.boundPaintVertexBuffers.length !== r.length, u = 0; !l && u < r.length; u++)this.boundPaintVertexBuffers[u] !== r[u] && (l = !0); t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === n && this.boundVertexOffset === a && this.boundDynamicVertexBuffer === o && this.boundDynamicVertexBuffer2 === s ? (t.bindVertexArrayOES.set(this.vao), o && o.bind(), n && n.dynamicDraw && n.bind(), s && s.bind()) : this.freshBind(e, i, r, n, a, o, s) }, vi.prototype.freshBind = function (t, e, i, r, n, a, o) { var s, l = t.numAttributes, u = this.context, h = u.gl; if (u.extVertexArrayObject) this.vao && this.destroy(), this.vao = u.extVertexArrayObject.createVertexArrayOES(), u.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = r, this.boundVertexOffset = n, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = o; else { s = u.currentNumAttributes || 0; for (var c = l; c < s; c++)h.disableVertexAttribArray(c) } e.enableAttributes(h, t); for (var p = 0, f = i; p < f.length; p += 1)f[p].enableAttributes(h, t); a && a.enableAttributes(h, t), o && o.enableAttributes(h, t), e.bind(), e.setVertexAttribPointers(h, t, n); for (var d = 0, m = i; d < m.length; d += 1) { var y = m[d]; y.bind(), y.setVertexAttribPointers(h, t, n) } a && (a.bind(), a.setVertexAttribPointers(h, t, n)), r && r.bind(), o && (o.bind(), o.setVertexAttribPointers(h, t, n)), u.currentNumAttributes = l }, vi.prototype.destroy = function () { this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null) }; var bi = function (t, e, i, r, n, a) { var o = t.gl; this.program = o.createProgram(); for (var s = xi(i.staticAttributes), l = r ? r.getBinderAttributes() : [], u = s.concat(l), h = i.staticUniforms ? xi(i.staticUniforms) : [], c = r ? r.getBinderUniforms() : [], p = [], f = 0, d = h.concat(c); f < d.length; f += 1) { var m = d[f]; p.indexOf(m) < 0 && p.push(m) } var y = r ? r.defines() : []; a && y.push("#define OVERDRAW_INSPECTOR;"); var g = y.concat(Ze.fragmentSource, i.fragmentSource).join("\n"), _ = y.concat(Ze.vertexSource, i.vertexSource).join("\n"), v = o.createShader(o.FRAGMENT_SHADER); if (o.isContextLost()) this.failedToCreate = !0; else { o.shaderSource(v, g), o.compileShader(v), o.attachShader(this.program, v); var x = o.createShader(o.VERTEX_SHADER); if (o.isContextLost()) this.failedToCreate = !0; else { o.shaderSource(x, _), o.compileShader(x), o.attachShader(this.program, x), this.attributes = {}; var b = {}; this.numAttributes = u.length; for (var w = 0; w < this.numAttributes; w++)u[w] && (o.bindAttribLocation(this.program, w, u[w]), this.attributes[u[w]] = w); o.linkProgram(this.program), o.deleteShader(x), o.deleteShader(v); for (var M = 0; M < p.length; M++) { var S = p[M]; if (S && !b[S]) { var E = o.getUniformLocation(this.program, S); E && (b[S] = E) } } this.fixedUniforms = n(t, b), this.binderUniforms = r ? r.getUniforms(t, b) : [] } } }; function wi(t, e, i) { var r = 1 / pe(i, 1, e.transform.tileZoom), n = Math.pow(2, i.tileID.overscaledZ), a = i.tileSize * Math.pow(2, e.transform.tileZoom) / n, o = a * (i.tileID.canonical.x + i.tileID.wrap * n), s = a * i.tileID.canonical.y; return { u_image: 0, u_texsize: i.imageAtlasTexture.size, u_scale: [r, t.fromScale, t.toScale], u_fade: t.t, u_pixel_coord_upper: [o >> 16, s >> 16], u_pixel_coord_lower: [65535 & o, 65535 & s] } } bi.prototype.draw = function (t, e, i, r, n, a, o, s, l, u, h, c, p, f, d, m) { var y, g = t.gl; if (!this.failedToCreate) { for (var _ in t.program.set(this.program), t.setDepthMode(i), t.setStencilMode(r), t.setColorMode(n), t.setCullFace(a), this.fixedUniforms) this.fixedUniforms[_].set(o[_]); f && f.setUniforms(t, this.binderUniforms, c, { zoom: p }); for (var v = (y = {}, y[g.LINES] = 2, y[g.TRIANGLES] = 3, y[g.LINE_STRIP] = 1, y)[e], x = 0, b = h.get(); x < b.length; x += 1) { var w = b[x], M = w.vaos || (w.vaos = {}); (M[s] || (M[s] = new vi)).bind(t, this, l, f ? f.getPaintVertexBuffers() : [], u, w.vertexOffset, d, m), g.drawElements(e, w.primitiveLength * v, g.UNSIGNED_SHORT, w.primitiveOffset * v * 2) } } }; var Mi = function (e, i, r, n) { var a = i.style.light, o = a.properties.get("position"), s = [o.x, o.y, o.z], l = t.create$1(); "viewport" === a.properties.get("anchor") && t.fromRotation(l, -i.transform.angle), t.transformMat3(s, s, l); var u = a.properties.get("color"); return { u_matrix: e, u_lightpos: s, u_lightintensity: a.properties.get("intensity"), u_lightcolor: [u.r, u.g, u.b], u_vertical_gradient: +r, u_opacity: n } }, Si = function (e, i, r, n, a, o, s) { return t.extend(Mi(e, i, r, n), wi(o, i, s), { u_height_factor: -Math.pow(2, a.overscaledZ) / s.tileSize / 8 }) }, Ei = function (t) { return { u_matrix: t } }, Ii = function (e, i, r, n) { return t.extend(Ei(e), wi(r, i, n)) }, Ti = function (t, e) { return { u_matrix: t, u_world: e } }, Ai = function (e, i, r, n, a) { return t.extend(Ii(e, i, r, n), { u_world: a }) }, Pi = function (e, i, r, n) { var a, o, s = e.transform; if ("map" === n.paint.get("circle-pitch-alignment")) { var l = pe(r, 1, s.zoom); a = !0, o = [l, l] } else a = !1, o = s.pixelsToGLUnits; return { u_camera_to_center_distance: s.cameraToCenterDistance, u_scale_with_map: +("map" === n.paint.get("circle-pitch-scale")), u_matrix: e.translatePosMatrix(i.posMatrix, r, n.paint.get("circle-translate"), n.paint.get("circle-translate-anchor")), u_pitch_with_map: +a, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: o } }, Ci = function (t, e, i) { var r = pe(i, 1, e.zoom), n = Math.pow(2, e.zoom - i.tileID.overscaledZ), a = i.tileID.overscaleFactor(); return { u_matrix: t, u_camera_to_center_distance: e.cameraToCenterDistance, u_pixels_to_tile_units: r, u_extrude_scale: [e.pixelsToGLUnits[0] / (r * n), e.pixelsToGLUnits[1] / (r * n)], u_overscale_factor: a } }, zi = function (t, e, i) { return { u_matrix: t, u_inv_matrix: e, u_camera_to_center_distance: i.cameraToCenterDistance, u_viewport_size: [i.width, i.height] } }, ki = function (t, e, i) { return void 0 === i && (i = 1), { u_matrix: t, u_color: e, u_overlay: 0, u_overlay_scale: i } }, Li = function (t) { return { u_matrix: t } }, Di = function (t, e, i, r) { return { u_matrix: t, u_extrude_scale: pe(e, 1, i), u_intensity: r } }, Ri = function (e, i, r) { var n = e.transform; return { u_matrix: Ni(e, i, r), u_ratio: 1 / pe(i, 1, n.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]] } }, Bi = function (e, i, r, n) { return t.extend(Ri(e, i, r), { u_image: 0, u_image_height: n }) }, Oi = function (e, i, r, n) { var a = e.transform, o = Ui(i, a); return { u_matrix: Ni(e, i, r), u_texsize: i.imageAtlasTexture.size, u_ratio: 1 / pe(i, 1, a.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [o, n.fromScale, n.toScale], u_fade: n.t, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]] } }, Fi = function (e, i, r, n, a) { var o = e.lineAtlas, s = Ui(i, e.transform), l = "round" === r.layout.get("line-cap"), u = o.getDash(n.from, l), h = o.getDash(n.to, l), c = u.width * a.fromScale, p = h.width * a.toScale; return t.extend(Ri(e, i, r), { u_patternscale_a: [s / c, -u.height / 2], u_patternscale_b: [s / p, -h.height / 2], u_sdfgamma: o.width / (256 * Math.min(c, p) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: u.y, u_tex_y_b: h.y, u_mix: a.t }) }; function Ui(t, e) { return 1 / pe(t, 1, e.tileZoom) } function Ni(t, e, i) { return t.translatePosMatrix(e.tileID.posMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor")) } var Vi = function (t, e, i, r, n) { return { u_matrix: t, u_tl_parent: e, u_scale_parent: i, u_buffer_scale: 1, u_fade_t: r.mix, u_opacity: r.opacity * n.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n.paint.get("raster-brightness-min"), u_brightness_high: n.paint.get("raster-brightness-max"), u_saturation_factor: (o = n.paint.get("raster-saturation"), o > 0 ? 1 - 1 / (1.001 - o) : -o), u_contrast_factor: (a = n.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a), u_spin_weights: ji(n.paint.get("raster-hue-rotate")) }; var a, o }; function ji(t) { t *= Math.PI / 180; var e = Math.sin(t), i = Math.cos(t); return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3] } var qi, Gi = function (t, e, i, r, n, a, o, s, l, u) { var h = n.transform; return { u_is_size_zoom_constant: +("constant" === t || "source" === t), u_is_size_feature_constant: +("constant" === t || "camera" === t), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: h.cameraToCenterDistance, u_pitch: h.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i, u_aspect_ratio: h.width / h.height, u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1, u_matrix: a, u_label_plane_matrix: o, u_coord_matrix: s, u_is_text: +l, u_pitch_with_map: +r, u_texsize: u, u_texture: 0 } }, Zi = function (e, i, r, n, a, o, s, l, u, h, c) { var p = a.transform; return t.extend(Gi(e, i, r, n, a, o, s, l, u, h), { u_gamma_scale: n ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +c }) }, Xi = function (e, i, r, n, a, o, s, l, u, h) { return t.extend(Zi(e, i, r, n, a, o, s, l, !0, u, !0), { u_texsize_icon: h, u_texture_icon: 1 }) }, Wi = function (t, e, i) { return { u_matrix: t, u_opacity: e, u_color: i } }, Ki = function (e, i, r, n, a, o) { return t.extend(function (t, e, i, r) { var n = i.imageManager.getPattern(t.from.toString()), a = i.imageManager.getPattern(t.to.toString()), o = i.imageManager.getPixelSize(), s = o.width, l = o.height, u = Math.pow(2, r.tileID.overscaledZ), h = r.tileSize * Math.pow(2, i.transform.tileZoom) / u, c = h * (r.tileID.canonical.x + r.tileID.wrap * u), p = h * r.tileID.canonical.y; return { u_image: 0, u_pattern_tl_a: n.tl, u_pattern_br_a: n.br, u_pattern_tl_b: a.tl, u_pattern_br_b: a.br, u_texsize: [s, l], u_mix: e.t, u_pattern_size_a: n.displaySize, u_pattern_size_b: a.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / pe(r, 1, i.transform.tileZoom), u_pixel_coord_upper: [c >> 16, p >> 16], u_pixel_coord_lower: [65535 & c, 65535 & p] } }(n, o, r, a), { u_matrix: e, u_opacity: i }) }, Hi = { fillExtrusion: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_lightpos: new t.Uniform3f(e, i.u_lightpos), u_lightintensity: new t.Uniform1f(e, i.u_lightintensity), u_lightcolor: new t.Uniform3f(e, i.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient), u_opacity: new t.Uniform1f(e, i.u_opacity) } }, fillExtrusionPattern: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_lightpos: new t.Uniform3f(e, i.u_lightpos), u_lightintensity: new t.Uniform1f(e, i.u_lightintensity), u_lightcolor: new t.Uniform3f(e, i.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient), u_height_factor: new t.Uniform1f(e, i.u_height_factor), u_image: new t.Uniform1i(e, i.u_image), u_texsize: new t.Uniform2f(e, i.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, i.u_scale), u_fade: new t.Uniform1f(e, i.u_fade), u_opacity: new t.Uniform1f(e, i.u_opacity) } }, fill: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix) } }, fillPattern: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_image: new t.Uniform1i(e, i.u_image), u_texsize: new t.Uniform2f(e, i.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, i.u_scale), u_fade: new t.Uniform1f(e, i.u_fade) } }, fillOutline: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_world: new t.Uniform2f(e, i.u_world) } }, fillOutlinePattern: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_world: new t.Uniform2f(e, i.u_world), u_image: new t.Uniform1i(e, i.u_image), u_texsize: new t.Uniform2f(e, i.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower), u_scale: new t.Uniform3f(e, i.u_scale), u_fade: new t.Uniform1f(e, i.u_fade) } }, circle: function (e, i) { return { u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e, i.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e, i.u_matrix) } }, collisionBox: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e, i.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e, i.u_overscale_factor) } }, collisionCircle: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e, i.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e, i.u_viewport_size) } }, debug: function (e, i) { return { u_color: new t.UniformColor(e, i.u_color), u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_overlay: new t.Uniform1i(e, i.u_overlay), u_overlay_scale: new t.Uniform1f(e, i.u_overlay_scale) } }, clippingMask: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix) } }, heatmap: function (e, i) { return { u_extrude_scale: new t.Uniform1f(e, i.u_extrude_scale), u_intensity: new t.Uniform1f(e, i.u_intensity), u_matrix: new t.UniformMatrix4f(e, i.u_matrix) } }, heatmapTexture: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_world: new t.Uniform2f(e, i.u_world), u_image: new t.Uniform1i(e, i.u_image), u_color_ramp: new t.Uniform1i(e, i.u_color_ramp), u_opacity: new t.Uniform1f(e, i.u_opacity) } }, hillshade: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_image: new t.Uniform1i(e, i.u_image), u_latrange: new t.Uniform2f(e, i.u_latrange), u_light: new t.Uniform2f(e, i.u_light), u_shadow: new t.UniformColor(e, i.u_shadow), u_highlight: new t.UniformColor(e, i.u_highlight), u_accent: new t.UniformColor(e, i.u_accent) } }, hillshadePrepare: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_image: new t.Uniform1i(e, i.u_image), u_dimension: new t.Uniform2f(e, i.u_dimension), u_zoom: new t.Uniform1f(e, i.u_zoom), u_unpack: new t.Uniform4f(e, i.u_unpack) } }, line: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_ratio: new t.Uniform1f(e, i.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels) } }, lineGradient: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_ratio: new t.Uniform1f(e, i.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels), u_image: new t.Uniform1i(e, i.u_image), u_image_height: new t.Uniform1f(e, i.u_image_height) } }, linePattern: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_texsize: new t.Uniform2f(e, i.u_texsize), u_ratio: new t.Uniform1f(e, i.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_image: new t.Uniform1i(e, i.u_image), u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels), u_scale: new t.Uniform3f(e, i.u_scale), u_fade: new t.Uniform1f(e, i.u_fade) } }, lineSDF: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_ratio: new t.Uniform1f(e, i.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e, i.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e, i.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e, i.u_sdfgamma), u_image: new t.Uniform1i(e, i.u_image), u_tex_y_a: new t.Uniform1f(e, i.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e, i.u_tex_y_b), u_mix: new t.Uniform1f(e, i.u_mix) } }, raster: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_tl_parent: new t.Uniform2f(e, i.u_tl_parent), u_scale_parent: new t.Uniform1f(e, i.u_scale_parent), u_buffer_scale: new t.Uniform1f(e, i.u_buffer_scale), u_fade_t: new t.Uniform1f(e, i.u_fade_t), u_opacity: new t.Uniform1f(e, i.u_opacity), u_image0: new t.Uniform1i(e, i.u_image0), u_image1: new t.Uniform1i(e, i.u_image1), u_brightness_low: new t.Uniform1f(e, i.u_brightness_low), u_brightness_high: new t.Uniform1f(e, i.u_brightness_high), u_saturation_factor: new t.Uniform1f(e, i.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e, i.u_contrast_factor), u_spin_weights: new t.Uniform3f(e, i.u_spin_weights) } }, symbolIcon: function (e, i) { return { u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, i.u_size_t), u_size: new t.Uniform1f(e, i.u_size), u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, i.u_pitch), u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, i.u_fade_change), u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix), u_is_text: new t.Uniform1i(e, i.u_is_text), u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map), u_texsize: new t.Uniform2f(e, i.u_texsize), u_texture: new t.Uniform1i(e, i.u_texture) } }, symbolSDF: function (e, i) { return { u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, i.u_size_t), u_size: new t.Uniform1f(e, i.u_size), u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, i.u_pitch), u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, i.u_fade_change), u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix), u_is_text: new t.Uniform1i(e, i.u_is_text), u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map), u_texsize: new t.Uniform2f(e, i.u_texsize), u_texture: new t.Uniform1i(e, i.u_texture), u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e, i.u_is_halo) } }, symbolTextAndIcon: function (e, i) { return { u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e, i.u_size_t), u_size: new t.Uniform1f(e, i.u_size), u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e, i.u_pitch), u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio), u_fade_change: new t.Uniform1f(e, i.u_fade_change), u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix), u_is_text: new t.Uniform1i(e, i.u_is_text), u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map), u_texsize: new t.Uniform2f(e, i.u_texsize), u_texsize_icon: new t.Uniform2f(e, i.u_texsize_icon), u_texture: new t.Uniform1i(e, i.u_texture), u_texture_icon: new t.Uniform1i(e, i.u_texture_icon), u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e, i.u_is_halo) } }, background: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_opacity: new t.Uniform1f(e, i.u_opacity), u_color: new t.UniformColor(e, i.u_color) } }, backgroundPattern: function (e, i) { return { u_matrix: new t.UniformMatrix4f(e, i.u_matrix), u_opacity: new t.Uniform1f(e, i.u_opacity), u_image: new t.Uniform1i(e, i.u_image), u_pattern_tl_a: new t.Uniform2f(e, i.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e, i.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e, i.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e, i.u_pattern_br_b), u_texsize: new t.Uniform2f(e, i.u_texsize), u_mix: new t.Uniform1f(e, i.u_mix), u_pattern_size_a: new t.Uniform2f(e, i.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e, i.u_pattern_size_b), u_scale_a: new t.Uniform1f(e, i.u_scale_a), u_scale_b: new t.Uniform1f(e, i.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e, i.u_tile_units_to_pixels) } } }; function $i(e, i, r, n, a, o, s) { for (var l = e.context, u = l.gl, h = e.useProgram("collisionBox"), c = [], p = 0, f = 0, d = 0; d < n.length; d++) { var m = n[d], y = i.getTile(m), g = y.getBucket(r); if (g) { var _ = m.posMatrix; 0 === a[0] && 0 === a[1] || (_ = e.translatePosMatrix(m.posMatrix, y, a, o)); var v = s ? g.textCollisionBox : g.iconCollisionBox, x = g.collisionCircleArray; if (x.length > 0) { var b = t.create(), w = _; t.mul(b, g.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(b, b, g.placementViewportMatrix), c.push({ circleArray: x, circleOffset: f, transform: w, invTransform: b }), f = p += x.length / 4 } v && h.draw(l, u.LINES, Et.disabled, It.disabled, e.colorModeForRenderPass(), At.disabled, Ci(_, e.transform, y), r.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, null, e.transform.zoom, null, null, v.collisionVertexBuffer) } } if (s && c.length) { var M = e.useProgram("collisionCircle"), S = new t.StructArrayLayout2f1f2i16; S.resize(4 * p), S._trim(); for (var E = 0, I = 0, T = c; I < T.length; I += 1)for (var A = T[I], P = 0; P < A.circleArray.length / 4; P++) { var C = 4 * P, z = A.circleArray[C + 0], k = A.circleArray[C + 1], L = A.circleArray[C + 2], D = A.circleArray[C + 3]; S.emplace(E++, z, k, L, D, 0), S.emplace(E++, z, k, L, D, 1), S.emplace(E++, z, k, L, D, 2), S.emplace(E++, z, k, L, D, 3) } (!qi || qi.length < 2 * p) && (qi = function (e) { var i = 2 * e, r = new t.StructArrayLayout3ui6; r.resize(i), r._trim(); for (var n = 0; n < i; n++) { var a = 6 * n; r.uint16[a + 0] = 4 * n + 0, r.uint16[a + 1] = 4 * n + 1, r.uint16[a + 2] = 4 * n + 2, r.uint16[a + 3] = 4 * n + 2, r.uint16[a + 4] = 4 * n + 3, r.uint16[a + 5] = 4 * n + 0 } return r }(p)); for (var R = l.createIndexBuffer(qi, !0), B = l.createVertexBuffer(S, t.collisionCircleLayout.members, !0), O = 0, F = c; O < F.length; O += 1) { var U = F[O], N = zi(U.transform, U.invTransform, e.transform); M.draw(l, u.TRIANGLES, Et.disabled, It.disabled, e.colorModeForRenderPass(), At.disabled, N, r.id, B, R, t.SegmentVector.simpleSegment(0, 2 * U.circleOffset, U.circleArray.length, U.circleArray.length / 2), null, e.transform.zoom, null, null, null) } B.destroy(), R.destroy() } } var Ji = t.identity(new Float32Array(16)); function Yi(e, i, r, n, a, o) { var s = t.getAnchorAlignment(e), l = -(s.horizontalAlign - .5) * i, u = -(s.verticalAlign - .5) * r, h = t.evaluateVariableOffset(e, n); return new t.Point((l / a + h[0]) * o, (u / a + h[1]) * o) } function Qi(e, i, r, n, a, o, s, l, u, h, c) { var p = e.text.placedSymbolArray, f = e.text.dynamicLayoutVertexArray, d = e.icon.dynamicLayoutVertexArray, m = {}; f.clear(); for (var y = 0; y < p.length; y++) { var g = p.get(y), _ = g.hidden || !g.crossTileID || e.allowVerticalPlacement && !g.placedOrientation ? null : n[g.crossTileID]; if (_) { var v = new t.Point(g.anchorX, g.anchorY), x = Qt(v, r ? l : s), b = te(o.cameraToCenterDistance, x.signedDistanceFromCamera), w = a.evaluateSizeForFeature(e.textSizeData, h, g) * b / t.ONE_EM; r && (w *= e.tilePixelRatio / u); for (var M = Yi(_.anchor, _.width, _.height, _.textOffset, _.textBoxScale, w), S = r ? Qt(v.add(M), s).point : x.point.add(i ? M.rotate(-o.angle) : M), E = e.allowVerticalPlacement && g.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, I = 0; I < g.numGlyphs; I++)t.addDynamicAttributes(f, S, E); c && g.associatedIconIndex >= 0 && (m[g.associatedIconIndex] = { shiftedAnchor: S, angle: E }) } else ue(g.numGlyphs, f) } if (c) { d.clear(); for (var T = e.icon.placedSymbolArray, A = 0; A < T.length; A++) { var P = T.get(A); if (P.hidden) ue(P.numGlyphs, d); else { var C = m[A]; if (C) for (var z = 0; z < P.numGlyphs; z++)t.addDynamicAttributes(d, C.shiftedAnchor, C.angle); else ue(P.numGlyphs, d) } } e.icon.dynamicLayoutVertexBuffer.updateData(d) } e.text.dynamicLayoutVertexBuffer.updateData(f) } function tr(t, e, i) { return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon" } function er(e, i, r, n, a, o, s, l, u, h, c, p) { for (var f = e.context, d = f.gl, m = e.transform, y = "map" === l, g = "map" === u, _ = y && "point" !== r.layout.get("symbol-placement"), v = y && !g && !_, x = void 0 !== r.layout.get("symbol-sort-key").constantOr(1), b = !1, w = e.depthModeForSublayer(0, Et.ReadOnly), M = r.layout.get("text-variable-anchor"), S = [], E = 0, I = n; E < I.length; E += 1) { var T = I[E], A = i.getTile(T), P = A.getBucket(r); if (P) { var C = a ? P.text : P.icon; if (C && C.segments.get().length) { var z = C.programConfigurations.get(r.id), k = a || P.sdfIcons, L = a ? P.textSizeData : P.iconSizeData, D = g || 0 !== m.pitch, R = e.useProgram(tr(k, a, P), z), B = t.evaluateSizeForZoom(L, m.zoom), O = void 0, F = [0, 0], U = void 0, N = void 0, V = null, j = void 0; if (a) U = A.glyphAtlasTexture, N = d.LINEAR, O = A.glyphAtlasTexture.size, P.iconsInText && (F = A.imageAtlasTexture.size, V = A.imageAtlasTexture, j = D || e.options.rotating || e.options.zooming || "composite" === L.kind || "camera" === L.kind ? d.LINEAR : d.NEAREST); else { var q = 1 !== r.layout.get("icon-size").constantOr(0) || P.iconsNeedLinear; U = A.imageAtlasTexture, N = k || e.options.rotating || e.options.zooming || q || D ? d.LINEAR : d.NEAREST, O = A.imageAtlasTexture.size } var G = pe(A, 1, e.transform.zoom), Z = Jt(T.posMatrix, g, y, e.transform, G), X = Yt(T.posMatrix, g, y, e.transform, G), W = M && P.hasTextData(), K = "none" !== r.layout.get("icon-text-fit") && W && P.hasIconData(); _ && ie(P, T.posMatrix, e, a, Z, X, g, h); var H = e.translatePosMatrix(T.posMatrix, A, o, s), $ = _ || a && M || K ? Ji : Z, J = e.translatePosMatrix(X, A, o, s, !0), Y = k && 0 !== r.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1), Q = { program: R, buffers: C, uniformValues: k ? P.iconsInText ? Xi(L.kind, B, v, g, e, H, $, J, O, F) : Zi(L.kind, B, v, g, e, H, $, J, a, O, !0) : Gi(L.kind, B, v, g, e, H, $, J, a, O), atlasTexture: U, atlasTextureIcon: V, atlasInterpolation: N, atlasInterpolationIcon: j, isSDF: k, hasHalo: Y }; if (x && P.canOverlap) { b = !0; for (var tt = 0, et = C.segments.get(); tt < et.length; tt += 1) { var it = et[tt]; S.push({ segments: new t.SegmentVector([it]), sortKey: it.sortKey, state: Q }) } } else S.push({ segments: C.segments, sortKey: 0, state: Q }) } } } b && S.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var rt = 0, nt = S; rt < nt.length; rt += 1) { var at = nt[rt], ot = at.state; if (f.activeTexture.set(d.TEXTURE0), ot.atlasTexture.bind(ot.atlasInterpolation, d.CLAMP_TO_EDGE), ot.atlasTextureIcon && (f.activeTexture.set(d.TEXTURE1), ot.atlasTextureIcon && ot.atlasTextureIcon.bind(ot.atlasInterpolationIcon, d.CLAMP_TO_EDGE)), ot.isSDF) { var st = ot.uniformValues; ot.hasHalo && (st.u_is_halo = 1, ir(ot.buffers, at.segments, r, e, ot.program, w, c, p, st)), st.u_is_halo = 0 } ir(ot.buffers, at.segments, r, e, ot.program, w, c, p, ot.uniformValues) } } function ir(t, e, i, r, n, a, o, s, l) { var u = r.context; n.draw(u, u.gl.TRIANGLES, a, o, s, At.disabled, l, i.id, t.layoutVertexBuffer, t.indexBuffer, e, i.paint, r.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer) } function rr(t, e, i, r, n, a, o) { var s, l, u, h, c, p = t.context.gl, f = i.paint.get("fill-pattern"), d = f && f.constantOr(1), m = i.getCrossfadeParameters(); o ? (l = d && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s = p.LINES) : (l = d ? "fillPattern" : "fill", s = p.TRIANGLES); for (var y = 0, g = r; y < g.length; y += 1) { var _ = g[y], v = e.getTile(_); if (!d || v.patternsLoaded()) { var x = v.getBucket(i); if (x) { var b = x.programConfigurations.get(i.id), w = t.useProgram(l, b); d && (t.context.activeTexture.set(p.TEXTURE0), v.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), b.updatePaintBuffers(m)); var M = f.constantOr(null); if (M && v.imageAtlas) { var S = v.imageAtlas, E = S.patternPositions[M.to.toString()], I = S.patternPositions[M.from.toString()]; E && I && b.setConstantPatternPositions(E, I) } var T = t.translatePosMatrix(_.posMatrix, v, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor")); if (o) { h = x.indexBuffer2, c = x.segments2; var A = [p.drawingBufferWidth, p.drawingBufferHeight]; u = "fillOutlinePattern" === l && d ? Ai(T, t, m, v, A) : Ti(T, A) } else h = x.indexBuffer, c = x.segments, u = d ? Ii(T, t, m, v) : Ei(T); w.draw(t.context, s, n, t.stencilModeForClipping(_), a, At.disabled, u, i.id, x.layoutVertexBuffer, h, c, i.paint, t.transform.zoom, b) } } } } function nr(t, e, i, r, n, a, o) { for (var s = t.context, l = s.gl, u = i.paint.get("fill-extrusion-pattern"), h = u.constantOr(1), c = i.getCrossfadeParameters(), p = i.paint.get("fill-extrusion-opacity"), f = 0, d = r; f < d.length; f += 1) { var m = d[f], y = e.getTile(m), g = y.getBucket(i); if (g) { var _ = g.programConfigurations.get(i.id), v = t.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", _); h && (t.context.activeTexture.set(l.TEXTURE0), y.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), _.updatePaintBuffers(c)); var x = u.constantOr(null); if (x && y.imageAtlas) { var b = y.imageAtlas, w = b.patternPositions[x.to.toString()], M = b.patternPositions[x.from.toString()]; w && M && _.setConstantPatternPositions(w, M) } var S = t.translatePosMatrix(m.posMatrix, y, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), E = i.paint.get("fill-extrusion-vertical-gradient"), I = h ? Si(S, t, E, p, m, c, y) : Mi(S, t, E, p); v.draw(s, s.gl.TRIANGLES, n, a, o, At.backCCW, I, i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, i.paint, t.transform.zoom, _) } } } function ar(e, i, r, n, a, o) { var s = e.context, l = s.gl, u = i.fbo; if (u) { var h = e.useProgram("hillshade"); s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, u.colorAttachment.get()); var c = function (e, i, r) { var n = r.paint.get("hillshade-shadow-color"), a = r.paint.get("hillshade-highlight-color"), o = r.paint.get("hillshade-accent-color"), s = r.paint.get("hillshade-illumination-direction") * (Math.PI / 180); "viewport" === r.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle); var l, u, h, c = !e.options.moving; return { u_matrix: e.transform.calculatePosMatrix(i.tileID.toUnwrapped(), c), u_image: 0, u_latrange: (l = i.tileID, u = Math.pow(2, l.canonical.z), h = l.canonical.y, [new t.MercatorCoordinate(0, h / u).toLngLat().lat, new t.MercatorCoordinate(0, (h + 1) / u).toLngLat().lat]), u_light: [r.paint.get("hillshade-exaggeration"), s], u_shadow: n, u_highlight: a, u_accent: o } }(e, i, r); h.draw(s, l.TRIANGLES, n, a, o, At.disabled, c, r.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments) } } function or(e, i, r, n, a, o) { var s = e.context, l = s.gl, u = i.dem; if (u && u.data) { var h = u.dim, c = u.stride, p = u.getPixels(); if (s.activeTexture.set(l.TEXTURE1), s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(c), i.demTexture) { var f = i.demTexture; f.update(p, { premultiply: !1 }), f.bind(l.NEAREST, l.CLAMP_TO_EDGE) } else i.demTexture = new t.Texture(s, p, l.RGBA, { premultiply: !1 }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE); s.activeTexture.set(l.TEXTURE0); var d = i.fbo; if (!d) { var m = new t.Texture(s, { width: h, height: h, data: null }, l.RGBA); m.bind(l.LINEAR, l.CLAMP_TO_EDGE), (d = i.fbo = s.createFramebuffer(h, h, !0)).colorAttachment.set(m.texture) } s.bindFramebuffer.set(d.framebuffer), s.viewport.set([0, 0, h, h]), e.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, n, a, o, At.disabled, function (e, i) { var r = i.stride, n = t.create(); return t.ortho(n, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(n, n, [0, -t.EXTENT, 0]), { u_matrix: n, u_image: 1, u_dimension: [r, r], u_zoom: e.overscaledZ, u_unpack: i.getUnpackVector() } }(i.tileID, u), r.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1 } } function sr(e, i, r, n, a) { var o = n.paint.get("raster-fade-duration"); if (o > 0) { var s = t.browser.now(), l = (s - e.timeAdded) / o, u = i ? (s - i.timeAdded) / o : -1, h = r.getSource(), c = a.coveringZoomLevel({ tileSize: h.tileSize, roundZoom: h.roundZoom }), p = !i || Math.abs(i.tileID.overscaledZ - c) > Math.abs(e.tileID.overscaledZ - c), f = p && e.refreshedUponExpiration ? 1 : t.clamp(p ? l : 1 - u, 0, 1); return e.refreshedUponExpiration && l >= 1 && (e.refreshedUponExpiration = !1), i ? { opacity: 1, mix: 1 - f } : { opacity: f, mix: 0 } } return { opacity: 1, mix: 0 } } var lr = new t.Color(1, 0, 0, 1), ur = new t.Color(0, 1, 0, 1), hr = new t.Color(0, 0, 1, 1), cr = new t.Color(1, 0, 1, 1), pr = new t.Color(0, 1, 1, 1); function fr(t, e, i, r) { mr(t, 0, e + i / 2, t.transform.width, i, r) } function dr(t, e, i, r) { mr(t, e - i / 2, 0, i, t.transform.height, r) } function mr(e, i, r, n, a, o) { var s = e.context, l = s.gl; l.enable(l.SCISSOR_TEST), l.scissor(i * t.browser.devicePixelRatio, r * t.browser.devicePixelRatio, n * t.browser.devicePixelRatio, a * t.browser.devicePixelRatio), s.clear({ color: o }), l.disable(l.SCISSOR_TEST) } function yr(e, i, r) { var n = e.context, a = n.gl, o = r.posMatrix, s = e.useProgram("debug"), l = Et.disabled, u = It.disabled, h = e.colorModeForRenderPass(); n.activeTexture.set(a.TEXTURE0), e.emptyTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), s.draw(n, a.LINE_STRIP, l, u, h, At.disabled, ki(o, t.Color.red), "$debug", e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments); var c = i.getTileByID(r.key).latestRawTileData, p = Math.floor((c && c.byteLength || 0) / 1024), f = i.getTile(r).tileSize, d = 512 / Math.min(f, 512) * (r.overscaledZ / e.transform.zoom) * .5, m = r.canonical.toString(); r.overscaledZ !== r.canonical.z && (m += " => " + r.overscaledZ), function (t, e) { t.initDebugOverlayCanvas(); var i = t.debugOverlayCanvas, r = t.context.gl, n = t.debugOverlayCanvas.getContext("2d"); n.clearRect(0, 0, i.width, i.height), n.shadowColor = "white", n.shadowBlur = 2, n.lineWidth = 1.5, n.strokeStyle = "white", n.textBaseline = "top", n.font = "bold 36px Open Sans, sans-serif", n.fillText(e, 5, 5), n.strokeText(e, 5, 5), t.debugOverlayTexture.update(i), t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE) }(e, m + " " + p + "kb"), s.draw(n, a.TRIANGLES, l, u, Tt.alphaBlended, At.disabled, ki(o, t.Color.transparent, d), "$debug", e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments) } var gr = { symbol: function (e, i, r, n, a) { if ("translucent" === e.renderPass) { var o = It.disabled, s = e.colorModeForRenderPass(); r.layout.get("text-variable-anchor") && function (e, i, r, n, a, o, s) { for (var l = i.transform, u = "map" === a, h = "map" === o, c = 0, p = e; c < p.length; c += 1) { var f = p[c], d = n.getTile(f), m = d.getBucket(r); if (m && m.text && m.text.segments.get().length) { var y = t.evaluateSizeForZoom(m.textSizeData, l.zoom), g = pe(d, 1, i.transform.zoom), _ = Jt(f.posMatrix, h, u, i.transform, g), v = "none" !== r.layout.get("icon-text-fit") && m.hasIconData(); if (y) { var x = Math.pow(2, l.zoom - d.tileID.overscaledZ); Qi(m, u, h, s, t.symbolSize, l, _, f.posMatrix, x, y, v) } } } }(n, e, r, i, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), a), 0 !== r.paint.get("icon-opacity").constantOr(1) && er(e, i, r, n, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), o, s), 0 !== r.paint.get("text-opacity").constantOr(1) && er(e, i, r, n, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), o, s), i.map.showCollisionBoxes && ($i(e, i, r, n, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), !0), $i(e, i, r, n, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), !1)) } }, circle: function (e, i, r, n) { if ("translucent" === e.renderPass) { var a = r.paint.get("circle-opacity"), o = r.paint.get("circle-stroke-width"), s = r.paint.get("circle-stroke-opacity"), l = void 0 !== r.layout.get("circle-sort-key").constantOr(1); if (0 !== a.constantOr(1) || 0 !== o.constantOr(1) && 0 !== s.constantOr(1)) { for (var u = e.context, h = u.gl, c = e.depthModeForSublayer(0, Et.ReadOnly), p = It.disabled, f = e.colorModeForRenderPass(), d = [], m = 0; m < n.length; m++) { var y = n[m], g = i.getTile(y), _ = g.getBucket(r); if (_) { var v = _.programConfigurations.get(r.id), x = { programConfiguration: v, program: e.useProgram("circle", v), layoutVertexBuffer: _.layoutVertexBuffer, indexBuffer: _.indexBuffer, uniformValues: Pi(e, y, g, r) }; if (l) for (var b = 0, w = _.segments.get(); b < w.length; b += 1) { var M = w[b]; d.push({ segments: new t.SegmentVector([M]), sortKey: M.sortKey, state: x }) } else d.push({ segments: _.segments, sortKey: 0, state: x }) } } l && d.sort((function (t, e) { return t.sortKey - e.sortKey })); for (var S = 0, E = d; S < E.length; S += 1) { var I = E[S], T = I.state; T.program.draw(u, h.TRIANGLES, c, p, f, At.disabled, T.uniformValues, r.id, T.layoutVertexBuffer, T.indexBuffer, I.segments, r.paint, e.transform.zoom, T.programConfiguration) } } } }, heatmap: function (e, i, r, n) { if (0 !== r.paint.get("heatmap-opacity")) if ("offscreen" === e.renderPass) { var a = e.context, o = a.gl, s = It.disabled, l = new Tt([o.ONE, o.ONE], t.Color.transparent, [!0, !0, !0, !0]); !function (t, e, i) { var r = t.gl; t.activeTexture.set(r.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]); var n = i.heatmapFbo; if (n) r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), t.bindFramebuffer.set(n.framebuffer); else { var a = r.createTexture(); r.bindTexture(r.TEXTURE_2D, a), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), n = i.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, i, r) { var n = t.gl; n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.width / 4, e.height / 4, 0, n.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : n.UNSIGNED_BYTE, null), r.colorAttachment.set(i) }(t, e, a, n) } }(a, e, r), a.clear({ color: t.Color.transparent }); for (var u = 0; u < n.length; u++) { var h = n[u]; if (!i.hasRenderableParent(h)) { var c = i.getTile(h), p = c.getBucket(r); if (p) { var f = p.programConfigurations.get(r.id); e.useProgram("heatmap", f).draw(a, o.TRIANGLES, Et.disabled, s, l, At.disabled, Di(h.posMatrix, c, e.transform.zoom, r.paint.get("heatmap-intensity")), r.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, r.paint, e.transform.zoom, f) } } } a.viewport.set([0, 0, e.width, e.height]) } else "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, i) { var r = e.context, n = r.gl, a = i.heatmapFbo; if (a) { r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, a.colorAttachment.get()), r.activeTexture.set(n.TEXTURE1); var o = i.colorRampTexture; o || (o = i.colorRampTexture = new t.Texture(r, i.colorRamp, n.RGBA)), o.bind(n.LINEAR, n.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(r, n.TRIANGLES, Et.disabled, It.disabled, e.colorModeForRenderPass(), At.disabled, function (e, i, r, n) { var a = t.create(); t.ortho(a, 0, e.width, e.height, 0, 0, 1); var o = e.context.gl; return { u_matrix: a, u_world: [o.drawingBufferWidth, o.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i.paint.get("heatmap-opacity") } }(e, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom) } }(e, r)) }, line: function (e, i, r, n) { if ("translucent" === e.renderPass) { var a = r.paint.get("line-opacity"), o = r.paint.get("line-width"); if (0 !== a.constantOr(1) && 0 !== o.constantOr(1)) for (var s = e.depthModeForSublayer(0, Et.ReadOnly), l = e.colorModeForRenderPass(), u = r.paint.get("line-dasharray"), h = r.paint.get("line-pattern"), c = h.constantOr(1), p = r.paint.get("line-gradient"), f = r.getCrossfadeParameters(), d = c ? "linePattern" : u ? "lineSDF" : p ? "lineGradient" : "line", m = e.context, y = m.gl, g = !0, _ = 0, v = n; _ < v.length; _ += 1) { var x = v[_], b = i.getTile(x); if (!c || b.patternsLoaded()) { var w = b.getBucket(r); if (w) { var M = w.programConfigurations.get(r.id), S = e.context.program.get(), E = e.useProgram(d, M), I = g || E.program !== S, T = h.constantOr(null); if (T && b.imageAtlas) { var A = b.imageAtlas, P = A.patternPositions[T.to.toString()], C = A.patternPositions[T.from.toString()]; P && C && M.setConstantPatternPositions(P, C) } var z = c ? Oi(e, b, r, f) : u ? Fi(e, b, r, u, f) : p ? Bi(e, b, r, w.lineClipsArray.length) : Ri(e, b, r); if (c) m.activeTexture.set(y.TEXTURE0), b.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), M.updatePaintBuffers(f); else if (u && (I || e.lineAtlas.dirty)) m.activeTexture.set(y.TEXTURE0), e.lineAtlas.bind(m); else if (p) { var k = w.gradients[r.id], L = k.texture; if (r.gradientVersion !== k.version) { var D = 256; if (r.stepInterpolant) { var R = i.getSource().maxzoom, B = x.canonical.z === R ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1; D = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * B), 256, m.maxTextureSize) } k.gradient = t.renderColorRamp({ expression: r.gradientExpression(), evaluationKey: "lineProgress", resolution: D, image: k.gradient || void 0, clips: w.lineClipsArray }), k.texture ? k.texture.update(k.gradient) : k.texture = new t.Texture(m, k.gradient, y.RGBA), k.version = r.gradientVersion, L = k.texture } m.activeTexture.set(y.TEXTURE0), L.bind(r.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE) } E.draw(m, y.TRIANGLES, s, e.stencilModeForClipping(x), l, At.disabled, z, r.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, r.paint, e.transform.zoom, M, w.layoutVertexBuffer2), g = !1 } } } } }, fill: function (e, i, r, n) { var a = r.paint.get("fill-color"), o = r.paint.get("fill-opacity"); if (0 !== o.constantOr(1)) { var s = e.colorModeForRenderPass(), l = r.paint.get("fill-pattern"), u = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === a.constantOr(t.Color.transparent).a && 1 === o.constantOr(0) ? "opaque" : "translucent"; if (e.renderPass === u) { var h = e.depthModeForSublayer(1, "opaque" === e.renderPass ? Et.ReadWrite : Et.ReadOnly); rr(e, i, r, n, h, s, !1) } if ("translucent" === e.renderPass && r.paint.get("fill-antialias")) { var c = e.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, Et.ReadOnly); rr(e, i, r, n, c, s, !0) } } }, "fill-extrusion": function (t, e, i, r) { var n = i.paint.get("fill-extrusion-opacity"); if (0 !== n && "translucent" === t.renderPass) { var a = new Et(t.context.gl.LEQUAL, Et.ReadWrite, t.depthRangeFor3D); if (1 !== n || i.paint.get("fill-extrusion-pattern").constantOr(1)) nr(t, e, i, r, a, It.disabled, Tt.disabled), nr(t, e, i, r, a, t.stencilModeFor3D(), t.colorModeForRenderPass()); else { var o = t.colorModeForRenderPass(); nr(t, e, i, r, a, It.disabled, o) } } }, hillshade: function (t, e, i, r) { if ("offscreen" === t.renderPass || "translucent" === t.renderPass) { for (var n = t.context, a = t.depthModeForSublayer(0, Et.ReadOnly), o = t.colorModeForRenderPass(), s = "translucent" === t.renderPass ? t.stencilConfigForOverlap(r) : [{}, r], l = s[0], u = 0, h = s[1]; u < h.length; u += 1) { var c = h[u], p = e.getTile(c); p.needsHillshadePrepare && "offscreen" === t.renderPass ? or(t, p, i, a, It.disabled, o) : "translucent" === t.renderPass && ar(t, p, i, a, l[c.overscaledZ], o) } n.viewport.set([0, 0, t.width, t.height]) } }, raster: function (t, e, i, r) { if ("translucent" === t.renderPass && 0 !== i.paint.get("raster-opacity") && r.length) for (var n = t.context, a = n.gl, o = e.getSource(), s = t.useProgram("raster"), l = t.colorModeForRenderPass(), u = o instanceof k ? [{}, r] : t.stencilConfigForOverlap(r), h = u[0], c = u[1], p = c[c.length - 1].overscaledZ, f = !t.options.moving, d = 0, m = c; d < m.length; d += 1) { var y = m[d], g = t.depthModeForSublayer(y.overscaledZ - p, 1 === i.paint.get("raster-opacity") ? Et.ReadWrite : Et.ReadOnly, a.LESS), _ = e.getTile(y), v = t.transform.calculatePosMatrix(y.toUnwrapped(), f); _.registerFadeDuration(i.paint.get("raster-fade-duration")); var x = e.findLoadedParent(y, 0), b = sr(_, x, e, i, t.transform), w = void 0, M = void 0, S = "nearest" === i.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR; n.activeTexture.set(a.TEXTURE0), _.texture.bind(S, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), n.activeTexture.set(a.TEXTURE1), x ? (x.texture.bind(S, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - _.tileID.overscaledZ), M = [_.tileID.canonical.x * w % 1, _.tileID.canonical.y * w % 1]) : _.texture.bind(S, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST); var E = Vi(v, M || [0, 0], w || 1, b, i); o instanceof k ? s.draw(n, a.TRIANGLES, g, It.disabled, l, At.disabled, E, i.id, o.boundsBuffer, t.quadTriangleIndexBuffer, o.boundsSegments) : s.draw(n, a.TRIANGLES, g, h[y.overscaledZ], l, At.disabled, E, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments) } }, background: function (t, e, i) { var r = i.paint.get("background-color"), n = i.paint.get("background-opacity"); if (0 !== n) { var a = t.context, o = a.gl, s = t.transform, l = s.tileSize, u = i.paint.get("background-pattern"); if (!t.isPatternMissing(u)) { var h = !u && 1 === r.a && 1 === n && t.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (t.renderPass === h) { var c = It.disabled, p = t.depthModeForSublayer(0, "opaque" === h ? Et.ReadWrite : Et.ReadOnly), f = t.colorModeForRenderPass(), d = t.useProgram(u ? "backgroundPattern" : "background"), m = s.coveringTiles({ tileSize: l }); u && (a.activeTexture.set(o.TEXTURE0), t.imageManager.bind(t.context)); for (var y = i.getCrossfadeParameters(), g = 0, _ = m; g < _.length; g += 1) { var v = _[g], x = t.transform.calculatePosMatrix(v.toUnwrapped()), b = u ? Ki(x, n, t, u, { tileID: v, tileSize: l }, y) : Wi(x, n, r); d.draw(a, o.TRIANGLES, p, c, f, At.disabled, b, i.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments) } } } } }, debug: function (t, e, i) { for (var r = 0; r < i.length; r++)yr(t, e, i[r]) }, custom: function (t, e, i) { var r = t.context, n = i.implementation; if ("offscreen" === t.renderPass) { var a = n.prerender; a && (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), a.call(n, r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState()) } else if ("translucent" === t.renderPass) { t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(It.disabled); var o = "3d" === n.renderingMode ? new Et(t.context.gl.LEQUAL, Et.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, Et.ReadOnly); r.setDepthMode(o), n.render(r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null) } } }, _r = function (t, e) { this.context = new Pt(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = Ct.maxUnderzooming + Ct.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe, this.gpuTimers = {} }; _r.prototype.resize = function (e, i) { if (this.width = e * t.browser.devicePixelRatio, this.height = i * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var r = 0, n = this.style._order; r < n.length; r += 1)this.style._layers[n[r]].resize() }, _r.prototype.setup = function () { var e = this.context, i = new t.StructArrayLayout2i4; i.emplaceBack(0, 0), i.emplaceBack(t.EXTENT, 0), i.emplaceBack(0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(i, Ge.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var r = new t.StructArrayLayout2i4; r.emplaceBack(0, 0), r.emplaceBack(t.EXTENT, 0), r.emplaceBack(0, t.EXTENT), r.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(r, Ge.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5); var n = new t.StructArrayLayout4i8; n.emplaceBack(0, 0, 0, 0), n.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), n.emplaceBack(0, t.EXTENT, 0, t.EXTENT), n.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(n, z.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var a = new t.StructArrayLayout2i4; a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, Ge.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2); var o = new t.StructArrayLayout1ui2; o.emplaceBack(0), o.emplaceBack(1), o.emplaceBack(3), o.emplaceBack(2), o.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(o); var s = new t.StructArrayLayout3ui6; s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s), this.emptyTexture = new t.Texture(e, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e.gl.RGBA); var l = this.context.gl; this.stencilClearMode = new It({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO) }, _r.prototype.clearStencil = function () { var e = this.context, i = e.gl; this.nextStencilID = 1, this.currentStencilSource = void 0; var r = t.create(); t.ortho(r, 0, this.width, this.height, 0, 0, 1), t.scale(r, r, [i.drawingBufferWidth, i.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, i.TRIANGLES, Et.disabled, this.stencilClearMode, Tt.disabled, At.disabled, Li(r), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments) }, _r.prototype._renderTileClippingMasks = function (t, e) { if (this.currentStencilSource !== t.source && t.isTileClipped() && e && e.length) { this.currentStencilSource = t.source; var i = this.context, r = i.gl; this.nextStencilID + e.length > 256 && this.clearStencil(), i.setColorMode(Tt.disabled), i.setDepthMode(Et.disabled); var n = this.useProgram("clippingMask"); this._tileClippingMaskIDs = {}; for (var a = 0, o = e; a < o.length; a += 1) { var s = o[a], l = this._tileClippingMaskIDs[s.key] = this.nextStencilID++; n.draw(i, r.TRIANGLES, Et.disabled, new It({ func: r.ALWAYS, mask: 0 }, l, 255, r.KEEP, r.KEEP, r.REPLACE), Tt.disabled, At.disabled, Li(s.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments) } } }, _r.prototype.stencilModeFor3D = function () { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); var t = this.nextStencilID++, e = this.context.gl; return new It({ func: e.NOTEQUAL, mask: 255 }, t, 255, e.KEEP, e.KEEP, e.REPLACE) }, _r.prototype.stencilModeForClipping = function (t) { var e = this.context.gl; return new It({ func: e.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE) }, _r.prototype.stencilConfigForOverlap = function (t) { var e, i = this.context.gl, r = t.sort((function (t, e) { return e.overscaledZ - t.overscaledZ })), n = r[r.length - 1].overscaledZ, a = r[0].overscaledZ - n + 1; if (a > 1) { this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil(); for (var o = {}, s = 0; s < a; s++)o[s + n] = new It({ func: i.GEQUAL, mask: 255 }, s + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE); return this.nextStencilID += a, [o, r] } return [(e = {}, e[n] = It.disabled, e), r] }, _r.prototype.colorModeForRenderPass = function () { var e = this.context.gl; return this._showOverdrawInspector ? new Tt([e.CONSTANT_COLOR, e.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? Tt.unblended : Tt.alphaBlended }, _r.prototype.depthModeForSublayer = function (t, e, i) { if (!this.opaquePassEnabledForLayer()) return Et.disabled; var r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon; return new Et(i || this.context.gl.LEQUAL, e, [r, r]) }, _r.prototype.opaquePassEnabledForLayer = function () { return this.currentLayer < this.opaquePassCutoff }, _r.prototype.render = function (e, i) { var r = this; this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame(); var n = this.style._order, a = this.style.sourceCaches; for (var o in a) { var s = a[o]; s.used && s.prepare(this.context) } var l, u, h = {}, c = {}, p = {}; for (var f in a) { var d = a[f]; h[f] = d.getVisibleCoordinates(), c[f] = h[f].slice().reverse(), p[f] = d.getVisibleCoordinates(!0).reverse() } this.opaquePassCutoff = 1 / 0; for (var m = 0; m < n.length; m++)if (this.style._layers[n[m]].is3D()) { this.opaquePassCutoff = m; break } this.renderPass = "offscreen"; for (var y = 0, g = n; y < g.length; y += 1) { var _ = this.style._layers[g[y]]; if (_.hasOffscreenPass() && !_.isHidden(this.transform.zoom)) { var v = c[_.source]; ("custom" === _.type || v.length) && this.renderLayer(this, a[_.source], _, v) } } for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = n.length - 1; this.currentLayer >= 0; this.currentLayer--) { var x = this.style._layers[n[this.currentLayer]], b = a[x.source], w = h[x.source]; this._renderTileClippingMasks(x, w), this.renderLayer(this, b, x, w) } for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) { var M = this.style._layers[n[this.currentLayer]], S = a[M.source], E = ("symbol" === M.type ? p : c)[M.source]; this._renderTileClippingMasks(M, h[M.source]), this.renderLayer(this, S, M, E) } this.options.showTileBoundaries && (t.values(this.style._layers).forEach((function (t) { t.source && !t.isHidden(r.transform.zoom) && (t.source !== (u && u.id) && (u = r.style.sourceCaches[t.source]), (!l || l.getSource().maxzoom < u.getSource().maxzoom) && (l = u)) })), l && gr.debug(this, l, l.getVisibleCoordinates())), this.options.showPadding && function (t) { var e = t.transform.padding; fr(t, t.transform.height - (e.top || 0), 3, lr), fr(t, e.bottom || 0, 3, ur), dr(t, e.left || 0, 3, hr), dr(t, t.transform.width - (e.right || 0), 3, cr); var i = t.transform.centerPoint; !function (t, e, i, r) { mr(t, e - 1, i - 10, 2, 20, r), mr(t, e - 10, i - 1, 20, 2, r) }(t, i.x, t.transform.height - i.y, pr) }(this), this.context.setDefault() }, _r.prototype.renderLayer = function (t, e, i, r) { i.isHidden(this.transform.zoom) || ("background" === i.type || "custom" === i.type || r.length) && (this.id = i.id, this.gpuTimingStart(i), gr[i.type](t, e, i, r, this.style.placement.variableOffsets), this.gpuTimingEnd()) }, _r.prototype.gpuTimingStart = function (t) { if (this.options.gpuTiming) { var e = this.context.extTimerQuery, i = this.gpuTimers[t.id]; i || (i = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: e.createQueryEXT() }), i.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query) } }, _r.prototype.gpuTimingEnd = function () { if (this.options.gpuTiming) { var t = this.context.extTimerQuery; t.endQueryEXT(t.TIME_ELAPSED_EXT) } }, _r.prototype.collectGpuTimers = function () { var t = this.gpuTimers; return this.gpuTimers = {}, t }, _r.prototype.queryGpuTimers = function (t) { var e = {}; for (var i in t) { var r = t[i], n = this.context.extTimerQuery, a = n.getQueryObjectEXT(r.query, n.QUERY_RESULT_EXT) / 1e6; n.deleteQueryEXT(r.query), e[i] = a } return e }, _r.prototype.translatePosMatrix = function (e, i, r, n, a) { if (!r[0] && !r[1]) return e; var o = a ? "map" === n ? this.transform.angle : 0 : "viewport" === n ? -this.transform.angle : 0; if (o) { var s = Math.sin(o), l = Math.cos(o); r = [r[0] * l - r[1] * s, r[0] * s + r[1] * l] } var u = [a ? r[0] : pe(i, r[0], this.transform.zoom), a ? r[1] : pe(i, r[1], this.transform.zoom), 0], h = new Float32Array(16); return t.translate(h, e, u), h }, _r.prototype.saveTileTexture = function (t) { var e = this._tileTextures[t.size[0]]; e ? e.push(t) : this._tileTextures[t.size[0]] = [t] }, _r.prototype.getTileTexture = function (t) { var e = this._tileTextures[t]; return e && e.length > 0 ? e.pop() : null }, _r.prototype.isPatternMissing = function (t) { if (!t) return !1; if (!t.from || !t.to) return !0; var e = this.imageManager.getPattern(t.from.toString()), i = this.imageManager.getPattern(t.to.toString()); return !e || !i }, _r.prototype.useProgram = function (t, e) { this.cache = this.cache || {}; var i = "" + t + (e ? e.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : ""); return this.cache[i] || (this.cache[i] = new bi(this.context, t, _i[t], e, Hi[t], this._showOverdrawInspector)), this.cache[i] }, _r.prototype.setCustomLayerDefaults = function () { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault() }, _r.prototype.setBaseState = function () { var t = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD) }, _r.prototype.initDebugOverlayCanvas = function () { null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)) }, _r.prototype.destroy = function () { this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy() }; var vr = function (t, e) { this.points = t, this.planes = e }; vr.fromInvProjectionMatrix = function (e, i, r) { var n = Math.pow(2, r), a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((function (i) { return t.transformMat4([], i, e) })).map((function (e) { return t.scale$1([], e, 1 / e[3] / i * n) })), o = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((function (e) { var i = t.sub([], a[e[0]], a[e[1]]), r = t.sub([], a[e[2]], a[e[1]]), n = t.normalize([], t.cross([], i, r)), o = -t.dot(n, a[e[1]]); return n.concat(o) })); return new vr(a, o) }; var xr = function (e, i) { this.min = e, this.max = i, this.center = t.scale$2([], t.add([], this.min, this.max), .5) }; xr.prototype.quadrant = function (e) { for (var i = [e % 2 == 0, e < 2], r = t.clone$2(this.min), n = t.clone$2(this.max), a = 0; a < i.length; a++)r[a] = i[a] ? this.min[a] : this.center[a], n[a] = i[a] ? this.center[a] : this.max[a]; return n[2] = this.max[2], new xr(r, n) }, xr.prototype.distanceX = function (t) { return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0] }, xr.prototype.distanceY = function (t) { return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1] }, xr.prototype.intersects = function (e) { for (var i = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], r = !0, n = 0; n < e.planes.length; n++) { for (var a = e.planes[n], o = 0, s = 0; s < i.length; s++)o += t.dot$1(a, i[s]) >= 0; if (0 === o) return 0; o !== i.length && (r = !1) } if (r) return 2; for (var l = 0; l < 3; l++) { for (var u = Number.MAX_VALUE, h = -Number.MAX_VALUE, c = 0; c < e.points.length; c++) { var p = e.points[c][l] - this.min[l]; u = Math.min(u, p), h = Math.max(h, p) } if (h < 0 || u > this.max[l] - this.min[l]) return 0 } return 1 }; var br = function (t, e, i, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(r) || r < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = t, this.bottom = e, this.left = i, this.right = r }; br.prototype.interpolate = function (e, i, r) { return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, r)), null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, r)), null != i.left && null != e.left && (this.left = t.number(e.left, i.left, r)), null != i.right && null != e.right && (this.right = t.number(e.right, i.right, r)), this }, br.prototype.getCenter = function (e, i) { var r = t.clamp((this.left + e - this.right) / 2, 0, e), n = t.clamp((this.top + i - this.bottom) / 2, 0, i); return new t.Point(r, n) }, br.prototype.equals = function (t) { return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right }, br.prototype.clone = function () { return new br(this.top, this.bottom, this.left, this.right) }, br.prototype.toJSON = function () { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } }; var wr = function (e, i, r, n, a) { this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a || a, this._minZoom = e || 0, this._maxZoom = i || 22, this._minPitch = null == r ? 0 : r, this._maxPitch = null == n ? 60 : n, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new br, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} }, Mr = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } }; wr.prototype.clone = function () { var t = new wr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies); return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t }, Mr.minZoom.get = function () { return this._minZoom }, Mr.minZoom.set = function (t) { this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t)) }, Mr.maxZoom.get = function () { return this._maxZoom }, Mr.maxZoom.set = function (t) { this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t)) }, Mr.minPitch.get = function () { return this._minPitch }, Mr.minPitch.set = function (t) { this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t)) }, Mr.maxPitch.get = function () { return this._maxPitch }, Mr.maxPitch.set = function (t) { this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t)) }, Mr.renderWorldCopies.get = function () { return this._renderWorldCopies }, Mr.renderWorldCopies.set = function (t) { void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t }, Mr.worldSize.get = function () { return this.tileSize * this.scale }, Mr.centerOffset.get = function () { return this.centerPoint._sub(this.size._div(2)) }, Mr.size.get = function () { return new t.Point(this.width, this.height) }, Mr.bearing.get = function () { return -this.angle / Math.PI * 180 }, Mr.bearing.set = function (e) { var i = -t.wrap(e, -180, 180) * Math.PI / 180; this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle)) }, Mr.pitch.get = function () { return this._pitch / Math.PI * 180 }, Mr.pitch.set = function (e) { var i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices()) }, Mr.fov.get = function () { return this._fov / Math.PI * 180 }, Mr.fov.set = function (t) { t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices()) }, Mr.zoom.get = function () { return this._zoom }, Mr.zoom.set = function (t) { var e = Math.min(Math.max(t, this.minZoom), this.maxZoom); this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices()) }, Mr.center.get = function () { return this._center }, Mr.center.set = function (t) { t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices()) }, Mr.padding.get = function () { return this._edgeInsets.toJSON() }, Mr.padding.set = function (t) { this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices()) }, Mr.centerPoint.get = function () { return this._edgeInsets.getCenter(this.width, this.height) }, wr.prototype.isPaddingEqual = function (t) { return this._edgeInsets.equals(t) }, wr.prototype.interpolatePadding = function (t, e, i) { this._unmodified = !1, this._edgeInsets.interpolate(t, e, i), this._constrain(), this._calcMatrices() }, wr.prototype.coveringZoomLevel = function (t) { var e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize)); return Math.max(0, e) }, wr.prototype.getVisibleUnwrappedCoordinates = function (e) { var i = [new t.UnwrappedTileID(0, e)]; if (this._renderWorldCopies) for (var r = this.pointCoordinate(new t.Point(0, 0)), n = this.pointCoordinate(new t.Point(this.width, 0)), a = this.pointCoordinate(new t.Point(this.width, this.height)), o = this.pointCoordinate(new t.Point(0, this.height)), s = Math.floor(Math.min(r.x, n.x, a.x, o.x)), l = Math.floor(Math.max(r.x, n.x, a.x, o.x)), u = s - 1; u <= l + 1; u++)0 !== u && i.push(new t.UnwrappedTileID(u, e)); return i }, wr.prototype.coveringTiles = function (e) { var i = this.coveringZoomLevel(e), r = i; if (void 0 !== e.minzoom && i < e.minzoom) return []; void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom); var n = t.MercatorCoordinate.fromLngLat(this.center), a = Math.pow(2, i), o = [a * n.x, a * n.y, 0], s = vr.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i), l = e.minzoom || 0; this.pitch <= 60 && this._edgeInsets.top < .1 && (l = i); var u = function (t) { return { aabb: new xr([t * a, 0, 0], [(t + 1) * a, a, 0]), zoom: 0, x: 0, y: 0, wrap: t, fullyVisible: !1 } }, h = [], c = [], p = i, f = e.reparseOverscaled ? r : i; if (this._renderWorldCopies) for (var d = 1; d <= 3; d++)h.push(u(-d)), h.push(u(d)); for (h.push(u(0)); h.length > 0;) { var m = h.pop(), y = m.x, g = m.y, _ = m.fullyVisible; if (!_) { var v = m.aabb.intersects(s); if (0 === v) continue; _ = 2 === v } var x = m.aabb.distanceX(o), b = m.aabb.distanceY(o), w = Math.max(Math.abs(x), Math.abs(b)); if (m.zoom === p || w > 3 + (1 << p - m.zoom) - 2 && m.zoom >= l) c.push({ tileID: new t.OverscaledTileID(m.zoom === p ? f : m.zoom, m.wrap, m.zoom, y, g), distanceSq: t.sqrLen([o[0] - .5 - y, o[1] - .5 - g]) }); else for (var M = 0; M < 4; M++) { var S = (y << 1) + M % 2, E = (g << 1) + (M >> 1); h.push({ aabb: m.aabb.quadrant(M), zoom: m.zoom + 1, x: S, y: E, wrap: m.wrap, fullyVisible: _ }) } } return c.sort((function (t, e) { return t.distanceSq - e.distanceSq })).map((function (t) { return t.tileID })) }, wr.prototype.resize = function (t, e) { this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices() }, Mr.unmodified.get = function () { return this._unmodified }, wr.prototype.zoomScale = function (t) { return Math.pow(2, t) }, wr.prototype.scaleZoom = function (t) { return Math.log(t) / Math.LN2 }, wr.prototype.project = function (e) { var i = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude); return new t.Point(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(i) * this.worldSize) }, wr.prototype.unproject = function (e) { return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat() }, Mr.point.get = function () { return this.project(this.center) }, wr.prototype.setLocationAtPoint = function (e, i) { var r = this.pointCoordinate(i), n = this.pointCoordinate(this.centerPoint), a = this.locationCoordinate(e), o = new t.MercatorCoordinate(a.x - (r.x - n.x), a.y - (r.y - n.y)); this.center = this.coordinateLocation(o), this._renderWorldCopies && (this.center = this.center.wrap()) }, wr.prototype.locationPoint = function (t) { return this.coordinatePoint(this.locationCoordinate(t)) }, wr.prototype.pointLocation = function (t) { return this.coordinateLocation(this.pointCoordinate(t)) }, wr.prototype.locationCoordinate = function (e) { return t.MercatorCoordinate.fromLngLat(e) }, wr.prototype.coordinateLocation = function (t) { return t.toLngLat() }, wr.prototype.pointCoordinate = function (e) { var i = [e.x, e.y, 0, 1], r = [e.x, e.y, 1, 1]; t.transformMat4(i, i, this.pixelMatrixInverse), t.transformMat4(r, r, this.pixelMatrixInverse); var n = i[3], a = r[3], o = i[1] / n, s = r[1] / a, l = i[2] / n, u = r[2] / a, h = l === u ? 0 : (0 - l) / (u - l); return new t.MercatorCoordinate(t.number(i[0] / n, r[0] / a, h) / this.worldSize, t.number(o, s, h) / this.worldSize) }, wr.prototype.coordinatePoint = function (e) { var i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return t.transformMat4(i, i, this.pixelMatrix), new t.Point(i[0] / i[3], i[1] / i[3]) }, wr.prototype.getBounds = function () { return (new t.LngLatBounds).extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height))) }, wr.prototype.getMaxBounds = function () { return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null }, wr.prototype.setMaxBounds = function (t) { t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]) }, wr.prototype.calculatePosMatrix = function (e, i) { void 0 === i && (i = !1); var r = e.key, n = i ? this._alignedPosMatrixCache : this._posMatrixCache; if (n[r]) return n[r]; var a = e.canonical, o = this.worldSize / this.zoomScale(a.z), s = a.x + Math.pow(2, a.z) * e.wrap, l = t.identity(new Float64Array(16)); return t.translate(l, l, [s * o, a.y * o, 0]), t.scale(l, l, [o / t.EXTENT, o / t.EXTENT, 1]), t.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), n[r] = new Float32Array(l), n[r] }, wr.prototype.customLayerMatrix = function () { return this.mercatorMatrix.slice() }, wr.prototype._constrain = function () { if (this.center && this.width && this.height && !this._constraining) { this._constraining = !0; var e, i, r, n, a = -90, o = 90, s = -180, l = 180, u = this.size, h = this._unmodified; if (this.latRange) { var c = this.latRange; a = t.mercatorYfromLat(c[1]) * this.worldSize, e = (o = t.mercatorYfromLat(c[0]) * this.worldSize) - a < u.y ? u.y / (o - a) : 0 } if (this.lngRange) { var p = this.lngRange; s = t.mercatorXfromLng(p[0]) * this.worldSize, i = (l = t.mercatorXfromLng(p[1]) * this.worldSize) - s < u.x ? u.x / (l - s) : 0 } var f = this.point, d = Math.max(i || 0, e || 0); if (d) return this.center = this.unproject(new t.Point(i ? (l + s) / 2 : f.x, e ? (o + a) / 2 : f.y)), this.zoom += this.scaleZoom(d), this._unmodified = h, void (this._constraining = !1); if (this.latRange) { var m = f.y, y = u.y / 2; m - y < a && (n = a + y), m + y > o && (n = o - y) } if (this.lngRange) { var g = f.x, _ = u.x / 2; g - _ < s && (r = s + _), g + _ > l && (r = l - _) } void 0 === r && void 0 === n || (this.center = this.unproject(new t.Point(void 0 !== r ? r : f.x, void 0 !== n ? n : f.y))), this._unmodified = h, this._constraining = !1 } }, wr.prototype._calcMatrices = function () { if (this.height) { var e = this.centerOffset; this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height; var i = Math.PI / 2 + this._pitch, r = this._fov * (.5 + e.y / this.height), n = Math.sin(r) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i - r, .01, Math.PI - .01)), a = this.point, o = a.x, s = a.y, l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * n + this.cameraToCenterDistance), u = this.height / 50, h = new Float64Array(16); t.perspective(h, this._fov, this.width / this.height, u, l), h[8] = 2 * -e.x / this.width, h[9] = 2 * e.y / this.height, t.scale(h, h, [1, -1, 1]), t.translate(h, h, [0, 0, -this.cameraToCenterDistance]), t.rotateX(h, h, this._pitch), t.rotateZ(h, h, this.angle), t.translate(h, h, [-o, -s, 0]), this.mercatorMatrix = t.scale([], h, [this.worldSize, this.worldSize, this.worldSize]), t.scale(h, h, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = h, this.invProjMatrix = t.invert([], this.projMatrix); var c = this.width % 2 / 2, p = this.height % 2 / 2, f = Math.cos(this.angle), d = Math.sin(this.angle), m = o - Math.round(o) + f * c + d * p, y = s - Math.round(s) + f * p + d * c, g = new Float64Array(h); if (t.translate(g, g, [m > .5 ? m - 1 : m, y > .5 ? y - 1 : y, 0]), this.alignedProjMatrix = g, h = t.create(), t.scale(h, h, [this.width / 2, -this.height / 2, 1]), t.translate(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = t.create(), t.scale(h, h, [1, -1, 1]), t.translate(h, h, [-1, -1, 0]), t.scale(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(h = t.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix"); this.pixelMatrixInverse = h, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} } }, wr.prototype.maxPitchScaleFactor = function () { if (!this.pixelMatrixInverse) return 1; var e = this.pointCoordinate(new t.Point(0, 0)), i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return t.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance }, wr.prototype.getCameraPoint = function () { var e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new t.Point(0, e)) }, wr.prototype.getCameraQueryGeometry = function (e) { var i = this.getCameraPoint(); if (1 === e.length) return [e[0], i]; for (var r = i.x, n = i.y, a = i.x, o = i.y, s = 0, l = e; s < l.length; s += 1) { var u = l[s]; r = Math.min(r, u.x), n = Math.min(n, u.y), a = Math.max(a, u.x), o = Math.max(o, u.y) } return [new t.Point(r, n), new t.Point(a, n), new t.Point(a, o), new t.Point(r, o), new t.Point(r, n)] }, Object.defineProperties(wr.prototype, Mr); var Sr = function (e) { var i, r, n, a; this._hashName = e && encodeURIComponent(e), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i = this._updateHashUnthrottled.bind(this), r = !1, n = null, a = function () { n = null, r && (i(), n = setTimeout(a, 300), r = !1) }, function () { return r = !0, n || a(), n }) }; Sr.prototype.addTo = function (e) { return this._map = e, t.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this }, Sr.prototype.remove = function () { return t.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this }, Sr.prototype.getHashString = function (e) { var i = this._map.getCenter(), r = Math.round(100 * this._map.getZoom()) / 100, n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), a = Math.pow(10, n), o = Math.round(i.lng * a) / a, s = Math.round(i.lat * a) / a, l = this._map.getBearing(), u = this._map.getPitch(), h = ""; if (h += e ? "/" + o + "/" + s + "/" + r : r + "/" + s + "/" + o, (l || u) && (h += "/" + Math.round(10 * l) / 10), u && (h += "/" + Math.round(u)), this._hashName) { var c = this._hashName, p = !1, f = t.window.location.hash.slice(1).split("&").map((function (t) { var e = t.split("=")[0]; return e === c ? (p = !0, e + "=" + h) : t })).filter((function (t) { return t })); return p || f.push(c + "=" + h), "#" + f.join("&") } return "#" + h }, Sr.prototype._getCurrentHash = function () { var e, i = this, r = t.window.location.hash.replace("#", ""); return this._hashName ? (r.split("&").map((function (t) { return t.split("=") })).forEach((function (t) { t[0] === i._hashName && (e = t) })), (e && e[1] || "").split("/")) : r.split("/") }, Sr.prototype._onHashChange = function () { var t = this._getCurrentHash(); if (t.length >= 3 && !t.some((function (t) { return isNaN(t) }))) { var e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing(); return this._map.jumpTo({ center: [+t[2], +t[1]], zoom: +t[0], bearing: e, pitch: +(t[4] || 0) }), !0 } return !1 }, Sr.prototype._updateHashUnthrottled = function () { var e = t.window.location.href.replace(/(#.+)?$/, this.getHashString()); try { t.window.history.replaceState(t.window.history.state, null, e) } catch (t) { } }; var Er = { linearity: .3, easing: t.bezier(0, 0, .3, 1) }, Ir = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Er), Tr = t.extend({ deceleration: 20, maxSpeed: 1400 }, Er), Ar = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Er), Pr = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Er), Cr = function (t) { this._map = t, this.clear() }; function zr(t, e) { (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing) } function kr(e, i, r) { var n = r.maxSpeed, a = r.linearity, o = r.deceleration, s = t.clamp(e * a / (i / 1e3), -n, n), l = Math.abs(s) / (o * a); return { easing: r.easing, duration: 1e3 * l, amount: s * (l / 2) } } Cr.prototype.clear = function () { this._inertiaBuffer = [] }, Cr.prototype.record = function (e) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.browser.now(), settings: e }) }, Cr.prototype._drainInertiaBuffer = function () { for (var e = this._inertiaBuffer, i = t.browser.now(); e.length > 0 && i - e[0].time > 160;)e.shift() }, Cr.prototype._onMoveEnd = function (e) { if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) { for (var i = { zoom: 0, bearing: 0, pitch: 0, pan: new t.Point(0, 0), pinchAround: void 0, around: void 0 }, r = 0, n = this._inertiaBuffer; r < n.length; r += 1) { var a = n[r].settings; i.zoom += a.zoomDelta || 0, i.bearing += a.bearingDelta || 0, i.pitch += a.pitchDelta || 0, a.panDelta && i.pan._add(a.panDelta), a.around && (i.around = a.around), a.pinchAround && (i.pinchAround = a.pinchAround) } var o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s = {}; if (i.pan.mag()) { var l = kr(i.pan.mag(), o, t.extend({}, Ir, e || {})); s.offset = i.pan.mult(l.amount / i.pan.mag()), s.center = this._map.transform.center, zr(s, l) } if (i.zoom) { var u = kr(i.zoom, o, Tr); s.zoom = this._map.transform.zoom + u.amount, zr(s, u) } if (i.bearing) { var h = kr(i.bearing, o, Ar); s.bearing = this._map.transform.bearing + t.clamp(h.amount, -179, 179), zr(s, h) } if (i.pitch) { var c = kr(i.pitch, o, Pr); s.pitch = this._map.transform.pitch + c.amount, zr(s, c) } if (s.zoom || s.bearing) { var p = void 0 === i.pinchAround ? i.around : i.pinchAround; s.around = p ? this._map.unproject(p) : this._map.getCenter() } return this.clear(), t.extend(s, { noMoveStart: !0 }) } }; var Lr = function (e) { function r(r, n, a, o) { void 0 === o && (o = {}); var s = i.mousePos(n.getCanvasContainer(), a), l = n.unproject(s); e.call(this, r, t.extend({ point: s, lngLat: l, originalEvent: a }, o)), this._defaultPrevented = !1, this.target = n } e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r; var n = { defaultPrevented: { configurable: !0 } }; return r.prototype.preventDefault = function () { this._defaultPrevented = !0 }, n.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(r.prototype, n), r }(t.Event), Dr = function (e) { function r(r, n, a) { var o = "touchend" === r ? a.changedTouches : a.touches, s = i.touchPos(n.getCanvasContainer(), o), l = s.map((function (t) { return n.unproject(t) })), u = s.reduce((function (t, e, i, r) { return t.add(e.div(r.length)) }), new t.Point(0, 0)), h = n.unproject(u); e.call(this, r, { points: s, point: u, lngLats: l, lngLat: h, originalEvent: a }), this._defaultPrevented = !1 } e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r; var n = { defaultPrevented: { configurable: !0 } }; return r.prototype.preventDefault = function () { this._defaultPrevented = !0 }, n.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(r.prototype, n), r }(t.Event), Rr = function (t) { function e(e, i, r) { t.call(this, e, { originalEvent: r }), this._defaultPrevented = !1 } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var i = { defaultPrevented: { configurable: !0 } }; return e.prototype.preventDefault = function () { this._defaultPrevented = !0 }, i.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(e.prototype, i), e }(t.Event), Br = function (t, e) { this._map = t, this._clickTolerance = e.clickTolerance }; Br.prototype.reset = function () { delete this._mousedownPos }, Br.prototype.wheel = function (t) { return this._firePreventable(new Rr(t.type, this._map, t)) }, Br.prototype.mousedown = function (t, e) { return this._mousedownPos = e, this._firePreventable(new Lr(t.type, this._map, t)) }, Br.prototype.mouseup = function (t) { this._map.fire(new Lr(t.type, this._map, t)) }, Br.prototype.click = function (t, e) { this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new Lr(t.type, this._map, t)) }, Br.prototype.dblclick = function (t) { return this._firePreventable(new Lr(t.type, this._map, t)) }, Br.prototype.mouseover = function (t) { this._map.fire(new Lr(t.type, this._map, t)) }, Br.prototype.mouseout = function (t) { this._map.fire(new Lr(t.type, this._map, t)) }, Br.prototype.touchstart = function (t) { return this._firePreventable(new Dr(t.type, this._map, t)) }, Br.prototype.touchmove = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, Br.prototype.touchend = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, Br.prototype.touchcancel = function (t) { this._map.fire(new Dr(t.type, this._map, t)) }, Br.prototype._firePreventable = function (t) { if (this._map.fire(t), t.defaultPrevented) return {} }, Br.prototype.isEnabled = function () { return !0 }, Br.prototype.isActive = function () { return !1 }, Br.prototype.enable = function () { }, Br.prototype.disable = function () { }; var Or = function (t) { this._map = t }; Or.prototype.reset = function () { this._delayContextMenu = !1, delete this._contextMenuEvent }, Or.prototype.mousemove = function (t) { this._map.fire(new Lr(t.type, this._map, t)) }, Or.prototype.mousedown = function () { this._delayContextMenu = !0 }, Or.prototype.mouseup = function () { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Lr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent) }, Or.prototype.contextmenu = function (t) { this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Lr(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault() }, Or.prototype.isEnabled = function () { return !0 }, Or.prototype.isActive = function () { return !1 }, Or.prototype.enable = function () { }, Or.prototype.disable = function () { }; var Fr = function (t, e) { this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1 }; function Ur(t, e) { for (var i = {}, r = 0; r < t.length; r++)i[t[r].identifier] = e[r]; return i } Fr.prototype.isEnabled = function () { return !!this._enabled }, Fr.prototype.isActive = function () { return !!this._active }, Fr.prototype.enable = function () { this.isEnabled() || (this._enabled = !0) }, Fr.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, Fr.prototype.mousedown = function (t, e) { this.isEnabled() && t.shiftKey && 0 === t.button && (i.disableDrag(), this._startPos = this._lastPos = e, this._active = !0) }, Fr.prototype.mousemoveWindow = function (t, e) { if (this._active) { var r = e; if (!(this._lastPos.equals(r) || !this._box && r.dist(this._startPos) < this._clickTolerance)) { var n = this._startPos; this._lastPos = r, this._box || (this._box = i.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t)); var a = Math.min(n.x, r.x), o = Math.max(n.x, r.x), s = Math.min(n.y, r.y), l = Math.max(n.y, r.y); i.setTransform(this._box, "translate(" + a + "px," + s + "px)"), this._box.style.width = o - a + "px", this._box.style.height = l - s + "px" } } }, Fr.prototype.mouseupWindow = function (e, r) { var n = this; if (this._active && 0 === e.button) { var a = this._startPos, o = r; if (this.reset(), i.suppressClick(), a.x !== o.x || a.y !== o.y) return this._map.fire(new t.Event("boxzoomend", { originalEvent: e })), { cameraAnimation: function (t) { return t.fitScreenCoordinates(a, o, n._map.getBearing(), { linear: !0 }) } }; this._fireEvent("boxzoomcancel", e) } }, Fr.prototype.keydown = function (t) { this._active && 27 === t.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t)) }, Fr.prototype.reset = function () { this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos }, Fr.prototype._fireEvent = function (e, i) { return this._map.fire(new t.Event(e, { originalEvent: i })) }; var Nr = function (t) { this.reset(), this.numTouches = t.numTouches }; Nr.prototype.reset = function () { delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1 }, Nr.prototype.touchstart = function (e, i, r) { (this.centroid || r.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), r.length === this.numTouches && (this.centroid = function (e) { for (var i = new t.Point(0, 0), r = 0, n = e; r < n.length; r += 1)i._add(n[r]); return i.div(e.length) }(i), this.touches = Ur(r, i))) }, Nr.prototype.touchmove = function (t, e, i) { if (!this.aborted && this.centroid) { var r = Ur(i, e); for (var n in this.touches) { var a = r[n]; (!a || a.dist(this.touches[n]) > 30) && (this.aborted = !0) } } }, Nr.prototype.touchend = function (t, e, i) { if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) { var r = !this.aborted && this.centroid; if (this.reset(), r) return r } }; var Vr = function (t) { this.singleTap = new Nr(t), this.numTaps = t.numTaps, this.reset() }; Vr.prototype.reset = function () { this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset() }, Vr.prototype.touchstart = function (t, e, i) { this.singleTap.touchstart(t, e, i) }, Vr.prototype.touchmove = function (t, e, i) { this.singleTap.touchmove(t, e, i) }, Vr.prototype.touchend = function (t, e, i) { var r = this.singleTap.touchend(t, e, i); if (r) { var n = t.timeStamp - this.lastTime < 500, a = !this.lastTap || this.lastTap.dist(r) < 30; if (n && a || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = r, this.count === this.numTaps) return this.reset(), r } }; var jr = function () { this._zoomIn = new Vr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vr({ numTouches: 2, numTaps: 1 }), this.reset() }; jr.prototype.reset = function () { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset() }, jr.prototype.touchstart = function (t, e, i) { this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i) }, jr.prototype.touchmove = function (t, e, i) { this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i) }, jr.prototype.touchend = function (t, e, i) { var r = this, n = this._zoomIn.touchend(t, e, i), a = this._zoomOut.touchend(t, e, i); return n ? (this._active = !0, t.preventDefault(), setTimeout((function () { return r.reset() }), 0), { cameraAnimation: function (e) { return e.easeTo({ duration: 300, zoom: e.getZoom() + 1, around: e.unproject(n) }, { originalEvent: t }) } }) : a ? (this._active = !0, t.preventDefault(), setTimeout((function () { return r.reset() }), 0), { cameraAnimation: function (e) { return e.easeTo({ duration: 300, zoom: e.getZoom() - 1, around: e.unproject(a) }, { originalEvent: t }) } }) : void 0 }, jr.prototype.touchcancel = function () { this.reset() }, jr.prototype.enable = function () { this._enabled = !0 }, jr.prototype.disable = function () { this._enabled = !1, this.reset() }, jr.prototype.isEnabled = function () { return this._enabled }, jr.prototype.isActive = function () { return this._active }; var qr = { 0: 1, 2: 2 }, Gr = function (t) { this.reset(), this._clickTolerance = t.clickTolerance || 1 }; Gr.prototype.reset = function () { this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton }, Gr.prototype._correctButton = function (t, e) { return !1 }, Gr.prototype._move = function (t, e) { return {} }, Gr.prototype.mousedown = function (t, e) { if (!this._lastPoint) { var r = i.mouseButton(t); this._correctButton(t, r) && (this._lastPoint = e, this._eventButton = r) } }, Gr.prototype.mousemoveWindow = function (t, e) { var i = this._lastPoint; if (i) if (t.preventDefault(), function (t, e) { var i = qr[e]; return void 0 === t.buttons || (t.buttons & i) !== i }(t, this._eventButton)) this.reset(); else if (this._moved || !(e.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(i, e) }, Gr.prototype.mouseupWindow = function (t) { this._lastPoint && i.mouseButton(t) === this._eventButton && (this._moved && i.suppressClick(), this.reset()) }, Gr.prototype.enable = function () { this._enabled = !0 }, Gr.prototype.disable = function () { this._enabled = !1, this.reset() }, Gr.prototype.isEnabled = function () { return this._enabled }, Gr.prototype.isActive = function () { return this._active }; var Zr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.mousedown = function (e, i) { t.prototype.mousedown.call(this, e, i), this._lastPoint && (this._active = !0) }, e.prototype._correctButton = function (t, e) { return 0 === e && !t.ctrlKey }, e.prototype._move = function (t, e) { return { around: e, panDelta: e.sub(t) } }, e }(Gr), Xr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) { return 0 === e && t.ctrlKey || 2 === e }, e.prototype._move = function (t, e) { var i = .8 * (e.x - t.x); if (i) return this._active = !0, { bearingDelta: i } }, e.prototype.contextmenu = function (t) { t.preventDefault() }, e }(Gr), Wr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) { return 0 === e && t.ctrlKey || 2 === e }, e.prototype._move = function (t, e) { var i = -.5 * (e.y - t.y); if (i) return this._active = !0, { pitchDelta: i } }, e.prototype.contextmenu = function (t) { t.preventDefault() }, e }(Gr), Kr = function (t) { this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset() }; Kr.prototype.reset = function () { this._active = !1, this._touches = {}, this._sum = new t.Point(0, 0) }, Kr.prototype.touchstart = function (t, e, i) { return this._calculateTransform(t, e, i) }, Kr.prototype.touchmove = function (t, e, i) { if (this._active && !(i.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, i) }, Kr.prototype.touchend = function (t, e, i) { this._calculateTransform(t, e, i), this._active && i.length < this._minTouches && this.reset() }, Kr.prototype.touchcancel = function () { this.reset() }, Kr.prototype._calculateTransform = function (e, i, r) { r.length > 0 && (this._active = !0); var n = Ur(r, i), a = new t.Point(0, 0), o = new t.Point(0, 0), s = 0; for (var l in n) { var u = n[l], h = this._touches[l]; h && (a._add(u), o._add(u.sub(h)), s++, n[l] = u) } if (this._touches = n, !(s < this._minTouches) && o.mag()) { var c = o.div(s); if (this._sum._add(c), !(this._sum.mag() < this._clickTolerance)) return { around: a.div(s), panDelta: c } } }, Kr.prototype.enable = function () { this._enabled = !0 }, Kr.prototype.disable = function () { this._enabled = !1, this.reset() }, Kr.prototype.isEnabled = function () { return this._enabled }, Kr.prototype.isActive = function () { return this._active }; var Hr = function () { this.reset() }; function $r(t, e, i) { for (var r = 0; r < t.length; r++)if (t[r].identifier === i) return e[r] } function Jr(t, e) { return Math.log(t / e) / Math.LN2 } Hr.prototype.reset = function () { this._active = !1, delete this._firstTwoTouches }, Hr.prototype._start = function (t) { }, Hr.prototype._move = function (t, e, i) { return {} }, Hr.prototype.touchstart = function (t, e, i) { this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([e[0], e[1]])) }, Hr.prototype.touchmove = function (t, e, i) { if (this._firstTwoTouches) { t.preventDefault(); var r = this._firstTwoTouches, n = r[1], a = $r(i, e, r[0]), o = $r(i, e, n); if (a && o) { var s = this._aroundCenter ? null : a.add(o).div(2); return this._move([a, o], s, t) } } }, Hr.prototype.touchend = function (t, e, r) { if (this._firstTwoTouches) { var n = this._firstTwoTouches, a = n[1], o = $r(r, e, n[0]), s = $r(r, e, a); o && s || (this._active && i.suppressClick(), this.reset()) } }, Hr.prototype.touchcancel = function () { this.reset() }, Hr.prototype.enable = function (t) { this._enabled = !0, this._aroundCenter = !!t && "center" === t.around }, Hr.prototype.disable = function () { this._enabled = !1, this.reset() }, Hr.prototype.isEnabled = function () { return this._enabled }, Hr.prototype.isActive = function () { return this._active }; var Yr = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), delete this._distance, delete this._startDistance }, e.prototype._start = function (t) { this._startDistance = this._distance = t[0].dist(t[1]) }, e.prototype._move = function (t, e) { var i = this._distance; if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Jr(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Jr(this._distance, i), pinchAround: e } }, e }(Hr); function Qr(t, e) { return 180 * t.angleWith(e) / Math.PI } var tn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector }, e.prototype._start = function (t) { this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]) }, e.prototype._move = function (t, e) { var i = this._vector; if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Qr(this._vector, i), pinchAround: e } }, e.prototype._isBelowThreshold = function (t) { this._minDiameter = Math.min(this._minDiameter, t.mag()); var e = 25 / (Math.PI * this._minDiameter) * 360, i = Qr(t, this._startVector); return Math.abs(i) < e }, e }(Hr); function en(t) { return Math.abs(t.y) > Math.abs(t.x) } var rn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () { t.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints }, e.prototype._start = function (t) { this._lastPoints = t, en(t[0].sub(t[1])) && (this._valid = !1) }, e.prototype._move = function (t, e, i) { var r = t[0].sub(this._lastPoints[0]), n = t[1].sub(this._lastPoints[1]); if (this._valid = this.gestureBeginsVertically(r, n, i.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, { pitchDelta: (r.y + n.y) / 2 * -.5 } }, e.prototype.gestureBeginsVertically = function (t, e, i) { if (void 0 !== this._valid) return this._valid; var r = t.mag() >= 2, n = e.mag() >= 2; if (r || n) { if (!r || !n) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0; var a = t.y > 0 == e.y > 0; return en(t) && en(e) && a } }, e }(Hr), nn = { panStep: 100, bearingStep: 15, pitchStep: 10 }, an = function () { var t = nn; this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1 }; function on(t) { return t * (2 - t) } an.prototype.reset = function () { this._active = !1 }, an.prototype.keydown = function (t) { var e = this; if (!(t.altKey || t.ctrlKey || t.metaKey)) { var i = 0, r = 0, n = 0, a = 0, o = 0; switch (t.keyCode) { case 61: case 107: case 171: case 187: i = 1; break; case 189: case 109: case 173: i = -1; break; case 37: t.shiftKey ? r = -1 : (t.preventDefault(), a = -1); break; case 39: t.shiftKey ? r = 1 : (t.preventDefault(), a = 1); break; case 38: t.shiftKey ? n = 1 : (t.preventDefault(), o = -1); break; case 40: t.shiftKey ? n = -1 : (t.preventDefault(), o = 1); break; default: return }return this._rotationDisabled && (r = 0, n = 0), { cameraAnimation: function (s) { var l = s.getZoom(); s.easeTo({ duration: 300, easeId: "keyboardHandler", easing: on, zoom: i ? Math.round(l) + i * (t.shiftKey ? 2 : 1) : l, bearing: s.getBearing() + r * e._bearingStep, pitch: s.getPitch() + n * e._pitchStep, offset: [-a * e._panStep, -o * e._panStep], center: s.getCenter() }, { originalEvent: t }) } } } }, an.prototype.enable = function () { this._enabled = !0 }, an.prototype.disable = function () { this._enabled = !1, this.reset() }, an.prototype.isEnabled = function () { return this._enabled }, an.prototype.isActive = function () { return this._active }, an.prototype.disableRotation = function () { this._rotationDisabled = !0 }, an.prototype.enableRotation = function () { this._rotationDisabled = !1 }; var sn = function (e, i) { this._map = e, this._el = e.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this) }; sn.prototype.setZoomRate = function (t) { this._defaultZoomRate = t }, sn.prototype.setWheelZoomRate = function (t) { this._wheelZoomRate = t }, sn.prototype.isEnabled = function () { return !!this._enabled }, sn.prototype.isActive = function () { return !!this._active || void 0 !== this._finishTimeout }, sn.prototype.isZooming = function () { return !!this._zooming }, sn.prototype.enable = function (t) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around) }, sn.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, sn.prototype.wheel = function (e) { if (this.isEnabled()) { var i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY, r = t.browser.now(), n = r - (this._lastWheelEventTime || 0); this._lastWheelEventTime = r, 0 !== i && i % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : n > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(n * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault() } }, sn.prototype._onTimeout = function (t) { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t) }, sn.prototype._start = function (e) { if (this._delta) { this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); var r = i.mousePos(this._el, e); this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(r)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame()) } }, sn.prototype.renderFrame = function () { var e = this; if (this._frameId && (this._frameId = null, this.isActive())) { var i = this._map.transform; if (0 !== this._delta) { var r = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, n = 2 / (1 + Math.exp(-Math.abs(this._delta * r))); this._delta < 0 && 0 !== n && (n = 1 / n); var a = "number" == typeof this._targetZoom ? i.zoomScale(this._targetZoom) : i.scale; this._targetZoom = Math.min(i.maxZoom, Math.max(i.minZoom, i.scaleZoom(a * n))), "wheel" === this._type && (this._startZoom = i.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0 } var o, s = "number" == typeof this._targetZoom ? this._targetZoom : i.zoom, l = this._startZoom, u = this._easing, h = !1; if ("wheel" === this._type && l && u) { var c = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), p = u(c); o = t.number(l, s, p), c < 1 ? this._frameId || (this._frameId = !0) : h = !0 } else o = s, h = !0; return this._active = !0, h && (this._active = !1, this._finishTimeout = setTimeout((function () { e._zooming = !1, e._handler._triggerRenderFrame(), delete e._targetZoom, delete e._finishTimeout }), 200)), { noInertia: !0, needsRenderFrame: !h, zoomDelta: o - i.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent } } }, sn.prototype._smoothOutEasing = function (e) { var i = t.ease; if (this._prevEase) { var r = this._prevEase, n = (t.browser.now() - r.start) / r.duration, a = r.easing(n + .01) - r.easing(n), o = .27 / Math.sqrt(a * a + 1e-4) * .01, s = Math.sqrt(.0729 - o * o); i = t.bezier(o, s, .25, 1) } return this._prevEase = { start: t.browser.now(), duration: e, easing: i }, i }, sn.prototype.reset = function () { this._active = !1 }; var ln = function (t, e) { this._clickZoom = t, this._tapZoom = e }; ln.prototype.enable = function () { this._clickZoom.enable(), this._tapZoom.enable() }, ln.prototype.disable = function () { this._clickZoom.disable(), this._tapZoom.disable() }, ln.prototype.isEnabled = function () { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() }, ln.prototype.isActive = function () { return this._clickZoom.isActive() || this._tapZoom.isActive() }; var un = function () { this.reset() }; un.prototype.reset = function () { this._active = !1 }, un.prototype.dblclick = function (t, e) { return t.preventDefault(), { cameraAnimation: function (i) { i.easeTo({ duration: 300, zoom: i.getZoom() + (t.shiftKey ? -1 : 1), around: i.unproject(e) }, { originalEvent: t }) } } }, un.prototype.enable = function () { this._enabled = !0 }, un.prototype.disable = function () { this._enabled = !1, this.reset() }, un.prototype.isEnabled = function () { return this._enabled }, un.prototype.isActive = function () { return this._active }; var hn = function () { this._tap = new Vr({ numTouches: 1, numTaps: 1 }), this.reset() }; hn.prototype.reset = function () { this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset() }, hn.prototype.touchstart = function (t, e, i) { this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i)) }, hn.prototype.touchmove = function (t, e, i) { if (this._tapTime) { if (this._swipePoint) { if (i[0].identifier !== this._swipeTouch) return; var r = e[0], n = r.y - this._swipePoint.y; return this._swipePoint = r, t.preventDefault(), this._active = !0, { zoomDelta: n / 128 } } } else this._tap.touchmove(t, e, i) }, hn.prototype.touchend = function (t, e, i) { this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp) }, hn.prototype.touchcancel = function () { this.reset() }, hn.prototype.enable = function () { this._enabled = !0 }, hn.prototype.disable = function () { this._enabled = !1, this.reset() }, hn.prototype.isEnabled = function () { return this._enabled }, hn.prototype.isActive = function () { return this._active }; var cn = function (t, e, i) { this._el = t, this._mousePan = e, this._touchPan = i }; cn.prototype.enable = function (t) { this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan") }, cn.prototype.disable = function () { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan") }, cn.prototype.isEnabled = function () { return this._mousePan.isEnabled() && this._touchPan.isEnabled() }, cn.prototype.isActive = function () { return this._mousePan.isActive() || this._touchPan.isActive() }; var pn = function (t, e, i) { this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = i }; pn.prototype.enable = function () { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable() }, pn.prototype.disable = function () { this._mouseRotate.disable(), this._mousePitch.disable() }, pn.prototype.isEnabled = function () { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) }, pn.prototype.isActive = function () { return this._mouseRotate.isActive() || this._mousePitch.isActive() }; var fn = function (t, e, i, r) { this._el = t, this._touchZoom = e, this._touchRotate = i, this._tapDragZoom = r, this._rotationDisabled = !1, this._enabled = !0 }; fn.prototype.enable = function (t) { this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate") }, fn.prototype.disable = function () { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate") }, fn.prototype.isEnabled = function () { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() }, fn.prototype.isActive = function () { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() }, fn.prototype.disableRotation = function () { this._rotationDisabled = !0, this._touchRotate.disable() }, fn.prototype.enableRotation = function () { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable() }; var dn = function (t) { return t.zoom || t.drag || t.pitch || t.rotate }, mn = function (t) { function e() { t.apply(this, arguments) } return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e }(t.Event); function yn(t) { return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta } var gn = function (e, r) { this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Cr(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r), t.bindAll(["handleEvent", "handleWindowEvent"], this); var n = this._el; this._listeners = [[n, "touchstart", { passive: !0 }], [n, "touchmove", { passive: !1 }], [n, "touchend", void 0], [n, "touchcancel", void 0], [n, "mousedown", void 0], [n, "mousemove", void 0], [n, "mouseup", void 0], [t.window.document, "mousemove", { capture: !0 }], [t.window.document, "mouseup", void 0], [n, "mouseover", void 0], [n, "mouseout", void 0], [n, "dblclick", void 0], [n, "click", void 0], [n, "keydown", { capture: !1 }], [n, "keyup", void 0], [n, "wheel", { passive: !1 }], [n, "contextmenu", void 0], [t.window, "blur", void 0]]; for (var a = 0, o = this._listeners; a < o.length; a += 1) { var s = o[a], l = s[0]; i.addEventListener(l, s[1], l === t.window.document ? this.handleWindowEvent : this.handleEvent, s[2]) } }; gn.prototype.destroy = function () { for (var e = 0, r = this._listeners; e < r.length; e += 1) { var n = r[e], a = n[0]; i.removeEventListener(a, n[1], a === t.window.document ? this.handleWindowEvent : this.handleEvent, n[2]) } }, gn.prototype._addDefaultHandlers = function (t) { var e = this._map, i = e.getCanvasContainer(); this._add("mapEvent", new Br(e, t)); var r = e.boxZoom = new Fr(e, t); this._add("boxZoom", r); var n = new jr, a = new un; e.doubleClickZoom = new ln(a, n), this._add("tapZoom", n), this._add("clickZoom", a); var o = new hn; this._add("tapDragZoom", o); var s = e.touchPitch = new rn; this._add("touchPitch", s); var l = new Xr(t), u = new Wr(t); e.dragRotate = new pn(t, l, u), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", u, ["mouseRotate"]); var h = new Zr(t), c = new Kr(t); e.dragPan = new cn(i, h, c), this._add("mousePan", h), this._add("touchPan", c, ["touchZoom", "touchRotate"]); var p = new tn, f = new Yr; e.touchZoomRotate = new fn(i, f, p, o), this._add("touchRotate", p, ["touchPan", "touchZoom"]), this._add("touchZoom", f, ["touchPan", "touchRotate"]); var d = e.scrollZoom = new sn(e, this); this._add("scrollZoom", d, ["mousePan"]); var m = e.keyboard = new an; this._add("keyboard", m), this._add("blockableMapEvent", new Or(e)); for (var y = 0, g = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; y < g.length; y += 1) { var _ = g[y]; t.interactive && t[_] && e[_].enable(t[_]) } }, gn.prototype._add = function (t, e, i) { this._handlers.push({ handlerName: t, handler: e, allowed: i }), this._handlersById[t] = e }, gn.prototype.stop = function (t) { if (!this._updatingCamera) { for (var e = 0, i = this._handlers; e < i.length; e += 1)i[e].handler.reset(); this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [] } }, gn.prototype.isActive = function () { for (var t = 0, e = this._handlers; t < e.length; t += 1)if (e[t].handler.isActive()) return !0; return !1 }, gn.prototype.isZooming = function () { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() }, gn.prototype.isRotating = function () { return !!this._eventsInProgress.rotate }, gn.prototype.isMoving = function () { return Boolean(dn(this._eventsInProgress)) || this.isZooming() }, gn.prototype._blockedByActive = function (t, e, i) { for (var r in t) if (r !== i && (!e || e.indexOf(r) < 0)) return !0; return !1 }, gn.prototype.handleWindowEvent = function (t) { this.handleEvent(t, t.type + "Window") }, gn.prototype._getMapTouches = function (t) { for (var e = [], i = 0, r = t; i < r.length; i += 1) { var n = r[i]; this._el.contains(n.target) && e.push(n) } return e }, gn.prototype.handleEvent = function (t, e) { if ("blur" !== t.type) { this._updatingCamera = !0; for (var r = "renderFrame" === t.type ? void 0 : t, n = { needsRenderFrame: !1 }, a = {}, o = {}, s = t.touches ? this._getMapTouches(t.touches) : void 0, l = s ? i.touchPos(this._el, s) : i.mousePos(this._el, t), u = 0, h = this._handlers; u < h.length; u += 1) { var c = h[u], p = c.handlerName, f = c.handler, d = c.allowed; if (f.isEnabled()) { var m = void 0; this._blockedByActive(o, d, p) ? f.reset() : f[e || t.type] && (m = f[e || t.type](t, l, s), this.mergeHandlerResult(n, a, m, p, r), m && m.needsRenderFrame && this._triggerRenderFrame()), (m || f.isActive()) && (o[p] = f) } } var y = {}; for (var g in this._previousActiveHandlers) o[g] || (y[g] = r); this._previousActiveHandlers = o, (Object.keys(y).length || yn(n)) && (this._changes.push([n, a, y]), this._triggerRenderFrame()), (Object.keys(o).length || yn(n)) && this._map._stop(!0), this._updatingCamera = !1; var _ = n.cameraAnimation; _ && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], _(this._map)) } else this.stop(!0) }, gn.prototype.mergeHandlerResult = function (e, i, r, n, a) { if (r) { t.extend(e, r); var o = { handlerName: n, originalEvent: r.originalEvent || a }; void 0 !== r.zoomDelta && (i.zoom = o), void 0 !== r.panDelta && (i.drag = o), void 0 !== r.pitchDelta && (i.pitch = o), void 0 !== r.bearingDelta && (i.rotate = o) } }, gn.prototype._applyChanges = function () { for (var e = {}, i = {}, r = {}, n = 0, a = this._changes; n < a.length; n += 1) { var o = a[n], s = o[0], l = o[1], u = o[2]; s.panDelta && (e.panDelta = (e.panDelta || new t.Point(0, 0))._add(s.panDelta)), s.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (e.around = s.around), void 0 !== s.pinchAround && (e.pinchAround = s.pinchAround), s.noInertia && (e.noInertia = s.noInertia), t.extend(i, l), t.extend(r, u) } this._updateMapTransform(e, i, r), this._changes = [] }, gn.prototype._updateMapTransform = function (t, e, i) { var r = this._map, n = r.transform; if (!yn(t)) return this._fireEvents(e, i, !0); var a = t.panDelta, o = t.zoomDelta, s = t.bearingDelta, l = t.pitchDelta, u = t.around, h = t.pinchAround; void 0 !== h && (u = h), r._stop(!0), u = u || r.transform.centerPoint; var c = n.pointLocation(a ? u.sub(a) : u); s && (n.bearing += s), l && (n.pitch += l), o && (n.zoom += o), n.setLocationAtPoint(c, u), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, i, !0) }, gn.prototype._fireEvents = function (e, i, r) { var n = this, a = dn(this._eventsInProgress), o = dn(e), s = {}; for (var l in e) this._eventsInProgress[l] || (s[l + "start"] = e[l].originalEvent), this._eventsInProgress[l] = e[l]; for (var u in !a && o && this._fireEvent("movestart", o.originalEvent), s) this._fireEvent(u, s[u]); for (var h in o && this._fireEvent("move", o.originalEvent), e) this._fireEvent(h, e[h].originalEvent); var c, p = {}; for (var f in this._eventsInProgress) { var d = this._eventsInProgress[f], m = d.handlerName, y = d.originalEvent; this._handlersById[m].isActive() || (delete this._eventsInProgress[f], p[f + "end"] = c = i[m] || y) } for (var g in p) this._fireEvent(g, p[g]); var _ = dn(this._eventsInProgress); if (r && (a || o) && !_) { this._updatingCamera = !0; var v = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), x = function (t) { return 0 !== t && -n._bearingSnap < t && t < n._bearingSnap }; v ? (x(v.bearing || this._map.getBearing()) && (v.bearing = 0), this._map.easeTo(v, { originalEvent: c })) : (this._map.fire(new t.Event("moveend", { originalEvent: c })), x(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1 } }, gn.prototype._fireEvent = function (e, i) { this._map.fire(new t.Event(e, i ? { originalEvent: i } : {})) }, gn.prototype._requestFrame = function () { var t = this; return this._map.triggerRepaint(), this._map._renderTaskQueue.add((function (e) { delete t._frameId, t.handleEvent(new mn("renderFrame", { timeStamp: e })), t._applyChanges() })) }, gn.prototype._triggerRenderFrame = function () { void 0 === this._frameId && (this._frameId = this._requestFrame()) }; var _n = function (e) { function i(i, r) { e.call(this), this._moving = !1, this._zooming = !1, this.transform = i, this._bearingSnap = r.bearingSnap, t.bindAll(["_renderFrameCallback"], this) } return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getCenter = function () { return new t.LngLat(this.transform.center.lng, this.transform.center.lat) }, i.prototype.setCenter = function (t, e) { return this.jumpTo({ center: t }, e) }, i.prototype.panBy = function (e, i, r) { return e = t.Point.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e }, i), r) }, i.prototype.panTo = function (e, i, r) { return this.easeTo(t.extend({ center: e }, i), r) }, i.prototype.getZoom = function () { return this.transform.zoom }, i.prototype.setZoom = function (t, e) { return this.jumpTo({ zoom: t }, e), this }, i.prototype.zoomTo = function (e, i, r) { return this.easeTo(t.extend({ zoom: e }, i), r) }, i.prototype.zoomIn = function (t, e) { return this.zoomTo(this.getZoom() + 1, t, e), this }, i.prototype.zoomOut = function (t, e) { return this.zoomTo(this.getZoom() - 1, t, e), this }, i.prototype.getBearing = function () { return this.transform.bearing }, i.prototype.setBearing = function (t, e) { return this.jumpTo({ bearing: t }, e), this }, i.prototype.getPadding = function () { return this.transform.padding }, i.prototype.setPadding = function (t, e) { return this.jumpTo({ padding: t }, e), this }, i.prototype.rotateTo = function (e, i, r) { return this.easeTo(t.extend({ bearing: e }, i), r) }, i.prototype.resetNorth = function (e, i) { return this.rotateTo(0, t.extend({ duration: 1e3 }, e), i), this }, i.prototype.resetNorthPitch = function (e, i) { return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e), i), this }, i.prototype.snapToNorth = function (t, e) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this }, i.prototype.getPitch = function () { return this.transform.pitch }, i.prototype.setPitch = function (t, e) { return this.jumpTo({ pitch: t }, e), this }, i.prototype.cameraForBounds = function (e, i) { e = t.LngLatBounds.convert(e); var r = i && i.bearing || 0; return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), r, i) }, i.prototype._cameraForBoxAndBearing = function (e, i, r, n) { var a = { top: 0, bottom: 0, right: 0, left: 0 }; if ("number" == typeof (n = t.extend({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, n)).padding) { var o = n.padding; n.padding = { top: o, bottom: o, right: o, left: o } } n.padding = t.extend(a, n.padding); var s = this.transform, l = s.padding, u = s.project(t.LngLat.convert(e)), h = s.project(t.LngLat.convert(i)), c = u.rotate(-r * Math.PI / 180), p = h.rotate(-r * Math.PI / 180), f = new t.Point(Math.max(c.x, p.x), Math.max(c.y, p.y)), d = new t.Point(Math.min(c.x, p.x), Math.min(c.y, p.y)), m = f.sub(d), y = (s.width - (l.left + l.right + n.padding.left + n.padding.right)) / m.x, g = (s.height - (l.top + l.bottom + n.padding.top + n.padding.bottom)) / m.y; if (!(g < 0 || y < 0)) { var _ = Math.min(s.scaleZoom(s.scale * Math.min(y, g)), n.maxZoom), v = "number" == typeof n.offset.x ? new t.Point(n.offset.x, n.offset.y) : t.Point.convert(n.offset), x = new t.Point((n.padding.left - n.padding.right) / 2, (n.padding.top - n.padding.bottom) / 2).rotate(r * Math.PI / 180), b = v.add(x).mult(s.scale / s.zoomScale(_)); return { center: s.unproject(u.add(h).div(2).sub(b)), zoom: _, bearing: r } } t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.") }, i.prototype.fitBounds = function (t, e, i) { return this._fitInternal(this.cameraForBounds(t, e), e, i) }, i.prototype.fitScreenCoordinates = function (e, i, r, n, a) { return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)), this.transform.pointLocation(t.Point.convert(i)), r, n), n, a) }, i.prototype._fitInternal = function (e, i, r) { return e ? (delete (i = t.extend(e, i)).padding, i.linear ? this.easeTo(i, r) : this.flyTo(i, r)) : this }, i.prototype.jumpTo = function (e, i) { this.stop(); var r = this.transform, n = !1, a = !1, o = !1; return "zoom" in e && r.zoom !== +e.zoom && (n = !0, r.zoom = +e.zoom), void 0 !== e.center && (r.center = t.LngLat.convert(e.center)), "bearing" in e && r.bearing !== +e.bearing && (a = !0, r.bearing = +e.bearing), "pitch" in e && r.pitch !== +e.pitch && (o = !0, r.pitch = +e.pitch), null == e.padding || r.isPaddingEqual(e.padding) || (r.padding = e.padding), this.fire(new t.Event("movestart", i)).fire(new t.Event("move", i)), n && this.fire(new t.Event("zoomstart", i)).fire(new t.Event("zoom", i)).fire(new t.Event("zoomend", i)), a && this.fire(new t.Event("rotatestart", i)).fire(new t.Event("rotate", i)).fire(new t.Event("rotateend", i)), o && this.fire(new t.Event("pitchstart", i)).fire(new t.Event("pitch", i)).fire(new t.Event("pitchend", i)), this.fire(new t.Event("moveend", i)) }, i.prototype.easeTo = function (e, i) { var r = this; this._stop(!1, e.easeId), (!1 === (e = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e)).animate || !e.essential && t.browser.prefersReducedMotion) && (e.duration = 0); var n = this.transform, a = this.getZoom(), o = this.getBearing(), s = this.getPitch(), l = this.getPadding(), u = "zoom" in e ? +e.zoom : a, h = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, c = "pitch" in e ? +e.pitch : s, p = "padding" in e ? e.padding : n.padding, f = t.Point.convert(e.offset), d = n.centerPoint.add(f), m = n.pointLocation(d), y = t.LngLat.convert(e.center || m); this._normalizeCenter(y); var g, _, v = n.project(m), x = n.project(y).sub(v), b = n.zoomScale(u - a); e.around && (g = t.LngLat.convert(e.around), _ = n.locationPoint(g)); var w = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching }; return this._zooming = this._zooming || u !== a, this._rotating = this._rotating || o !== h, this._pitching = this._pitching || c !== s, this._padding = !n.isPaddingEqual(p), this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, w), this._ease((function (e) { if (r._zooming && (n.zoom = t.number(a, u, e)), r._rotating && (n.bearing = t.number(o, h, e)), r._pitching && (n.pitch = t.number(s, c, e)), r._padding && (n.interpolatePadding(l, p, e), d = n.centerPoint.add(f)), g) n.setLocationAtPoint(g, _); else { var m = n.zoomScale(n.zoom - a), y = u > a ? Math.min(2, b) : Math.max(.5, b), w = Math.pow(y, 1 - e), M = n.unproject(v.add(x.mult(e * w)).mult(m)); n.setLocationAtPoint(n.renderWorldCopies ? M.wrap() : M, d) } r._fireMoveEvents(i) }), (function (t) { r._afterEase(i, t) }), e), this }, i.prototype._prepareEase = function (e, i, r) { void 0 === r && (r = {}), this._moving = !0, i || r.moving || this.fire(new t.Event("movestart", e)), this._zooming && !r.zooming && this.fire(new t.Event("zoomstart", e)), this._rotating && !r.rotating && this.fire(new t.Event("rotatestart", e)), this._pitching && !r.pitching && this.fire(new t.Event("pitchstart", e)) }, i.prototype._fireMoveEvents = function (e) { this.fire(new t.Event("move", e)), this._zooming && this.fire(new t.Event("zoom", e)), this._rotating && this.fire(new t.Event("rotate", e)), this._pitching && this.fire(new t.Event("pitch", e)) }, i.prototype._afterEase = function (e, i) { if (!this._easeId || !i || this._easeId !== i) { delete this._easeId; var r = this._zooming, n = this._rotating, a = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, r && this.fire(new t.Event("zoomend", e)), n && this.fire(new t.Event("rotateend", e)), a && this.fire(new t.Event("pitchend", e)), this.fire(new t.Event("moveend", e)) } }, i.prototype.flyTo = function (e, i) { var r = this; if (!e.essential && t.browser.prefersReducedMotion) { var n = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]); return this.jumpTo(n, i) } this.stop(), e = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e); var a = this.transform, o = this.getZoom(), s = this.getBearing(), l = this.getPitch(), u = this.getPadding(), h = "zoom" in e ? t.clamp(+e.zoom, a.minZoom, a.maxZoom) : o, c = "bearing" in e ? this._normalizeBearing(e.bearing, s) : s, p = "pitch" in e ? +e.pitch : l, f = "padding" in e ? e.padding : a.padding, d = a.zoomScale(h - o), m = t.Point.convert(e.offset), y = a.centerPoint.add(m), g = a.pointLocation(y), _ = t.LngLat.convert(e.center || g); this._normalizeCenter(_); var v = a.project(g), x = a.project(_).sub(v), b = e.curve, w = Math.max(a.width, a.height), M = w / d, S = x.mag(); if ("minZoom" in e) { var E = t.clamp(Math.min(e.minZoom, o, h), a.minZoom, a.maxZoom), I = w / a.zoomScale(E - o); b = Math.sqrt(I / S * 2) } var T = b * b; function A(t) { var e = (M * M - w * w + (t ? -1 : 1) * T * T * S * S) / (2 * (t ? M : w) * T * S); return Math.log(Math.sqrt(e * e + 1) - e) } function P(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function C(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } var z = A(0), k = function (t) { return C(z) / C(z + b * t) }, L = function (t) { return w * ((C(z) * (P(e = z + b * t) / C(e)) - P(z)) / T) / S; var e }, D = (A(1) - z) / b; if (Math.abs(S) < 1e-6 || !isFinite(D)) { if (Math.abs(w - M) < 1e-6) return this.easeTo(e, i); var R = M < w ? -1 : 1; D = Math.abs(Math.log(M / w)) / b, L = function () { return 0 }, k = function (t) { return Math.exp(R * b * t) } } return e.duration = "duration" in e ? +e.duration : 1e3 * D / ("screenSpeed" in e ? +e.screenSpeed / b : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== c, this._pitching = p !== l, this._padding = !a.isPaddingEqual(f), this._prepareEase(i, !1), this._ease((function (e) { var n = e * D, d = 1 / k(n); a.zoom = 1 === e ? h : o + a.scaleZoom(d), r._rotating && (a.bearing = t.number(s, c, e)), r._pitching && (a.pitch = t.number(l, p, e)), r._padding && (a.interpolatePadding(u, f, e), y = a.centerPoint.add(m)); var g = 1 === e ? _ : a.unproject(v.add(x.mult(L(n))).mult(d)); a.setLocationAtPoint(a.renderWorldCopies ? g.wrap() : g, y), r._fireMoveEvents(i) }), (function () { return r._afterEase(i) }), e), this }, i.prototype.isEasing = function () { return !!this._easeFrameId }, i.prototype.stop = function () { return this._stop() }, i.prototype._stop = function (t, e) { if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { var i = this._onEaseEnd; delete this._onEaseEnd, i.call(this, e) } if (!t) { var r = this.handlers; r && r.stop(!1) } return this }, i.prototype._ease = function (e, i, r) { !1 === r.animate || 0 === r.duration ? (e(1), i()) : (this._easeStart = t.browser.now(), this._easeOptions = r, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) }, i.prototype._renderFrameCallback = function () { var e = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() }, i.prototype._normalizeBearing = function (e, i) { e = t.wrap(e, -180, 180); var r = Math.abs(e - i); return Math.abs(e - 360 - i) < r && (e -= 360), Math.abs(e + 360 - i) < r && (e += 360), e }, i.prototype._normalizeCenter = function (t) { var e = this.transform; if (e.renderWorldCopies && !e.lngRange) { var i = t.lng - e.center.lng; t.lng += i > 180 ? -360 : i < -180 ? 360 : 0 } }, i }(t.Evented), vn = function (e) { void 0 === e && (e = {}), this.options = e, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this) }; vn.prototype.getDefaultPosition = function () { return "bottom-right" }, vn.prototype.onAdd = function (t) { var e = this.options && this.options.compact; return this._map = t, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container }, vn.prototype.onRemove = function () { i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0 }, vn.prototype._setElementTitle = function (t, e) { var i = this._map._getUIString("AttributionControl." + e); t.title = i, t.setAttribute("aria-label", i) }, vn.prototype._toggleAttribution = function () { this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true")) }, vn.prototype._updateEditLink = function () { var e = this._editLink; e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map")); var i = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }]; if (e) { var r = i.reduce((function (t, e, r) { return e.value && (t += e.key + "=" + e.value + (r < i.length - 1 ? "&" : "")), t }), "?"); e.href = t.config.FEEDBACK_URL + "/" + r + (this._map._hash ? this._map._hash.getHashString(!0) : ""), e.rel = "noopener nofollow", this._setElementTitle(e, "MapFeedback") } }, vn.prototype._updateData = function (t) { !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(), this._updateEditLink()) }, vn.prototype._updateAttributions = function () { if (this._map.style) { var t = []; if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map((function (t) { return "string" != typeof t ? "" : t }))) : "string" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) { var e = this._map.style.stylesheet; this.styleOwner = e.owner, this.styleId = e.id } var i = this._map.style.sourceCaches; for (var r in i) { var n = i[r]; if (n.used) { var a = n.getSource(); a.attribution && t.indexOf(a.attribution) < 0 && t.push(a.attribution) } } t.sort((function (t, e) { return t.length - e.length })); var o = (t = t.filter((function (e, i) { for (var r = i + 1; r < t.length; r++)if (t[r].indexOf(e) >= 0) return !1; return !0 }))).join(" | "); o !== this._attribHTML && (this._attribHTML = o, t.length ? (this._innerContainer.innerHTML = o, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null) } }, vn.prototype._updateCompact = function () { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show") }; var xn = function () { t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this) }; xn.prototype.onAdd = function (t) { this._map = t, this._container = i.create("div", "mapboxgl-ctrl"); var e = i.create("a", "mapboxgl-ctrl-logo"); return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://www.mapbox.com/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container }, xn.prototype.onRemove = function () { i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact) }, xn.prototype.getDefaultPosition = function () { return "bottom-left" }, xn.prototype._updateLogo = function (t) { t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none") }, xn.prototype._logoRequired = function () { if (this._map.style) { var t = this._map.style.sourceCaches; for (var e in t) if (t[e].getSource().mapbox_logo) return !0; return !1 } }, xn.prototype._updateCompact = function () { var t = this._container.children; if (t.length) { var e = t[0]; this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("mapboxgl-compact") : e.classList.remove("mapboxgl-compact") } }; var bn = function () { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 }; bn.prototype.add = function (t) { var e = ++this._id; return this._queue.push({ callback: t, id: e, cancelled: !1 }), e }, bn.prototype.remove = function (t) { for (var e = this._currentlyRunning, i = 0, r = e ? this._queue.concat(e) : this._queue; i < r.length; i += 1) { var n = r[i]; if (n.id === t) return void (n.cancelled = !0) } }, bn.prototype.run = function (t) { void 0 === t && (t = 0); var e = this._currentlyRunning = this._queue; this._queue = []; for (var i = 0, r = e; i < r.length; i += 1) { var n = r[i]; if (!n.cancelled && (n.callback(t), this._cleared)) break } this._cleared = !1, this._currentlyRunning = !1 }, bn.prototype.clear = function () { this._currentlyRunning && (this._cleared = !0), this._queue = [] }; var wn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Mn = t.window.HTMLImageElement, Sn = t.window.HTMLElement, En = t.window.ImageBitmap, In = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Tn = function (r) { function n(e) { var i = this; if (null != (e = t.extend({}, In, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (null != e.maxPitch && e.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60"); var n = new wr(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies); if (r.call(this, n, e), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new bn, this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wn, e.locale), this._clickTolerance = e.clickTolerance, this._requestManager = new t.RequestManager(e.transformRequest, e.accessToken), "string" == typeof e.container) { if (this._container = t.window.document.getElementById(e.container), !this._container) throw new Error("Container '" + e.container + "' not found.") } else { if (!(e.container instanceof Sn)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = e.container } if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL."); this.on("move", (function () { return i._update(!1) })), this.on("moveend", (function () { return i._update(!1) })), this.on("zoom", (function () { return i._update(!0) })), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1), t.window.addEventListener("resize", this._onWindowResize, !1), t.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new gn(this, e), this._hash = e.hash && new Sr("string" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, { localIdeographFontFamily: e.localIdeographFontFamily }), e.attributionControl && this.addControl(new vn({ customAttribution: e.customAttribution })), this.addControl(new xn, e.logoPosition), this.on("style.load", (function () { i.transform.unmodified && i.jumpTo(i.style.stylesheet) })), this.on("data", (function (e) { i._update("style" === e.dataType), i.fire(new t.Event(e.dataType + "data", e)) })), this.on("dataloading", (function (e) { i.fire(new t.Event(e.dataType + "dataloading", e)) })) } r && (n.__proto__ = r), (n.prototype = Object.create(r && r.prototype)).constructor = n; var a = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } }; return n.prototype._getMapId = function () { return this._mapId }, n.prototype.addControl = function (e, i) { if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); var r = e.onAdd(this); this._controls.push(e); var n = this._controlPositions[i]; return -1 !== i.indexOf("bottom") ? n.insertBefore(r, n.firstChild) : n.appendChild(r), this }, n.prototype.removeControl = function (e) { if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); var i = this._controls.indexOf(e); return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this }, n.prototype.hasControl = function (t) { return this._controls.indexOf(t) > -1 }, n.prototype.resize = function (e) { var i = this._containerDimensions(), r = i[0], n = i[1]; this._resizeCanvas(r, n), this.transform.resize(r, n), this.painter.resize(r, n); var a = !this._moving; return a && (this.stop(), this.fire(new t.Event("movestart", e)).fire(new t.Event("move", e))), this.fire(new t.Event("resize", e)), a && this.fire(new t.Event("moveend", e)), this }, n.prototype.getBounds = function () { return this.transform.getBounds() }, n.prototype.getMaxBounds = function () { return this.transform.getMaxBounds() }, n.prototype.setMaxBounds = function (e) { return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update() }, n.prototype.setMinZoom = function (t) { if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") }, n.prototype.getMinZoom = function () { return this.transform.minZoom }, n.prototype.setMaxZoom = function (t) { if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this; throw new Error("maxZoom must be greater than the current minZoom") }, n.prototype.getMaxZoom = function () { return this.transform.maxZoom }, n.prototype.setMinPitch = function (t) { if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") }, n.prototype.getMinPitch = function () { return this.transform.minPitch }, n.prototype.setMaxPitch = function (t) { if ((t = null == t ? 60 : t) > 60) throw new Error("maxPitch must be less than or equal to 60"); if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this; throw new Error("maxPitch must be greater than the current minPitch") }, n.prototype.getMaxPitch = function () { return this.transform.maxPitch }, n.prototype.getRenderWorldCopies = function () { return this.transform.renderWorldCopies }, n.prototype.setRenderWorldCopies = function (t) { return this.transform.renderWorldCopies = t, this._update() }, n.prototype.project = function (e) { return this.transform.locationPoint(t.LngLat.convert(e)) }, n.prototype.unproject = function (e) { return this.transform.pointLocation(t.Point.convert(e)) }, n.prototype.isMoving = function () { return this._moving || this.handlers.isMoving() }, n.prototype.isZooming = function () { return this._zooming || this.handlers.isZooming() }, n.prototype.isRotating = function () { return this._rotating || this.handlers.isRotating() }, n.prototype._createDelegatedListener = function (t, e, i) { var r, n = this; if ("mouseenter" === t || "mouseover" === t) { var a = !1; return { layer: e, listener: i, delegates: { mousemove: function (r) { var o = n.getLayer(e) ? n.queryRenderedFeatures(r.point, { layers: [e] }) : []; o.length ? a || (a = !0, i.call(n, new Lr(t, n, r.originalEvent, { features: o }))) : a = !1 }, mouseout: function () { a = !1 } } } } if ("mouseleave" === t || "mouseout" === t) { var o = !1; return { layer: e, listener: i, delegates: { mousemove: function (r) { (n.getLayer(e) ? n.queryRenderedFeatures(r.point, { layers: [e] }) : []).length ? o = !0 : o && (o = !1, i.call(n, new Lr(t, n, r.originalEvent))) }, mouseout: function (e) { o && (o = !1, i.call(n, new Lr(t, n, e.originalEvent))) } } } } return { layer: e, listener: i, delegates: (r = {}, r[t] = function (t) { var r = n.getLayer(e) ? n.queryRenderedFeatures(t.point, { layers: [e] }) : []; r.length && (t.features = r, i.call(n, t), delete t.features) }, r) } }, n.prototype.on = function (t, e, i) { if (void 0 === i) return r.prototype.on.call(this, t, e); var n = this._createDelegatedListener(t, e, i); for (var a in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(n), n.delegates) this.on(a, n.delegates[a]); return this }, n.prototype.once = function (t, e, i) { if (void 0 === i) return r.prototype.once.call(this, t, e); var n = this._createDelegatedListener(t, e, i); for (var a in n.delegates) this.once(a, n.delegates[a]); return this }, n.prototype.off = function (t, e, i) { var n = this; return void 0 === i ? r.prototype.off.call(this, t, e) : (this._delegatedListeners && this._delegatedListeners[t] && function (r) { for (var a = r[t], o = 0; o < a.length; o++) { var s = a[o]; if (s.layer === e && s.listener === i) { for (var l in s.delegates) n.off(l, s.delegates[l]); return a.splice(o, 1), n } } }(this._delegatedListeners), this) }, n.prototype.queryRenderedFeatures = function (e, i) { if (!this.style) return []; var r; if (void 0 !== i || void 0 === e || e instanceof t.Point || Array.isArray(e) || (i = e, e = void 0), i = i || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e[0]) r = [t.Point.convert(e)]; else { var n = t.Point.convert(e[0]), a = t.Point.convert(e[1]); r = [n, new t.Point(a.x, n.y), a, new t.Point(n.x, a.y), n] } return this.style.queryRenderedFeatures(r, i, this.transform) }, n.prototype.querySourceFeatures = function (t, e) { return this.style.querySourceFeatures(t, e) }, n.prototype.setStyle = function (e, i) { return !1 !== (i = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i)) }, n.prototype._getUIString = function (t) { var e = this._locale[t]; if (null == e) throw new Error("Missing UI string '" + t + "'"); return e }, n.prototype._updateStyle = function (t, e) { return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new qe(this, e || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this) }, n.prototype._lazyInitEmptyStyle = function () { this.style || (this.style = new qe(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()) }, n.prototype._diffStyle = function (e, i) { var r = this; if ("string" == typeof e) { var n = this._requestManager.normalizeStyleURL(e), a = this._requestManager.transformRequest(n, t.ResourceType.Style); t.getJSON(a, (function (e, n) { e ? r.fire(new t.ErrorEvent(e)) : n && r._updateDiff(n, i) })) } else "object" == typeof e && this._updateDiff(e, i) }, n.prototype._updateDiff = function (e, i) { try { this.style.setState(e) && this._update(!0) } catch (r) { t.warnOnce("Unable to perform style diff: " + (r.message || r.error || r) + ".  Rebuilding the style from scratch."), this._updateStyle(e, i) } }, n.prototype.getStyle = function () { if (this.style) return this.style.serialize() }, n.prototype.isStyleLoaded = function () { return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.") }, n.prototype.addSource = function (t, e) { return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0) }, n.prototype.isSourceLoaded = function (e) { var i = this.style && this.style.sourceCaches[e]; if (void 0 !== i) return i.loaded(); this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e + "'"))) }, n.prototype.areTilesLoaded = function () { var t = this.style && this.style.sourceCaches; for (var e in t) { var i = t[e]._tiles; for (var r in i) { var n = i[r]; if ("loaded" !== n.state && "errored" !== n.state) return !1 } } return !0 }, n.prototype.addSourceType = function (t, e, i) { return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, i) }, n.prototype.removeSource = function (t) { return this.style.removeSource(t), this._update(!0) }, n.prototype.getSource = function (t) { return this.style.getSource(t) }, n.prototype.addImage = function (e, i, r) { void 0 === r && (r = {}); var n = r.pixelRatio; void 0 === n && (n = 1); var a = r.sdf; void 0 === a && (a = !1); var o = r.stretchX, s = r.stretchY, l = r.content; if (this._lazyInitEmptyStyle(), i instanceof Mn || En && i instanceof En) { var u = t.browser.getImageData(i); this.style.addImage(e, { data: new t.RGBAImage({ width: u.width, height: u.height }, u.data), pixelRatio: n, stretchX: o, stretchY: s, content: l, sdf: a, version: 0 }) } else { if (void 0 === i.width || void 0 === i.height) return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); var h = i; this.style.addImage(e, { data: new t.RGBAImage({ width: i.width, height: i.height }, new Uint8Array(i.data)), pixelRatio: n, stretchX: o, stretchY: s, content: l, sdf: a, version: 0, userImage: h }), h.onAdd && h.onAdd(this, e) } }, n.prototype.updateImage = function (e, i) { var r = this.style.getImage(e); if (!r) return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); var n = i instanceof Mn || En && i instanceof En ? t.browser.getImageData(i) : i, a = n.width, o = n.height, s = n.data; return void 0 === a || void 0 === o ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a !== r.data.width || o !== r.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (r.data.replace(s, !(i instanceof Mn || En && i instanceof En)), void this.style.updateImage(e, r)) }, n.prototype.hasImage = function (e) { return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1) }, n.prototype.removeImage = function (t) { this.style.removeImage(t) }, n.prototype.loadImage = function (e, i) { t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), i) }, n.prototype.listImages = function () { return this.style.listImages() }, n.prototype.addLayer = function (t, e) { return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0) }, n.prototype.moveLayer = function (t, e) { return this.style.moveLayer(t, e), this._update(!0) }, n.prototype.removeLayer = function (t) { return this.style.removeLayer(t), this._update(!0) }, n.prototype.getLayer = function (t) { return this.style.getLayer(t) }, n.prototype.setLayerZoomRange = function (t, e, i) { return this.style.setLayerZoomRange(t, e, i), this._update(!0) }, n.prototype.setFilter = function (t, e, i) { return void 0 === i && (i = {}), this.style.setFilter(t, e, i), this._update(!0) }, n.prototype.getFilter = function (t) { return this.style.getFilter(t) }, n.prototype.setPaintProperty = function (t, e, i, r) { return void 0 === r && (r = {}), this.style.setPaintProperty(t, e, i, r), this._update(!0) }, n.prototype.getPaintProperty = function (t, e) { return this.style.getPaintProperty(t, e) }, n.prototype.setLayoutProperty = function (t, e, i, r) { return void 0 === r && (r = {}), this.style.setLayoutProperty(t, e, i, r), this._update(!0) }, n.prototype.getLayoutProperty = function (t, e) { return this.style.getLayoutProperty(t, e) }, n.prototype.setLight = function (t, e) { return void 0 === e && (e = {}), this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0) }, n.prototype.getLight = function () { return this.style.getLight() }, n.prototype.setFeatureState = function (t, e) { return this.style.setFeatureState(t, e), this._update() }, n.prototype.removeFeatureState = function (t, e) { return this.style.removeFeatureState(t, e), this._update() }, n.prototype.getFeatureState = function (t) { return this.style.getFeatureState(t) }, n.prototype.getContainer = function () { return this._container }, n.prototype.getCanvasContainer = function () { return this._canvasContainer }, n.prototype.getCanvas = function () { return this._canvas }, n.prototype._containerDimensions = function () { var t = 0, e = 0; return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e] }, n.prototype._detectMissingCSS = function () { "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.") }, n.prototype._setupContainer = function () { var t = this._container; t.classList.add("mapboxgl-map"), (this._missingCSSCanary = i.create("div", "mapboxgl-canary", t)).style.visibility = "hidden", this._detectMissingCSS(); var e = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t); this._interactive && e.classList.add("mapboxgl-interactive"), this._canvas = i.create("canvas", "mapboxgl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"); var r = this._containerDimensions(); this._resizeCanvas(r[0], r[1]); var n = this._controlContainer = i.create("div", "mapboxgl-control-container", t), a = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach((function (t) { a[t] = i.create("div", "mapboxgl-ctrl-" + t, n) })), this._container.addEventListener("scroll", this._onMapScroll, !1) }, n.prototype._resizeCanvas = function (e, i) { var r = t.browser.devicePixelRatio || 1; this._canvas.width = r * e, this._canvas.height = r * i, this._canvas.style.width = e + "px", this._canvas.style.height = i + "px" }, n.prototype._setupPainter = function () { var i = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), r = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i); r ? (this.painter = new _r(r, this.transform), t.webpSupported.testSupport(r)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL"))) }, n.prototype._contextLost = function (e) { e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e })) }, n.prototype._contextRestored = function (e) { this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e })) }, n.prototype._onMapScroll = function (t) { if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 }, n.prototype.loaded = function () { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() }, n.prototype._update = function (t) { return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this }, n.prototype._requestRenderFrame = function (t) { return this._update(), this._renderTaskQueue.add(t) }, n.prototype._cancelRenderFrame = function (t) { this._renderTaskQueue.remove(t) }, n.prototype._render = function (e) { var i, r = this, n = 0, a = this.painter.context.extTimerQuery; if (this.listens("gpu-timing-frame") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), n = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), !this._removed) { var o = !1; if (this.style && this._styleDirty) { this._styleDirty = !1; var s = this.transform.zoom, l = t.browser.now(); this.style.zoomHistory.update(s, l); var u = new t.EvaluationParameters(s, { now: l, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), h = u.crossFadingFactor(); 1 === h && h === this._crossFadingFactor || (o = !0, this._crossFadingFactor = h), this.style.update(u) } if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || o) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) { var c = t.browser.now() - n; a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout((function () { var e = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6; a.deleteQueryEXT(i), r.fire(new t.Event("gpu-timing-frame", { cpuTime: c, gpuTime: e })) }), 50) } if (this.listens("gpu-timing-layer")) { var p = this.painter.collectGpuTimers(); setTimeout((function () { var e = r.painter.queryGpuTimers(p); r.fire(new t.Event("gpu-timing-layer", { layerTimes: e })) }), 50) } var f = this._sourcesDirty || this._styleDirty || this._placementDirty; return f || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || f || (this._fullyLoaded = !0), this } }, n.prototype.remove = function () { this._hash && this._hash.remove(); for (var e = 0, i = this._controls; e < i.length; e += 1)i[e].onRemove(this); this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1), t.window.removeEventListener("orientationchange", this._onWindowResize, !1), t.window.removeEventListener("online", this._onWindowOnline, !1)); var r = this.painter.context.gl.getExtension("WEBGL_lose_context"); r && r.loseContext(), An(this._canvasContainer), An(this._controlContainer), An(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new t.Event("remove")) }, n.prototype.triggerRepaint = function () { var e = this; this.style && !this._frame && (this._frame = t.browser.frame((function (t) { e._frame = null, e._render(t) }))) }, n.prototype._onWindowOnline = function () { this._update() }, n.prototype._onWindowResize = function (t) { this._trackResize && this.resize({ originalEvent: t })._update() }, a.showTileBoundaries.get = function () { return !!this._showTileBoundaries }, a.showTileBoundaries.set = function (t) { this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update()) }, a.showPadding.get = function () { return !!this._showPadding }, a.showPadding.set = function (t) { this._showPadding !== t && (this._showPadding = t, this._update()) }, a.showCollisionBoxes.get = function () { return !!this._showCollisionBoxes }, a.showCollisionBoxes.set = function (t) { this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update()) }, a.showOverdrawInspector.get = function () { return !!this._showOverdrawInspector }, a.showOverdrawInspector.set = function (t) { this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update()) }, a.repaint.get = function () { return !!this._repaint }, a.repaint.set = function (t) { this._repaint !== t && (this._repaint = t, this.triggerRepaint()) }, a.vertices.get = function () { return !!this._vertices }, a.vertices.set = function (t) { this._vertices = t, this._update() }, n.prototype._setCacheLimits = function (e, i) { t.setCacheLimits(e, i) }, a.version.get = function () { return t.version }, Object.defineProperties(n.prototype, a), n }(_n); function An(t) { t.parentNode && t.parentNode.removeChild(t) } var Pn = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, Cn = function (e) { var r = this; this.options = t.extend({}, Pn, e), this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (function (t) { return t.preventDefault() })), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (function (t) { return r._map.zoomIn({}, { originalEvent: t }) })), i.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (function (t) { return r._map.zoomOut({}, { originalEvent: t }) })), i.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (function (t) { r.options.visualizePitch ? r._map.resetNorthPitch({}, { originalEvent: t }) : r._map.resetNorth({}, { originalEvent: t }) })), this._compassIcon = i.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0)) }; Cn.prototype._updateZoomButtons = function () { var t = this._map.getZoom(), e = t === this._map.getMaxZoom(), i = t === this._map.getMinZoom(); this._zoomInButton.disabled = e, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", e.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString()) }, Cn.prototype._rotateCompassArrow = function () { var t = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)"; this._compassIcon.style.transform = t }, Cn.prototype.onAdd = function (t) { return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new zn(this._map, this._compass, this.options.visualizePitch)), this._container }, Cn.prototype.onRemove = function () { i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map }, Cn.prototype._createButton = function (t, e) { var r = i.create("button", t, this._container); return r.type = "button", r.addEventListener("click", e), r }, Cn.prototype._setButtonTitle = function (t, e) { var i = this._map._getUIString("NavigationControl." + e); t.title = i, t.setAttribute("aria-label", i) }; var zn = function (e, r, n) { void 0 === n && (n = !1), this._clickTolerance = 10, this.element = r, this.mouseRotate = new Xr({ clickTolerance: e.dragRotate._mouseRotate._clickTolerance }), this.map = e, n && (this.mousePitch = new Wr({ clickTolerance: e.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(r, "mousedown", this.mousedown), i.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), i.addEventListener(r, "touchmove", this.touchmove), i.addEventListener(r, "touchend", this.touchend), i.addEventListener(r, "touchcancel", this.reset) }; function kn(e, i, r) { if (e = new t.LngLat(e.lng, e.lat), i) { var n = new t.LngLat(e.lng - 360, e.lat), a = new t.LngLat(e.lng + 360, e.lat), o = r.locationPoint(e).distSqr(i); r.locationPoint(n).distSqr(i) < o ? e = n : r.locationPoint(a).distSqr(i) < o && (e = a) } for (; Math.abs(e.lng - r.center.lng) > 180;) { var s = r.locationPoint(e); if (s.x >= 0 && s.y >= 0 && s.x <= r.width && s.y <= r.height) break; e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360 } return e } zn.prototype.down = function (t, e) { this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), i.disableDrag() }, zn.prototype.move = function (t, e) { var i = this.map, r = this.mouseRotate.mousemoveWindow(t, e); if (r && r.bearingDelta && i.setBearing(i.getBearing() + r.bearingDelta), this.mousePitch) { var n = this.mousePitch.mousemoveWindow(t, e); n && n.pitchDelta && i.setPitch(i.getPitch() + n.pitchDelta) } }, zn.prototype.off = function () { var t = this.element; i.removeEventListener(t, "mousedown", this.mousedown), i.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), i.removeEventListener(t, "touchmove", this.touchmove), i.removeEventListener(t, "touchend", this.touchend), i.removeEventListener(t, "touchcancel", this.reset), this.offTemp() }, zn.prototype.offTemp = function () { i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup) }, zn.prototype.mousedown = function (e) { this.down(t.extend({}, e, { ctrlKey: !0, preventDefault: function () { return e.preventDefault() } }), i.mousePos(this.element, e)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup) }, zn.prototype.mousemove = function (t) { this.move(t, i.mousePos(this.element, t)) }, zn.prototype.mouseup = function (t) { this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp() }, zn.prototype.touchstart = function (t) { 1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function () { return t.preventDefault() } }, this._startPos)) }, zn.prototype.touchmove = function (t) { 1 !== t.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.move({ preventDefault: function () { return t.preventDefault() } }, this._lastPos)) }, zn.prototype.touchend = function (t) { 0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset() }, zn.prototype.reset = function () { this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp() }; var Ln = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Dn(t, e, i) { var r = t.classList; for (var n in Ln) r.remove("mapboxgl-" + i + "-anchor-" + n); r.add("mapboxgl-" + i + "-anchor-" + e) } var Rn, Bn = function (e) { function r(r, n) { if (e.call(this), (r instanceof t.window.HTMLElement || n) && (r = t.extend({ element: r }, n)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = r && r.anchor || "center", this._color = r && r.color || "#3FB1CE", this._scale = r && r.scale || 1, this._draggable = r && r.draggable || !1, this._clickTolerance = r && r.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = r && r.rotation || 0, this._rotationAlignment = r && r.rotationAlignment || "auto", this._pitchAlignment = r && r.pitchAlignment && "auto" !== r.pitchAlignment ? r.pitchAlignment : this._rotationAlignment, r && r.element) this._element = r.element, this._offset = t.Point.convert(r && r.offset || [0, 0]); else { this._defaultMarker = !0, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker"); var a = i.createNS("http://www.w3.org/2000/svg", "svg"); a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", "41px"), a.setAttributeNS(null, "width", "27px"), a.setAttributeNS(null, "viewBox", "0 0 27 41"); var o = i.createNS("http://www.w3.org/2000/svg", "g"); o.setAttributeNS(null, "stroke", "none"), o.setAttributeNS(null, "stroke-width", "1"), o.setAttributeNS(null, "fill", "none"), o.setAttributeNS(null, "fill-rule", "evenodd"); var s = i.createNS("http://www.w3.org/2000/svg", "g"); s.setAttributeNS(null, "fill-rule", "nonzero"); var l = i.createNS("http://www.w3.org/2000/svg", "g"); l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000"); for (var u = 0, h = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; u < h.length; u += 1) { var c = h[u], p = i.createNS("http://www.w3.org/2000/svg", "ellipse"); p.setAttributeNS(null, "opacity", "0.04"), p.setAttributeNS(null, "cx", "10.5"), p.setAttributeNS(null, "cy", "5.80029008"), p.setAttributeNS(null, "rx", c.rx), p.setAttributeNS(null, "ry", c.ry), l.appendChild(p) } var f = i.createNS("http://www.w3.org/2000/svg", "g"); f.setAttributeNS(null, "fill", this._color); var d = i.createNS("http://www.w3.org/2000/svg", "path"); d.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), f.appendChild(d); var m = i.createNS("http://www.w3.org/2000/svg", "g"); m.setAttributeNS(null, "opacity", "0.25"), m.setAttributeNS(null, "fill", "#000000"); var y = i.createNS("http://www.w3.org/2000/svg", "path"); y.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), m.appendChild(y); var g = i.createNS("http://www.w3.org/2000/svg", "g"); g.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g.setAttributeNS(null, "fill", "#FFFFFF"); var _ = i.createNS("http://www.w3.org/2000/svg", "g"); _.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); var v = i.createNS("http://www.w3.org/2000/svg", "circle"); v.setAttributeNS(null, "fill", "#000000"), v.setAttributeNS(null, "opacity", "0.25"), v.setAttributeNS(null, "cx", "5.5"), v.setAttributeNS(null, "cy", "5.5"), v.setAttributeNS(null, "r", "5.4999962"); var x = i.createNS("http://www.w3.org/2000/svg", "circle"); x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), _.appendChild(v), _.appendChild(x), s.appendChild(l), s.appendChild(f), s.appendChild(m), s.appendChild(g), s.appendChild(_), a.appendChild(s), a.setAttributeNS(null, "height", 41 * this._scale + "px"), a.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a), this._offset = t.Point.convert(r && r.offset || [0, -14]) } this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (function (t) { t.preventDefault() })), this._element.addEventListener("mousedown", (function (t) { t.preventDefault() })), Dn(this._element, this._anchor, "marker"), this._popup = null } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.addTo = function (t) { return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this }, r.prototype.remove = function () { return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this }, r.prototype.getLngLat = function () { return this._lngLat }, r.prototype.setLngLat = function (e) { return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this }, r.prototype.getElement = function () { return this._element }, r.prototype.setPopup = function (t) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) { if (!("offset" in t.options)) { var e = Math.sqrt(Math.pow(13.5, 2) / 2); t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e, -1 * (24.6 + e)], "bottom-right": [-e, -1 * (24.6 + e)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset } this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress) } return this }, r.prototype._onKeyPress = function (t) { var e = t.code, i = t.charCode || t.keyCode; "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup() }, r.prototype._onMapClick = function (t) { var e = t.originalEvent.target, i = this._element; this._popup && (e === i || i.contains(e)) && this.togglePopup() }, r.prototype.getPopup = function () { return this._popup }, r.prototype.togglePopup = function () { var t = this._popup; return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this }, r.prototype._update = function (t) { if (this._map) { this._map.transform.renderWorldCopies && (this._lngLat = kn(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset); var e = ""; "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)"); var r = ""; "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? r = "rotateX(0deg)" : "map" === this._pitchAlignment && (r = "rotateX(" + this._map.getPitch() + "deg)"), t && "moveend" !== t.type || (this._pos = this._pos.round()), i.setTransform(this._element, Ln[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + r + " " + e) } }, r.prototype.getOffset = function () { return this._offset }, r.prototype.setOffset = function (e) { return this._offset = t.Point.convert(e), this._update(), this }, r.prototype._onMove = function (e) { if (!this._isDragging) { var i = this._clickTolerance || this._map._clickTolerance; this._isDragging = e.point.dist(this._pointerdownPos) >= i } this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag"))) }, r.prototype._onUp = function () { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive" }, r.prototype._addDragHandler = function (t) { this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)) }, r.prototype.setDraggable = function (t) { return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this }, r.prototype.isDraggable = function () { return this._draggable }, r.prototype.setRotation = function (t) { return this._rotation = t || 0, this._update(), this }, r.prototype.getRotation = function () { return this._rotation }, r.prototype.setRotationAlignment = function (t) { return this._rotationAlignment = t || "auto", this._update(), this }, r.prototype.getRotationAlignment = function () { return this._rotationAlignment }, r.prototype.setPitchAlignment = function (t) { return this._pitchAlignment = t && "auto" !== t ? t : this._rotationAlignment, this._update(), this }, r.prototype.getPitchAlignment = function () { return this._pitchAlignment }, r }(t.Evented), On = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, Fn = 0, Un = !1, Nn = function (e) { function r(i) { e.call(this), this.options = t.extend({}, On, i), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this) } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.onAdd = function (e) { var r; return this._map = e, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), r = this._setupUI, void 0 !== Rn ? r(Rn) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then((function (t) { r(Rn = "denied" !== t.state) })) : r(Rn = !!t.window.navigator.geolocation), this._container }, r.prototype.onRemove = function () { void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fn = 0, Un = !1 }, r.prototype._isOutOfMapMaxBounds = function (t) { var e = this._map.getMaxBounds(), i = t.coords; return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth()) }, r.prototype._setErrorState = function () { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting") } }, r.prototype._onSuccess = function (e) { if (this._map) { if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background") }this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e)), this._finish() } }, r.prototype._updateCamera = function (e) { var i = new t.LngLat(e.coords.longitude, e.coords.latitude), r = e.coords.accuracy, n = this._map.getBearing(), a = t.extend({ bearing: n }, this.options.fitBoundsOptions); this._map.fitBounds(i.toBounds(r), a, { geolocateSource: !0 }) }, r.prototype._updateMarker = function (e) { if (e) { var i = new t.LngLat(e.coords.longitude, e.coords.latitude); this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove() }, r.prototype._updateCircleRadius = function () { var t = this._map._container.clientHeight / 2, e = this._map.unproject([0, t]), i = this._map.unproject([1, t]), r = e.distanceTo(i), n = Math.ceil(2 * this._accuracy / r); this._circleElement.style.width = n + "px", this._circleElement.style.height = n + "px" }, r.prototype._onZoom = function () { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() }, r.prototype._onError = function (e) { if (this._map) { if (this.options.trackUserLocation) if (1 === e.code) { this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; var i = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), void 0 !== this._geolocationWatchID && this._clearWatch() } else { if (3 === e.code && Un) return; this._setErrorState() } "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e)), this._finish() } }, r.prototype._finish = function () { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 }, r.prototype._setupUI = function (e) { var r = this; if (this._container.addEventListener("contextmenu", (function (t) { return t.preventDefault() })), this._geolocateButton = i.create("button", "mapboxgl-ctrl-geolocate", this._container), i.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === e) { t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled."); var n = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n) } else { var a = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a) } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Bn(this._dotElement), this._circleElement = i.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Bn({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (function (e) { e.geolocateSource || "ACTIVE_LOCK" !== r._watchState || e.originalEvent && "resize" === e.originalEvent.type || (r._watchState = "BACKGROUND", r._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), r._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), r.fire(new t.Event("trackuserlocationend"))) })) }, r.prototype.trigger = function () { if (!this._setup) return t.warnOnce("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": Fn--, Un = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart")) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "BACKGROUND": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"); break; case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error") }if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch(); else if (void 0 === this._geolocationWatchID) { var e; this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fn > 1 ? (e = { maximumAge: 6e5, timeout: 0 }, Un = !0) : (e = this.options.positionOptions, Un = !1), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e) } } else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 }, r.prototype._clearWatch = function () { t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) }, r }(t.Evented), Vn = { maxWidth: 100, unit: "metric" }, jn = function (e) { this.options = t.extend({}, Vn, e), t.bindAll(["_onMove", "setUnit"], this) }; function qn(t, e, i) { var r = i && i.maxWidth || 100, n = t._container.clientHeight / 2, a = t.unproject([0, n]), o = t.unproject([r, n]), s = a.distanceTo(o); if (i && "imperial" === i.unit) { var l = 3.2808 * s; l > 5280 ? Gn(e, r, l / 5280, t._getUIString("ScaleControl.Miles")) : Gn(e, r, l, t._getUIString("ScaleControl.Feet")) } else i && "nautical" === i.unit ? Gn(e, r, s / 1852, t._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? Gn(e, r, s / 1e3, t._getUIString("ScaleControl.Kilometers")) : Gn(e, r, s, t._getUIString("ScaleControl.Meters")) } function Gn(t, e, i, r) { var n, a, o, s = (n = i, (a = Math.pow(10, ("" + Math.floor(n)).length - 1)) * (o = (o = n / a) >= 10 ? 10 : o >= 5 ? 5 : o >= 3 ? 3 : o >= 2 ? 2 : o >= 1 ? 1 : function (t) { var e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10)); return Math.round(t * e) / e }(o))); t.style.width = e * (s / i) + "px", t.innerHTML = s + "&nbsp;" + r } jn.prototype.getDefaultPosition = function () { return "bottom-left" }, jn.prototype._onMove = function () { qn(this._map, this._container, this.options) }, jn.prototype.onAdd = function (t) { return this._map = t, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container }, jn.prototype.onRemove = function () { i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0 }, jn.prototype.setUnit = function (t) { this.options.unit = t, qn(this._map, this._container, this.options) }; var Zn = function (e) { this._fullscreen = !1, e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange") }; Zn.prototype.onAdd = function (e) { return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer }, Zn.prototype.onRemove = function () { i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon) }, Zn.prototype._checkFullscreenSupport = function () { return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled) }, Zn.prototype._setupUI = function () { var e = this._fullscreenButton = i.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer); i.create("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", !0), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon) }, Zn.prototype._updateTitle = function () { var t = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t }, Zn.prototype._getTitle = function () { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") }, Zn.prototype._isFullscreen = function () { return this._fullscreen }, Zn.prototype._changeIcon = function () { (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle()) }, Zn.prototype._onClickFullscreen = function () { this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen() }; var Xn = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, Wn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Kn = function (e) { function r(i) { e.call(this), this.options = t.extend(Object.create(Xn), i), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this) } return e && (r.__proto__ = e), (r.prototype = Object.create(e && e.prototype)).constructor = r, r.prototype.addTo = function (e) { return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this }, r.prototype.isOpen = function () { return !!this._map }, r.prototype.remove = function () { return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this }, r.prototype.getLngLat = function () { return this._lngLat }, r.prototype.setLngLat = function (e) { return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this }, r.prototype.trackPointer = function () { return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this }, r.prototype.getElement = function () { return this._container }, r.prototype.setText = function (e) { return this.setDOMContent(t.window.document.createTextNode(e)) }, r.prototype.setHTML = function (e) { var i, r = t.window.document.createDocumentFragment(), n = t.window.document.createElement("body"); for (n.innerHTML = e; i = n.firstChild;)r.appendChild(i); return this.setDOMContent(r) }, r.prototype.getMaxWidth = function () { return this._container && this._container.style.maxWidth }, r.prototype.setMaxWidth = function (t) { return this.options.maxWidth = t, this._update(), this }, r.prototype.setDOMContent = function (t) { if (this._content) for (; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = i.create("div", "mapboxgl-popup-content", this._container); return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this }, r.prototype.addClassName = function (t) { this._container && this._container.classList.add(t) }, r.prototype.removeClassName = function (t) { this._container && this._container.classList.remove(t) }, r.prototype.setOffset = function (t) { return this.options.offset = t, this._update(), this }, r.prototype.toggleClassName = function (t) { if (this._container) return this._container.classList.toggle(t) }, r.prototype._createCloseButton = function () { this.options.closeButton && (this._closeButton = i.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose)) }, r.prototype._onMouseUp = function (t) { this._update(t.point) }, r.prototype._onMouseMove = function (t) { this._update(t.point) }, r.prototype._onDrag = function (t) { this._update(t.point) }, r.prototype._update = function (e) { var r = this; if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((function (t) { return r._container.classList.add(t) })), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = kn(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e)) { var n = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat), a = this.options.anchor, o = function e(i) { if (i) { if ("number" == typeof i) { var r = Math.round(Math.sqrt(.5 * Math.pow(i, 2))); return { center: new t.Point(0, 0), top: new t.Point(0, i), "top-left": new t.Point(r, r), "top-right": new t.Point(-r, r), bottom: new t.Point(0, -i), "bottom-left": new t.Point(r, -r), "bottom-right": new t.Point(-r, -r), left: new t.Point(i, 0), right: new t.Point(-i, 0) } } if (i instanceof t.Point || Array.isArray(i)) { var n = t.Point.convert(i); return { center: n, top: n, "top-left": n, "top-right": n, bottom: n, "bottom-left": n, "bottom-right": n, left: n, right: n } } return { center: t.Point.convert(i.center || [0, 0]), top: t.Point.convert(i.top || [0, 0]), "top-left": t.Point.convert(i["top-left"] || [0, 0]), "top-right": t.Point.convert(i["top-right"] || [0, 0]), bottom: t.Point.convert(i.bottom || [0, 0]), "bottom-left": t.Point.convert(i["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(i["bottom-right"] || [0, 0]), left: t.Point.convert(i.left || [0, 0]), right: t.Point.convert(i.right || [0, 0]) } } return e(new t.Point(0, 0)) }(this.options.offset); if (!a) { var s, l = this._container.offsetWidth, u = this._container.offsetHeight; s = n.y + o.bottom.y < u ? ["top"] : n.y > this._map.transform.height - u ? ["bottom"] : [], n.x < l / 2 ? s.push("left") : n.x > this._map.transform.width - l / 2 && s.push("right"), a = 0 === s.length ? "bottom" : s.join("-") } var h = n.add(o[a]).round(); i.setTransform(this._container, Ln[a] + " translate(" + h.x + "px," + h.y + "px)"), Dn(this._container, a, "popup") } }, r.prototype._focusFirstElement = function () { if (this.options.focusAfterOpen && this._container) { var t = this._container.querySelector(Wn); t && t.focus() } }, r.prototype._onClose = function () { this.remove() }, r }(t.Evented), Hn = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: Tn, NavigationControl: Cn, GeolocateControl: Nn, AttributionControl: vn, ScaleControl: jn, FullscreenControl: Zn, Popup: Kn, Marker: Bn, Style: qe, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, prewarm: function () { Ft().acquire(Dt) }, clearPrewarmedResources: function () { var t = Bt; t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Dt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")) }, get accessToken() { return t.config.ACCESS_TOKEN }, set accessToken(e) { t.config.ACCESS_TOKEN = e }, get baseApiUrl() { return t.config.API_URL }, set baseApiUrl(e) { t.config.API_URL = e }, get workerCount() { return Rt.workerCount }, set workerCount(t) { Rt.workerCount = t }, get maxParallelImageRequests() { return t.config.MAX_PARALLEL_IMAGE_REQUESTS }, set maxParallelImageRequests(e) { t.config.MAX_PARALLEL_IMAGE_REQUESTS = e }, clearStorage: function (e) { t.clearTileCache(e) }, workerUrl: "" }; return Hn })), i }() }(pr = { exports: {} }, pr.exports), pr.exports); function dr(t) { let e; const i = t[6].default, r = o(i, t, t[5], null); return { c() { r && r.c() }, m(t, i) { r && r.m(t, i), e = !0 }, p(t, n) { r && r.p && (!e || 32 & n) && u(r, i, t, t[5], e ? l(i, t[5], n, null) : h(t[5]), null) }, i(t) { e || (G(r, t), e = !0) }, o(t) { Z(r, t), e = !1 }, d(t) { r && r.d(t) } } } function mr(t) { let e, i, r = t[0] && dr(t); return { c() { e = m("div"), r && r.c(), x(e, "class", "svelte-libsyc") }, m(n, a) { p(n, e, a), r && r.m(e, null), t[7](e), i = !0 }, p(t, [i]) { t[0] ? r ? (r.p(t, i), 1 & i && G(r, 1)) : (r = dr(t), r.c(), G(r, 1), r.m(e, null)) : r && (j(), Z(r, 1, 1, (() => { r = null })), q()) }, i(t) { i || (G(r), i = !0) }, o(t) { Z(r), i = !1 }, d(i) { i && f(e), r && r.d(), t[7](null) } } } function yr(t, e, i) { let r, n, { $$slots: a = {}, $$scope: o } = e, { location: s = { bounds: [[-5.816, 49.864], [1.863, 55.872]] } } = e, { style: l } = e, { map: u } = e, { side: h = "left" } = e; return s.bounds ? n = { bounds: s.bounds } : s.lon && s.lat && (n = { center: [s.lon, s.lat] }, s.zoom && (n.zoom = s.zoom)), "left" == h && (n.attributionControl = !1), T((() => { const t = document.createElement("link"); return t.rel = "stylesheet", t.href = "https://unpkg.com/mapbox-gl/dist/mapbox-gl.css", t.onload = () => { i(0, u = new fr.Map({ container: r, style: l, maxZoom: 17, ...n })), "left" == h ? u.addControl(new fr.AttributionControl, "bottom-left") : (u.addControl(new fr.NavigationControl({ showCompass: !1 }), "bottom-right"), u.addControl(new fr.GeolocateControl, "bottom-right")) }, document.head.appendChild(t), () => { u.remove(), t.parentNode.removeChild(t) } })), t.$$set = t => { "location" in t && i(2, s = t.location), "style" in t && i(3, l = t.style), "map" in t && i(0, u = t.map), "side" in t && i(4, h = t.side), "$$scope" in t && i(5, o = t.$$scope) }, [u, r, s, l, h, o, a, function (t) { P[t ? "unshift" : "push"]((() => { r = t, i(1, r) })) }] } class gr extends Y { constructor(t) { super(), J(this, t, yr, mr, a, { location: 2, style: 3, map: 0, side: 4 }) } } function _r(t, e, i) { const r = t.slice(); return r[20] = e[i], r } function vr(t, e, i) { const r = t.slice(); return r[20] = e[i], r } function xr(t, e, i) { const r = t.slice(); return r[20] = e[i], r } function br(t, e, i) { const r = t.slice(); return r[20] = e[i], r } function wr(e) { let i, r, n = e[20].name + ""; return { c() { i = m("option"), r = y(n), i.__value = e[20].id, i.value = i.__value }, m(t, e) { p(t, i, e), c(i, r) }, p: t, d(t) { t && f(i) } } } function Mr(t) { let e, i, a, o, s, l, u, h = t[20].name + ""; return { c() { e = m("label"), i = m("input"), a = g(), o = y(h), s = g(), x(i, "type", "checkbox"), i.__value = t[20].id, i.value = i.__value, t[8][1].push(i) }, m(r, h) { p(r, e, h), c(e, i), i.checked = ~t[0].left.overlays.indexOf(i.__value), c(e, a), c(e, o), c(e, s), l || (u = [_(i, "change", t[7]), _(i, "click", (function () { n(t[4](t[0].left, t[20].id)) && t[4](t[0].left, t[20].id).apply(this, arguments) }))], l = !0) }, p(e, r) { t = e, 1 & r && (i.checked = ~t[0].left.overlays.indexOf(i.__value)) }, d(n) { n && f(e), t[8][1].splice(t[8][1].indexOf(i), 1), l = !1, r(u) } } } function Sr(e) { let i, r, n = e[20].name + ""; return { c() { i = m("option"), r = y(n), i.__value = e[20].id, i.value = i.__value }, m(t, e) { p(t, i, e), c(i, r) }, p: t, d(t) { t && f(i) } } } function Er(t) { let e, i, a, o, s, l, u, h = t[20].name + ""; return { c() { e = m("label"), i = m("input"), a = g(), o = y(h), s = g(), x(i, "type", "checkbox"), i.__value = t[20].id, i.value = i.__value, t[8][0].push(i) }, m(r, h) { p(r, e, h), c(e, i), i.checked = ~t[0].right.overlays.indexOf(i.__value), c(e, a), c(e, o), c(e, s), l || (u = [_(i, "change", t[10]), _(i, "click", (function () { n(t[4](t[0].right, t[20].id)) && t[4](t[0].right, t[20].id).apply(this, arguments) }))], l = !0) }, p(e, r) { t = e, 1 & r && (i.checked = ~t[0].right.overlays.indexOf(i.__value)) }, d(n) { n && f(e), t[8][0].splice(t[8][0].indexOf(i), 1), l = !1, r(u) } } } function Ir(t) { let e, i, r; function n(e) { t[14](e) } let a = { $$slots: { default: [Tr] }, $$scope: { ctx: t } }; return void 0 !== t[0].container && (a.div = t[0].container), e = new cr({ props: a }), P.push((() => X(e, "div", n))), { c() { W(e.$$.fragment) }, m(t, i) { K(e, t, i), r = !0 }, p(t, r) { const n = {}; 536870915 & r && (n.$$scope = { dirty: r, ctx: t }), !i && 1 & r && (i = !0, n.div = t[0].container, R((() => i = !1))), e.$set(n) }, i(t) { r || (G(e.$$.fragment, t), r = !0) }, o(t) { Z(e.$$.fragment, t), r = !1 }, d(t) { H(e, t) } } } function Tr(t) { let e, i, r, n, a, o; function s(e) { t[12](e) } let l = { style: t[1], side: "left", location: { zoom: t[0].location[0], lon: t[0].location[1], lat: t[0].location[2] } }; function u(e) { t[13](e) } void 0 !== t[0].left.obj && (l.map = t[0].left.obj), e = new gr({ props: l }), P.push((() => X(e, "map", s))); let h = { style: t[1], side: "right", location: { zoom: t[0].location[0], lon: t[0].location[1], lat: t[0].location[2] } }; return void 0 !== t[0].right.obj && (h.map = t[0].right.obj), n = new gr({ props: h }), P.push((() => X(n, "map", u))), { c() { W(e.$$.fragment), r = g(), W(n.$$.fragment) }, m(t, i) { K(e, t, i), p(t, r, i), K(n, t, i), o = !0 }, p(t, r) { const o = {}; 2 & r && (o.style = t[1]), 1 & r && (o.location = { zoom: t[0].location[0], lon: t[0].location[1], lat: t[0].location[2] }), !i && 1 & r && (i = !0, o.map = t[0].left.obj, R((() => i = !1))), e.$set(o); const s = {}; 2 & r && (s.style = t[1]), 1 & r && (s.location = { zoom: t[0].location[0], lon: t[0].location[1], lat: t[0].location[2] }), !a && 1 & r && (a = !0, s.map = t[0].right.obj, R((() => a = !1))), n.$set(s) }, i(t) { o || (G(e.$$.fragment, t), G(n.$$.fragment, t), o = !0) }, o(t) { Z(e.$$.fragment, t), Z(n.$$.fragment, t), o = !1 }, d(t) { H(e, t), t && f(r), H(n, t) } } } function Ar(t) { let e, i, a, o, s, l, u, h, b, S, E, I, T, A, P, C, z, k = or.filter(Pr), L = []; for (let e = 0; e < k.length; e += 1)L[e] = wr(br(t, k, e)); let R = or.filter(Cr), B = []; for (let e = 0; e < R.length; e += 1)B[e] = Mr(xr(t, R, e)); let O = or.filter(zr), F = []; for (let e = 0; e < O.length; e += 1)F[e] = Sr(vr(t, O, e)); let U = or.filter(kr), N = []; for (let e = 0; e < U.length; e += 1)N[e] = Er(_r(t, U, e)); let V = t[1] && Ir(t); return { c() { e = m("div"), i = m("select"); for (let t = 0; t < L.length; t += 1)L[t].c(); a = g(); for (let t = 0; t < B.length; t += 1)B[t].c(); o = g(), s = m("div"), l = m("select"); for (let t = 0; t < F.length; t += 1)F[t].c(); u = g(); for (let t = 0; t < N.length; t += 1)N[t].c(); h = g(), b = m("form"), S = m("div"), E = m("input"), I = m("button"), I.textContent = "Go!", T = g(), V && V.c(), A = y(""), x(i, "class", "svelte-tzrjh0"), void 0 === t[0].left.base && D((() => t[6].call(i))), x(e, "id", "menu-left"), x(e, "class", "menu svelte-tzrjh0"), x(l, "class", "svelte-tzrjh0"), void 0 === t[0].right.base && D((() => t[9].call(l))), x(s, "id", "menu-right"), x(s, "class", "menu svelte-tzrjh0"), x(E, "type", "text"), x(E, "placeholder", "Find place or postcode..."), x(E, "class", "svelte-tzrjh0"), x(I, "type", "submit"), x(I, "class", "svelte-tzrjh0"), x(S, "id", "menu-search"), x(S, "class", "menu svelte-tzrjh0") }, m(r, f) { p(r, e, f), c(e, i); for (let t = 0; t < L.length; t += 1)L[t].m(i, null); M(i, t[0].left.base), c(e, a); for (let t = 0; t < B.length; t += 1)B[t].m(e, null); p(r, o, f), p(r, s, f), c(s, l); for (let t = 0; t < F.length; t += 1)F[t].m(l, null); M(l, t[0].right.base), c(s, u); for (let t = 0; t < N.length; t += 1)N[t].m(s, null); p(r, h, f), p(r, b, f), c(b, S), c(S, E), w(E, t[2]), c(S, I), p(r, T, f), V && V.m(r, f), p(r, A, f), P = !0, C || (z = [_(i, "change", t[6]), _(i, "change", (function () { n(t[3](t[0].left)) && t[3](t[0].left).apply(this, arguments) })), _(l, "change", t[9]), _(l, "change", (function () { n(t[3](t[0].right)) && t[3](t[0].right).apply(this, arguments) })), _(E, "input", t[11]), _(b, "submit", v(t[5]))], C = !0) }, p(r, [n]) { if (t = r, 0 & n) { let e; for (k = or.filter(Pr), e = 0; e < k.length; e += 1) { const r = br(t, k, e); L[e] ? L[e].p(r, n) : (L[e] = wr(r), L[e].c(), L[e].m(i, null)) } for (; e < L.length; e += 1)L[e].d(1); L.length = k.length } if (1 & n && M(i, t[0].left.base), 17 & n) { let i; for (R = or.filter(Cr), i = 0; i < R.length; i += 1) { const r = xr(t, R, i); B[i] ? B[i].p(r, n) : (B[i] = Mr(r), B[i].c(), B[i].m(e, null)) } for (; i < B.length; i += 1)B[i].d(1); B.length = R.length } if (0 & n) { let e; for (O = or.filter(zr), e = 0; e < O.length; e += 1) { const i = vr(t, O, e); F[e] ? F[e].p(i, n) : (F[e] = Sr(i), F[e].c(), F[e].m(l, null)) } for (; e < F.length; e += 1)F[e].d(1); F.length = O.length } if (1 & n && M(l, t[0].right.base), 17 & n) { let e; for (U = or.filter(kr), e = 0; e < U.length; e += 1) { const i = _r(t, U, e); N[e] ? N[e].p(i, n) : (N[e] = Er(i), N[e].c(), N[e].m(s, null)) } for (; e < N.length; e += 1)N[e].d(1); N.length = U.length } 4 & n && E.value !== t[2] && w(E, t[2]), t[1] ? V ? (V.p(t, n), 2 & n && G(V, 1)) : (V = Ir(t), V.c(), G(V, 1), V.m(A.parentNode, A)) : V && (j(), Z(V, 1, 1, (() => { V = null })), q()) }, i(t) { P || (G(V), P = !0) }, o(t) { Z(V), P = !1 }, d(t) { t && f(e), d(L, t), d(B, t), t && f(o), t && f(s), d(F, t), d(N, t), t && f(h), t && f(b), t && f(T), V && V.d(t), t && f(A), C = !1, r(z) } } } const Pr = t => !t.overlay, Cr = t => t.overlay, zr = t => !t.overlay, kr = t => t.overlay; function Lr(t, e, i) { ce.defs(ar[0], ar[1]); let r, n, a = { container: null, compare: null, location: ["7", "-1.97650", "52.97225"], left: { obj: null, base: "zoomstack-outdoor", basePrev: null, overlays: [] }, right: { obj: null, base: "os-1900", basePrev: null, overlays: [] } }, o = null; function s() { let t = location.hash, e = `#/${a.left.base}/${a.left.overlays.join(",")}/${a.right.base}/${a.right.overlays.join(",")}/${a.location.join(",")}`; t != e && (history.pushState(void 0, void 0, e), console.log("new url")) } function l() { console.log("replacing url"); let t = `#/${a.left.base}/${a.left.overlays.join(",")}/${a.right.base}/${a.right.overlays.join(",")}/${a.location.join(",")}`; history.replaceState(void 0, void 0, t) } async function u(t) { await lr(50), t.basePrev && (n[t.basePrev].forEach((e => { t.obj.getLayer(e.id) && t.obj.removeLayer(e.id) })), s()), or.find((e => e.id == t.base)) ? (n[t.base].forEach((e => { t.obj.getLayer(e.id) || t.obj.addLayer(e, "base") })), t.basePrev = t.base) : t.basePrev = t.base = null } async function h(t, e = null) { if (await lr(50), e) { let i = or.find((t => t.id == e)).middle ? "middle" : null; t.overlays.includes(e) ? (n[e].forEach((e => { t.obj.getLayer(e.id) || t.obj.addLayer(e, i) })), s()) : (n[e].forEach((e => { t.obj.getLayer(e.id) && t.obj.removeLayer(e.id) })), s()) } else t.overlays.length > 0 && t.overlays.forEach((e => { let i = or.find((t => t.id == e)); if (i) { let r = i.middle ? "middle" : null; n[e].forEach((e => { t.obj.getLayer(e.id) || t.obj.addLayer(e, r) })) } else { let i = t.overlays.indexOf(e); t.overlays.splice(i, 1) } })) } async function c() { await lr(300), a.left.obj.isStyleLoaded() && a.right.obj.isStyleLoaded() ? (u(a.left), u(a.right), h(a.left), h(a.right), console.log("updating layers"), l()) : c() } let p = "" == location.hash ? "" : location.hash.split("/"); 6 == p.length && (a.left.base = p[1], a.left.overlays = "" == p[2] ? [] : p[2].split(","), a.right.base = p[3], a.right.overlays = "" == p[4] ? [] : p[4].split(","), a.location = p[5].split(",")), async function (t, e, i) { let r = { version: 8, id: "basemaps", name: "basemaps", glyphs: e, sprite: i, sources: {}, layers: [] }, n = {}; for (const e of t) { let t = await sr(e); Object.keys(t.sources).forEach((e => { r.sources[e] || (r.sources[e] = t.sources[e]) })), n[e.id] = [], t.layers.forEach((t => { t.id = `${e.id}_${t.id}`, n[e.id].push(t) })) } return ["base", "middle"].forEach((t => { r.layers.push({ id: t, type: "background", paint: { "background-opacity": 0 } }) })), { style: r, layers: n } }(or, "https://cdn.ons.gov.uk/maptiles/osm/fontsv1/{fontstack}/{range}.pbf", "https://bothness.github.io/ons-basemaps/data/sprite").then((t => { i(1, r = t.style), n = t.layers })), window.onpopstate = () => { let t = "" == location.hash ? "" : location.hash.split("/"); if (a.left.base != t[1] && (i(0, a.left.base = t[1], a), u(a.left)), a.right.base != t[3] && (i(0, a.right.base = t[3], a), u(a.right)), a.left.overlays.join(",") != t[2]) { let e = [...a.left.overlays]; i(0, a.left.overlays = "" == t[2] ? [] : t[2].split(","), a), e.length > 0 ? e.forEach((t => { a.left.overlays.includes(t) || h(a.left, t) })) : a.left.overlays > 0 && a.left.overlays.forEach((t => { e.includes(t) || h(a.left, t) })) } if (a.right.overlays.join(",") != t[4]) { let e = [...a.right.overlays]; i(0, a.right.overlays = "" == t[4] ? [] : t[4].split(","), a), e.length > 0 ? e.forEach((t => { a.right.overlays.includes(t) || h(a.right, t) })) : a.right.overlays > 0 && a.right.overlays.forEach((t => { e.includes(t) || h(a.right, t) })) } if (a.location.join(",") != t[5]) { let e = t[5].split(","); a.left.obj.jumpTo({ zoom: e[0], center: [e[1], e[2]] }) } }; const f = [[], []]; return t.$$.update = () => { 1 & t.$$.dirty && !a.compare && a.container && a.left.obj && a.right.obj && (console.log("initialising map compare"), i(0, a.compare = new Compare(a.left.obj, a.right.obj, a.container), a), c(), a.left.obj.on("moveend", nr((() => { let t = a.left.obj.getCenter(); i(0, a.location = [a.left.obj.getZoom().toFixed(0), t.lng.toFixed(5), t.lat.toFixed(5)], a), l() }), 100))) }, [a, r, o, u, h, async function () { let t = `https://api.os.uk/search/names/v1/find?query=${o}&fq=LOCAL_TYPE:City%20LOCAL_TYPE:Town%20LOCAL_TYPE:Village%20LOCAL_TYPE:Hamlet%20LOCAL_TYPE:Suburban_Area%20LOCAL_TYPE:Other_Settlement%20LOCAL_TYPE:Postcode&maxresults=1&key=wIOFrAggpSEeCJKA1i7AfGK6VqRiCgnb`, e = await fetch(t), i = (await e.json()).results[0].GAZETTEER_ENTRY; if (i.MBR_XMIN) { let t = [i.MBR_XMIN, i.MBR_YMIN], e = [i.MBR_XMAX, i.MBR_YMAX], r = [ce("EPSG:27700", "WGS84", t), ce("EPSG:27700", "WGS84", e)]; a.left.obj.fitBounds(r), a.left.obj.once("moveend", (() => { s() })) } else { let t = { center: ce("EPSG:27700", "WGS84", [i.GEOMETRY_X, i.GEOMETRY_Y]), zoom: 15 }; a.left.obj.flyTo(t), a.left.obj.once("moveend", (() => { s() })) } }, function () { a.left.base = S(this), i(0, a) }, function () { a.left.overlays = b(f[1], this.__value, this.checked), i(0, a) }, f, function () { a.right.base = S(this), i(0, a) }, function () { a.right.overlays = b(f[0], this.__value, this.checked), i(0, a) }, function () { o = this.value, i(2, o) }, function (e) { t.$$.not_equal(a.left.obj, e) && (a.left.obj = e, i(0, a)) }, function (e) { t.$$.not_equal(a.right.obj, e) && (a.right.obj = e, i(0, a)) }, function (e) { t.$$.not_equal(a.container, e) && (a.container = e, i(0, a)) }] } return new class extends Y { constructor(t) { super(), J(this, t, Lr, Ar, a, {}) } }({ target: document.body }) }();
//# sourceMappingURL=bundle.js.map
